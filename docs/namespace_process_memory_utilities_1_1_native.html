<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ProcessMemoryUtilities.Net: ProcessMemoryUtilities.Native Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ProcessMemoryUtilities.Net
   &#160;<span id="projectnumber">1.3.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespace_process_memory_utilities_1_1_native.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a>  </div>
  <div class="headertitle">
<div class="title">ProcessMemoryUtilities.Native Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_process_memory_utilities_1_1_native_1_1_kernel32.html">Kernel32</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to some methods of kernel32.dll  <a href="class_process_memory_utilities_1_1_native_1_1_kernel32.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_process_memory_utilities_1_1_native_1_1_nt_dll.html">NtDll</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to some methods of ntdll.dll  <a href="class_process_memory_utilities_1_1_native_1_1_nt_dll.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a0729ee4af770ea067d43d9761df4cbdb"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_process_memory_utilities_1_1_native.html#a0729ee4af770ea067d43d9761df4cbdb">AllocationType</a> : uint { <br />
&#160;&#160;<a class="el" href="namespace_process_memory_utilities_1_1_native.html#a0729ee4af770ea067d43d9761df4cbdba4bbb8f967da6d1a610596d7257179c2b">AllocationType.Invalid</a> = 0, 
<a class="el" href="namespace_process_memory_utilities_1_1_native.html#a0729ee4af770ea067d43d9761df4cbdba59d5b10c3a447f036d85cb5ce524c96c">AllocationType.Commit</a> = 0x1000, 
<a class="el" href="namespace_process_memory_utilities_1_1_native.html#a0729ee4af770ea067d43d9761df4cbdba66f9c6c5b672ee16deeef6e4503cb4bc">AllocationType.Reserve</a> = 0x2000, 
<a class="el" href="namespace_process_memory_utilities_1_1_native.html#a0729ee4af770ea067d43d9761df4cbdba526d688f37a86d3c3f27d0c5016eb71d">AllocationType.Reset</a> = 0x80000, 
<br />
&#160;&#160;<a class="el" href="namespace_process_memory_utilities_1_1_native.html#a0729ee4af770ea067d43d9761df4cbdbad9504b07e71879cc2a511f9b6fcd6606">AllocationType.TopDown</a> = 0x100000, 
<a class="el" href="namespace_process_memory_utilities_1_1_native.html#a0729ee4af770ea067d43d9761df4cbdba82db37f82ef4146a02404a12cd36e5c0">AllocationType.WriteWatch</a> = 0x200000, 
<a class="el" href="namespace_process_memory_utilities_1_1_native.html#a0729ee4af770ea067d43d9761df4cbdbace898d62ed9ca7653a01fe0c781e97e9">AllocationType.Physical</a> = 0x400000, 
<a class="el" href="namespace_process_memory_utilities_1_1_native.html#a0729ee4af770ea067d43d9761df4cbdba93ddda9920613b51e016af4185c9bdfb">AllocationType.ResetUndo</a> = 0x1000000, 
<br />
&#160;&#160;<a class="el" href="namespace_process_memory_utilities_1_1_native.html#a0729ee4af770ea067d43d9761df4cbdba69339d694a14b9dad437dc487c34601d">AllocationType.LargePages</a> = 0x20000000
<br />
 }</td></tr>
<tr class="memdesc:a0729ee4af770ea067d43d9761df4cbdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the different types of memory allocations.  <a href="namespace_process_memory_utilities_1_1_native.html#a0729ee4af770ea067d43d9761df4cbdb">More...</a><br /></td></tr>
<tr class="separator:a0729ee4af770ea067d43d9761df4cbdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb58001ff27279e48c274189fcab7293"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_process_memory_utilities_1_1_native.html#adb58001ff27279e48c274189fcab7293">FreeType</a> : uint { <br />
&#160;&#160;<a class="el" href="namespace_process_memory_utilities_1_1_native.html#adb58001ff27279e48c274189fcab7293a4bbb8f967da6d1a610596d7257179c2b">FreeType.Invalid</a> = 0, 
<a class="el" href="namespace_process_memory_utilities_1_1_native.html#adb58001ff27279e48c274189fcab7293aefc95fb18e3e2bc62700b30914cd072e">FreeType.CoalescePlaceholders</a> = 0x00000001, 
<a class="el" href="namespace_process_memory_utilities_1_1_native.html#adb58001ff27279e48c274189fcab7293a88866f5d2196a28942c297c3b66a97ee">FreeType.PreservePlaceholder</a> = 0x00000002, 
<a class="el" href="namespace_process_memory_utilities_1_1_native.html#adb58001ff27279e48c274189fcab7293a0a86254d572293ae532e4a07c6f0675c">FreeType.Decommit</a> = 0x4000, 
<br />
&#160;&#160;<a class="el" href="namespace_process_memory_utilities_1_1_native.html#adb58001ff27279e48c274189fcab7293ab8e7b465df7c5979dc731d06e84ce2cf">FreeType.Release</a> = 0x8000
<br />
 }</td></tr>
<tr class="memdesc:adb58001ff27279e48c274189fcab7293"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the different types of free operations.  <a href="namespace_process_memory_utilities_1_1_native.html#adb58001ff27279e48c274189fcab7293">More...</a><br /></td></tr>
<tr class="separator:adb58001ff27279e48c274189fcab7293"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a253e5867c7af9a40486194ce6ab3cf53"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_process_memory_utilities_1_1_native.html#a253e5867c7af9a40486194ce6ab3cf53">MemoryProtectionFlags</a> : uint { <br />
&#160;&#160;<a class="el" href="namespace_process_memory_utilities_1_1_native.html#a253e5867c7af9a40486194ce6ab3cf53a4bbb8f967da6d1a610596d7257179c2b">MemoryProtectionFlags.Invalid</a> = 0, 
<a class="el" href="namespace_process_memory_utilities_1_1_native.html#a253e5867c7af9a40486194ce6ab3cf53a88a12f09800c497f30b98781952b50f2">MemoryProtectionFlags.NoAccess</a> = 0x01, 
<a class="el" href="namespace_process_memory_utilities_1_1_native.html#a253e5867c7af9a40486194ce6ab3cf53a131fb182a881796e7606ed6da27f1197">MemoryProtectionFlags.ReadOnly</a> = 0x02, 
<a class="el" href="namespace_process_memory_utilities_1_1_native.html#a253e5867c7af9a40486194ce6ab3cf53a70a2a84088d405a2e3f1e3accaa16723">MemoryProtectionFlags.ReadWrite</a> = 0x04, 
<br />
&#160;&#160;<a class="el" href="namespace_process_memory_utilities_1_1_native.html#a253e5867c7af9a40486194ce6ab3cf53a1d1f286d4bcef3fa32fb8be7682c1f35">MemoryProtectionFlags.WriteCopy</a> = 0x08, 
<a class="el" href="namespace_process_memory_utilities_1_1_native.html#a253e5867c7af9a40486194ce6ab3cf53a40cd014b7b6251e3a22e6a45a73a64e1">MemoryProtectionFlags.Execute</a> = 0x10, 
<a class="el" href="namespace_process_memory_utilities_1_1_native.html#a253e5867c7af9a40486194ce6ab3cf53ac26b597863a6aed885013205f3049c58">MemoryProtectionFlags.ExecuteRead</a> = 0x20, 
<a class="el" href="namespace_process_memory_utilities_1_1_native.html#a253e5867c7af9a40486194ce6ab3cf53ab4082047068113d3e76ff32df8842b38">MemoryProtectionFlags.ExecuteReadWrite</a> = 0x40, 
<br />
&#160;&#160;<a class="el" href="namespace_process_memory_utilities_1_1_native.html#a253e5867c7af9a40486194ce6ab3cf53aeda67591cccf6542fcd62a113dadbf81">MemoryProtectionFlags.ExecuteWriteCopy</a> = 0x80, 
<a class="el" href="namespace_process_memory_utilities_1_1_native.html#a253e5867c7af9a40486194ce6ab3cf53a0d53f148d8db8df28fc4b554bfc8ac6a">MemoryProtectionFlags.GuardModifierflag</a> = 0x100, 
<a class="el" href="namespace_process_memory_utilities_1_1_native.html#a253e5867c7af9a40486194ce6ab3cf53a366368bd9e209d231dd3761cfa5ab8c5">MemoryProtectionFlags.NoCacheModifierflag</a> = 0x200, 
<a class="el" href="namespace_process_memory_utilities_1_1_native.html#a253e5867c7af9a40486194ce6ab3cf53af64c79a7b6e638c2304cc8dfe545c90a">MemoryProtectionFlags.WriteCombineModifierflag</a> = 0x400
<br />
 }</td></tr>
<tr class="memdesc:a253e5867c7af9a40486194ce6ab3cf53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the memory protection constants.  <a href="namespace_process_memory_utilities_1_1_native.html#a253e5867c7af9a40486194ce6ab3cf53">More...</a><br /></td></tr>
<tr class="separator:a253e5867c7af9a40486194ce6ab3cf53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41790de5ba730eef87a43be26a6ca771"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_process_memory_utilities_1_1_native.html#a41790de5ba730eef87a43be26a6ca771">NtStatus</a> : uint { <br />
&#160;&#160;<a class="el" href="namespace_process_memory_utilities_1_1_native.html#a41790de5ba730eef87a43be26a6ca771ad0749aaba8b833466dfcbb0428e4f89c">NtStatus.SUCCESS</a> = 0x0, 
<a class="el" href="namespace_process_memory_utilities_1_1_native.html#a41790de5ba730eef87a43be26a6ca771a832032de0dab53d762e9585c9ad29ab2">NtStatus.DATATYPE_MISALIGNMENT</a> = 0x80000002u, 
<a class="el" href="namespace_process_memory_utilities_1_1_native.html#a41790de5ba730eef87a43be26a6ca771a7578294c2394177f6fe01cda0999570a">NtStatus.PARTIAL_COPY</a> = 0x8000000Du, 
<a class="el" href="namespace_process_memory_utilities_1_1_native.html#a41790de5ba730eef87a43be26a6ca771abc92e41646f576dd909e4d0fcf22b933">NtStatus.ACCESS_VIOLATION</a> = 0xC0000005u, 
<br />
&#160;&#160;<a class="el" href="namespace_process_memory_utilities_1_1_native.html#a41790de5ba730eef87a43be26a6ca771a91bf81a15031ab01510ec064d6004db5">NtStatus.INVALID_HANDLE</a> = 0xC0000008u, 
<a class="el" href="namespace_process_memory_utilities_1_1_native.html#a41790de5ba730eef87a43be26a6ca771a2eaec33b2d6224f90e7222e4b7a49183">NtStatus.ACCESS_DENIED</a> = 0xC0000022u, 
<a class="el" href="namespace_process_memory_utilities_1_1_native.html#a41790de5ba730eef87a43be26a6ca771ab1f8483a215dbe1f25758d255986835c">NtStatus.OBJECT_TYPE_MISMATCH</a> = 0xC0000024u, 
<a class="el" href="namespace_process_memory_utilities_1_1_native.html#a41790de5ba730eef87a43be26a6ca771a65d1d6f48a10e5dd3ec58098e285ada6">NtStatus.INSUFFICIENT_RESOURCES</a> = 0xC000009Au, 
<br />
&#160;&#160;<a class="el" href="namespace_process_memory_utilities_1_1_native.html#a41790de5ba730eef87a43be26a6ca771a8978834081ef19e57f9317a10fcf5a95">NtStatus.PROCESS_IS_TERMINATING</a> = 0xC000010Au
<br />
 }</td></tr>
<tr class="memdesc:a41790de5ba730eef87a43be26a6ca771"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains all NTSTATUS codes that could possibly happen when using this library. These may be incomplete.  <a href="namespace_process_memory_utilities_1_1_native.html#a41790de5ba730eef87a43be26a6ca771">More...</a><br /></td></tr>
<tr class="separator:a41790de5ba730eef87a43be26a6ca771"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdfccb438f768cae26c138a43489d2ff"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_process_memory_utilities_1_1_native.html#abdfccb438f768cae26c138a43489d2ff">ProcessAccessFlags</a> : uint { <br />
&#160;&#160;<a class="el" href="namespace_process_memory_utilities_1_1_native.html#abdfccb438f768cae26c138a43489d2ffa4bbb8f967da6d1a610596d7257179c2b">ProcessAccessFlags.Invalid</a> = 0, 
<a class="el" href="namespace_process_memory_utilities_1_1_native.html#abdfccb438f768cae26c138a43489d2ffa056fa3d840f48b7bfbbd68c19a4797b3">ProcessAccessFlags.Terminate</a> = 0x00000001, 
<a class="el" href="namespace_process_memory_utilities_1_1_native.html#abdfccb438f768cae26c138a43489d2ffad4b9bd5e20476116593b8b68fb08bf57">ProcessAccessFlags.CreateThread</a> = 0x00000002, 
<a class="el" href="namespace_process_memory_utilities_1_1_native.html#abdfccb438f768cae26c138a43489d2ffac9baacf6cca6c54626e594639081177f">ProcessAccessFlags.Allocate</a> = VirtualMemoryOperation, 
<br />
&#160;&#160;<a class="el" href="namespace_process_memory_utilities_1_1_native.html#abdfccb438f768cae26c138a43489d2ffa03fce4e381fb206d3b66fa0efeaa65b9">ProcessAccessFlags.VirtualMemoryOperation</a> = 0x00000008, 
<a class="el" href="namespace_process_memory_utilities_1_1_native.html#abdfccb438f768cae26c138a43489d2ffa7a1a5f3e79fdc91edf2f5ead9d66abb4">ProcessAccessFlags.Read</a> = VirtualMemoryRead, 
<a class="el" href="namespace_process_memory_utilities_1_1_native.html#abdfccb438f768cae26c138a43489d2ffa1097d94adf1ffb4f72859958d1e143fc">ProcessAccessFlags.VirtualMemoryRead</a> = 0x00000010, 
<a class="el" href="namespace_process_memory_utilities_1_1_native.html#abdfccb438f768cae26c138a43489d2ffad81b2f1b0d561c67eac1cfb40ee3b092">ProcessAccessFlags.VirtualMemoryWrite</a> = 0x00000020, 
<br />
&#160;&#160;<a class="el" href="namespace_process_memory_utilities_1_1_native.html#abdfccb438f768cae26c138a43489d2ffa1129c0e4d43f2d121652a7302712cff6">ProcessAccessFlags.Write</a> = VirtualMemoryWrite | VirtualMemoryOperation, 
<a class="el" href="namespace_process_memory_utilities_1_1_native.html#abdfccb438f768cae26c138a43489d2ffa70a2a84088d405a2e3f1e3accaa16723">ProcessAccessFlags.ReadWrite</a> = VirtualMemoryRead | VirtualMemoryWrite | VirtualMemoryOperation, 
<a class="el" href="namespace_process_memory_utilities_1_1_native.html#abdfccb438f768cae26c138a43489d2ffa14433c840778ea3194b1d7642df60317">ProcessAccessFlags.DuplicateHandle</a> = 0x00000040, 
<a class="el" href="namespace_process_memory_utilities_1_1_native.html#abdfccb438f768cae26c138a43489d2ffac6b59bdabc4d10b6cd98e97dbd071549">ProcessAccessFlags.CreateProcess</a> = 0x000000080, 
<br />
&#160;&#160;<a class="el" href="namespace_process_memory_utilities_1_1_native.html#abdfccb438f768cae26c138a43489d2ffacd7befb4aef8f46bbb823af1d99cde83">ProcessAccessFlags.SetQuota</a> = 0x00000100, 
<a class="el" href="namespace_process_memory_utilities_1_1_native.html#abdfccb438f768cae26c138a43489d2ffafd76c8a174c8459590eb48380c4edc40">ProcessAccessFlags.SetInformation</a> = 0x00000200, 
<a class="el" href="namespace_process_memory_utilities_1_1_native.html#abdfccb438f768cae26c138a43489d2ffa37e8a064723ac3f5eec1e7482f5037f7">ProcessAccessFlags.QueryInformation</a> = 0x00000400, 
<a class="el" href="namespace_process_memory_utilities_1_1_native.html#abdfccb438f768cae26c138a43489d2ffa225c7a85340534236811e3cae22e885e">ProcessAccessFlags.SuspendResume</a> = 0x0800, 
<br />
&#160;&#160;<a class="el" href="namespace_process_memory_utilities_1_1_native.html#abdfccb438f768cae26c138a43489d2ffa2bb5376eb8926e511abaa1f99fed558c">ProcessAccessFlags.QueryLimitedInformation</a> = 0x00001000, 
<a class="el" href="namespace_process_memory_utilities_1_1_native.html#abdfccb438f768cae26c138a43489d2ffaa82be0f551b8708bc08eb33cd9ded0cf">ProcessAccessFlags.Information</a> = QueryInformation | QueryLimitedInformation, 
<a class="el" href="namespace_process_memory_utilities_1_1_native.html#abdfccb438f768cae26c138a43489d2ffa40cd014b7b6251e3a22e6a45a73a64e1">ProcessAccessFlags.Execute</a> = VirtualMemoryRead | VirtualMemoryWrite | VirtualMemoryOperation | QueryInformation | QueryLimitedInformation | CreateThread, 
<a class="el" href="namespace_process_memory_utilities_1_1_native.html#abdfccb438f768cae26c138a43489d2ffab18b960c57a784907dc1cd97ba8a8065">ProcessAccessFlags.Synchronize</a> = 0x00100000, 
<br />
&#160;&#160;<a class="el" href="namespace_process_memory_utilities_1_1_native.html#abdfccb438f768cae26c138a43489d2ffab1c94ca2fbc3e78fc30069c8d0f01680">ProcessAccessFlags.All</a> = 0x001FFFFF
<br />
 }</td></tr>
<tr class="memdesc:abdfccb438f768cae26c138a43489d2ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines process security and access rights.  <a href="namespace_process_memory_utilities_1_1_native.html#abdfccb438f768cae26c138a43489d2ff">More...</a><br /></td></tr>
<tr class="separator:abdfccb438f768cae26c138a43489d2ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28a597a806a5662bfe6ef8a30725f3f6"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_process_memory_utilities_1_1_native.html#a28a597a806a5662bfe6ef8a30725f3f6">ThreadCreationFlags</a> : uint { <a class="el" href="namespace_process_memory_utilities_1_1_native.html#a28a597a806a5662bfe6ef8a30725f3f6afd83e0ccb3e6312a62f888dd496dd0a5">ThreadCreationFlags.Immediately</a> = 0, 
<a class="el" href="namespace_process_memory_utilities_1_1_native.html#a28a597a806a5662bfe6ef8a30725f3f6a8bf906833cc7aea8084f552217ed9c1d">ThreadCreationFlags.Suspended</a> = 0x4, 
<a class="el" href="namespace_process_memory_utilities_1_1_native.html#a28a597a806a5662bfe6ef8a30725f3f6af07c7c4657761b4e01a2ab20ed51855b">ThreadCreationFlags.StackSizeParamIsAReservation</a> = 0x10000
 }</td></tr>
<tr class="memdesc:a28a597a806a5662bfe6ef8a30725f3f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines flags that control the creation of a remote thread.  <a href="namespace_process_memory_utilities_1_1_native.html#a28a597a806a5662bfe6ef8a30725f3f6">More...</a><br /></td></tr>
<tr class="separator:a28a597a806a5662bfe6ef8a30725f3f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06054dd813bba2514407e29f39095dd7"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_process_memory_utilities_1_1_native.html#a06054dd813bba2514407e29f39095dd7">WaitObjectResult</a> : uint { <a class="el" href="namespace_process_memory_utilities_1_1_native.html#a06054dd813bba2514407e29f39095dd7a505a83f220c02df2f85c3810cd9ceb38">WaitObjectResult.Success</a> = 0x0, 
<a class="el" href="namespace_process_memory_utilities_1_1_native.html#a06054dd813bba2514407e29f39095dd7a255de8cd6ee11ed4dc01a19844c1271e">WaitObjectResult.Abandoned</a> = 0x80, 
<a class="el" href="namespace_process_memory_utilities_1_1_native.html#a06054dd813bba2514407e29f39095dd7ac85a251cc457840f1e032f1b733e9398">WaitObjectResult.Timeout</a> = 0x102, 
<a class="el" href="namespace_process_memory_utilities_1_1_native.html#a06054dd813bba2514407e29f39095dd7ad7c8c85bf79bbe1b7188497c32c3b0ca">WaitObjectResult.Failed</a> = 0xFFFFFFFF
 }</td></tr>
<tr class="memdesc:a06054dd813bba2514407e29f39095dd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the events that cause a function like WaitForSingleObject to return.  <a href="namespace_process_memory_utilities_1_1_native.html#a06054dd813bba2514407e29f39095dd7">More...</a><br /></td></tr>
<tr class="separator:a06054dd813bba2514407e29f39095dd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a0729ee4af770ea067d43d9761df4cbdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0729ee4af770ea067d43d9761df4cbdb">&#9670;&nbsp;</a></span>AllocationType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespace_process_memory_utilities_1_1_native.html#a0729ee4af770ea067d43d9761df4cbdb">ProcessMemoryUtilities.Native.AllocationType</a> : uint</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Defines the different types of memory allocations. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a0729ee4af770ea067d43d9761df4cbdba4bbb8f967da6d1a610596d7257179c2b"></a>Invalid&#160;</td><td class="fielddoc"><p>An invalid value. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0729ee4af770ea067d43d9761df4cbdba59d5b10c3a447f036d85cb5ce524c96c"></a>Commit&#160;</td><td class="fielddoc"><p>Allocates memory charges (from the overall size of memory and the paging files on disk) for the specified reserved memory pages. The function also guarantees that when the caller later initially accesses the memory, the contents will be zero. Actual physical pages are not allocated unless/until the virtual addresses are actually accessed. To reserve and commit pages in one step, call VirtualAllocEx with MEM_COMMIT | MEM_RESERVE. Attempting to commit a specific address range by specifying MEM_COMMIT without MEM_RESERVE and a non-NULL lpAddress fails unless the entire range has already been reserved. The resulting error code is ERROR_INVALID_ADDRESS. An attempt to commit a page that is already committed does not cause the function to fail. This means that you can commit pages without first determining the current commitment state of each page. If lpAddress specifies an address within an enclave, flAllocationType must be MEM_COMMIT. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0729ee4af770ea067d43d9761df4cbdba66f9c6c5b672ee16deeef6e4503cb4bc"></a>Reserve&#160;</td><td class="fielddoc"><p>Reserves a range of the process's virtual address space without allocating any actual physical storage in memory or in the paging file on disk. You commit reserved pages by calling VirtualAllocEx again with MEM_COMMIT. To reserve and commit pages in one step, call VirtualAllocEx with MEM_COMMIT | MEM_RESERVE. Other memory allocation functions, such as malloc and LocalAlloc, cannot use reserved memory until it has been released. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0729ee4af770ea067d43d9761df4cbdba526d688f37a86d3c3f27d0c5016eb71d"></a>Reset&#160;</td><td class="fielddoc"><p>Indicates that data in the memory range specified by lpAddress and dwSize is no longer of interest. The pages should not be read from or written to the paging file. However, the memory block will be used again later, so it should not be decommitted. This value cannot be used with any other value. Using this value does not guarantee that the range operated on with MEM_RESET will contain zeros. If you want the range to contain zeros, decommit the memory and then recommit it. When you use MEM_RESET, the VirtualAllocEx function ignores the value of fProtect. However, you must still set fProtect to a valid protection value, such as PAGE_NOACCESS. VirtualAllocEx returns an error if you use MEM_RESET and the range of memory is mapped to a file. A shared view is only acceptable if it is mapped to a paging file. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0729ee4af770ea067d43d9761df4cbdbad9504b07e71879cc2a511f9b6fcd6606"></a>TopDown&#160;</td><td class="fielddoc"><p>Allocates memory at the highest possible address. This can be slower than regular allocations, especially when there are many allocations. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0729ee4af770ea067d43d9761df4cbdba82db37f82ef4146a02404a12cd36e5c0"></a>WriteWatch&#160;</td><td class="fielddoc"><p>Causes the system to track pages that are written to in the allocated region. If you specify this value, you must also specify MEM_RESERVE. To retrieve the addresses of the pages that have been written to since the region was allocated or the write-tracking state was reset, call the GetWriteWatch function. To reset the write-tracking state, call GetWriteWatch or ResetWriteWatch. The write-tracking feature remains enabled for the memory region until the region is freed. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0729ee4af770ea067d43d9761df4cbdbace898d62ed9ca7653a01fe0c781e97e9"></a>Physical&#160;</td><td class="fielddoc"><p>Reserves an address range that can be used to map Address Windowing Extensions (AWE) pages. This value must be used with MEM_RESERVE and no other values. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0729ee4af770ea067d43d9761df4cbdba93ddda9920613b51e016af4185c9bdfb"></a>ResetUndo&#160;</td><td class="fielddoc"><p>MEM_RESET_UNDO should only be called on an address range to which MEM_RESET was successfully applied earlier. It indicates that the data in the specified memory range specified by lpAddress and dwSize is of interest to the caller and attempts to reverse the effects of MEM_RESET. If the function succeeds, that means all data in the specified address range is intact. If the function fails, at least some of the data in the address range has been replaced with zeroes. This value cannot be used with any other value. If MEM_RESET_UNDO is called on an address range which was not MEM_RESET earlier, the behavior is undefined. When you specify MEM_RESET, the VirtualAllocEx function ignores the value of flProtect. However, you must still set flProtect to a valid protection value, such as PAGE_NOACCESS. Windows Server 2008 R2, Windows 7, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP: The MEM_RESET_UNDO flag is not supported until Windows 8 and Windows Server 2012. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0729ee4af770ea067d43d9761df4cbdba69339d694a14b9dad437dc487c34601d"></a>LargePages&#160;</td><td class="fielddoc"><p>Allocates memory using large page support. The size and alignment must be a multiple of the large-page minimum. To obtain this value, use the GetLargePageMinimum function. If you specify this value, you must also specify MEM_RESERVE and MEM_COMMIT. </p>
</td></tr>
</table>

</div>
</div>
<a id="adb58001ff27279e48c274189fcab7293"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb58001ff27279e48c274189fcab7293">&#9670;&nbsp;</a></span>FreeType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespace_process_memory_utilities_1_1_native.html#adb58001ff27279e48c274189fcab7293">ProcessMemoryUtilities.Native.FreeType</a> : uint</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Defines the different types of free operations. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="adb58001ff27279e48c274189fcab7293a4bbb8f967da6d1a610596d7257179c2b"></a>Invalid&#160;</td><td class="fielddoc"><p>An invalid value. </p>
</td></tr>
<tr><td class="fieldname"><a id="adb58001ff27279e48c274189fcab7293aefc95fb18e3e2bc62700b30914cd072e"></a>CoalescePlaceholders&#160;</td><td class="fielddoc"><p>To coalesce two adjacent placeholders, specify MEM_RELEASE | MEM_COALESCE_PLACEHOLDERS. When you coalesce placeholders, lpAddress and dwSize must exactly match those of the placeholder. </p>
</td></tr>
<tr><td class="fieldname"><a id="adb58001ff27279e48c274189fcab7293a88866f5d2196a28942c297c3b66a97ee"></a>PreservePlaceholder&#160;</td><td class="fielddoc"><p>Frees an allocation back to a placeholder (after you've replaced a placeholder with a private allocation using VirtualAlloc2 or Virtual2AllocFromApp). To split a placeholder into two placeholders, specify MEM_RELEASE | MEM_PRESERVE_PLACEHOLDER. </p>
</td></tr>
<tr><td class="fieldname"><a id="adb58001ff27279e48c274189fcab7293a0a86254d572293ae532e4a07c6f0675c"></a>Decommit&#160;</td><td class="fielddoc"><p>Decommits the specified region of committed pages. After the operation, the pages are in the reserved state. The function does not fail if you attempt to decommit an uncommitted page. This means that you can decommit a range of pages without first determining their current commitment state. Do not use this value with MEM_RELEASE. The MEM_DECOMMIT value is not supported when the lpAddress parameter provides the base address for an enclave. </p>
</td></tr>
<tr><td class="fieldname"><a id="adb58001ff27279e48c274189fcab7293ab8e7b465df7c5979dc731d06e84ce2cf"></a>Release&#160;</td><td class="fielddoc"><p>Releases the specified region of pages, or placeholder (for a placeholder, the address space is released and available for other allocations). After the operation, the pages are in the free state. If you specify this value, dwSize must be 0 (zero), and lpAddress must point to the base address returned by the VirtualAllocEx function when the region is reserved. The function fails if either of these conditions is not met. If any pages in the region are committed currently, the function first decommits, and then releases them. The function does not fail if you attempt to release pages that are in different states, some reserved and some committed. This means that you can release a range of pages without first determining the current commitment state. Do not use this value with MEM_DECOMMIT. </p>
</td></tr>
</table>

</div>
</div>
<a id="a253e5867c7af9a40486194ce6ab3cf53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a253e5867c7af9a40486194ce6ab3cf53">&#9670;&nbsp;</a></span>MemoryProtectionFlags</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespace_process_memory_utilities_1_1_native.html#a253e5867c7af9a40486194ce6ab3cf53">ProcessMemoryUtilities.Native.MemoryProtectionFlags</a> : uint</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Defines the memory protection constants. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a253e5867c7af9a40486194ce6ab3cf53a4bbb8f967da6d1a610596d7257179c2b"></a>Invalid&#160;</td><td class="fielddoc"><p>An invalid value. </p>
</td></tr>
<tr><td class="fieldname"><a id="a253e5867c7af9a40486194ce6ab3cf53a88a12f09800c497f30b98781952b50f2"></a>NoAccess&#160;</td><td class="fielddoc"><p>Disables all access to the committed region of pages. An attempt to read from, write to, or execute the committed region results in an access violation. This flag is not supported by the CreateFileMapping function. </p>
</td></tr>
<tr><td class="fieldname"><a id="a253e5867c7af9a40486194ce6ab3cf53a131fb182a881796e7606ed6da27f1197"></a>ReadOnly&#160;</td><td class="fielddoc"><p>Enables read-only access to the committed region of pages. An attempt to write to the committed region results in an access violation. If Data Execution Prevention is enabled, an attempt to execute code in the committed region results in an access violation. </p>
</td></tr>
<tr><td class="fieldname"><a id="a253e5867c7af9a40486194ce6ab3cf53a70a2a84088d405a2e3f1e3accaa16723"></a>ReadWrite&#160;</td><td class="fielddoc"><p>Enables read-only or read/write access to the committed region of pages. If Data Execution Prevention is enabled, attempting to execute code in the committed region results in an access violation. </p>
</td></tr>
<tr><td class="fieldname"><a id="a253e5867c7af9a40486194ce6ab3cf53a1d1f286d4bcef3fa32fb8be7682c1f35"></a>WriteCopy&#160;</td><td class="fielddoc"><p>Enables read-only or copy-on-write access to a mapped view of a file mapping object. An attempt to write to a committed copy-on-write page results in a private copy of the page being made for the process. The private page is marked as PAGE_READWRITE, and the change is written to the new page. If Data Execution Prevention is enabled, attempting to execute code in the committed region results in an access violation. This flag is not supported by the VirtualAlloc or VirtualAllocEx functions. </p>
</td></tr>
<tr><td class="fieldname"><a id="a253e5867c7af9a40486194ce6ab3cf53a40cd014b7b6251e3a22e6a45a73a64e1"></a>Execute&#160;</td><td class="fielddoc"><p>Enables execute access to the committed region of pages. An attempt to write to the committed region results in an access violation. This flag is not supported by the CreateFileMapping function. </p>
</td></tr>
<tr><td class="fieldname"><a id="a253e5867c7af9a40486194ce6ab3cf53ac26b597863a6aed885013205f3049c58"></a>ExecuteRead&#160;</td><td class="fielddoc"><p>Enables execute or read-only access to the committed region of pages. An attempt to write to the committed region results in an access violation. Windows Server 2003 and Windows XP: This attribute is not supported by the CreateFileMapping function until Windows XP with SP2 and Windows Server 2003 with SP1. </p>
</td></tr>
<tr><td class="fieldname"><a id="a253e5867c7af9a40486194ce6ab3cf53ab4082047068113d3e76ff32df8842b38"></a>ExecuteReadWrite&#160;</td><td class="fielddoc"><p>Enables execute, read-only, or read/write access to the committed region of pages. Windows Server 2003 and Windows XP: This attribute is not supported by the CreateFileMapping function until Windows XP with SP2 and Windows Server 2003 with SP1. </p>
</td></tr>
<tr><td class="fieldname"><a id="a253e5867c7af9a40486194ce6ab3cf53aeda67591cccf6542fcd62a113dadbf81"></a>ExecuteWriteCopy&#160;</td><td class="fielddoc"><p>Enables execute, read-only, or copy-on-write access to a mapped view of a file mapping object. An attempt to write to a committed copy-on-write page results in a private copy of the page being made for the process. The private page is marked as PAGE_EXECUTE_READWRITE, and the change is written to the new page. This flag is not supported by the VirtualAlloc or VirtualAllocEx functions. Windows Vista, Windows Server 2003 and Windows XP: This attribute is not supported by the CreateFileMapping function until Windows Vista with SP1 and Windows Server 2008. </p>
</td></tr>
<tr><td class="fieldname"><a id="a253e5867c7af9a40486194ce6ab3cf53a0d53f148d8db8df28fc4b554bfc8ac6a"></a>GuardModifierflag&#160;</td><td class="fielddoc"><p>Pages in the region become guard pages. Any attempt to access a guard page causes the system to raise a STATUS_GUARD_PAGE_VIOLATION exception and turn off the guard page status. Guard pages thus act as a one-time access alarm. For more information, see Creating Guard Pages. When an access attempt leads the system to turn off guard page status, the underlying page protection takes over. If a guard page exception occurs during a system service, the service typically returns a failure status indicator. This value cannot be used with PAGE_NOACCESS. This flag is not supported by the CreateFileMapping function. </p>
</td></tr>
<tr><td class="fieldname"><a id="a253e5867c7af9a40486194ce6ab3cf53a366368bd9e209d231dd3761cfa5ab8c5"></a>NoCacheModifierflag&#160;</td><td class="fielddoc"><p>Sets all pages to be non-cachable. Applications should not use this attribute except when explicitly required for a device. Using the interlocked functions with memory that is mapped with SEC_NOCACHE can result in an EXCEPTION_ILLEGAL_INSTRUCTION exception. The PAGE_NOCACHE flag cannot be used with the PAGE_GUARD, PAGE_NOACCESS, or PAGE_WRITECOMBINE flags. The PAGE_NOCACHE flag can be used only when allocating private memory with the VirtualAlloc, VirtualAllocEx, or VirtualAllocExNuma functions. To enable non-cached memory access for shared memory, specify the SEC_NOCACHE flag when calling the CreateFileMapping function. </p>
</td></tr>
<tr><td class="fieldname"><a id="a253e5867c7af9a40486194ce6ab3cf53af64c79a7b6e638c2304cc8dfe545c90a"></a>WriteCombineModifierflag&#160;</td><td class="fielddoc"><p>Sets all pages to be write-combined. Applications should not use this attribute except when explicitly required for a device. Using the interlocked functions with memory that is mapped as write-combined can result in an EXCEPTION_ILLEGAL_INSTRUCTION exception. The PAGE_WRITECOMBINE flag cannot be specified with the PAGE_NOACCESS, PAGE_GUARD, and PAGE_NOCACHE flags. The PAGE_WRITECOMBINE flag can be used only when allocating private memory with the VirtualAlloc, VirtualAllocEx, or VirtualAllocExNuma functions. To enable write-combined memory access for shared memory, specify the SEC_WRITECOMBINE flag when calling the CreateFileMapping function. Windows Server 2003 and Windows XP: This flag is not supported until Windows Server 2003 with SP1. </p>
</td></tr>
</table>

</div>
</div>
<a id="a41790de5ba730eef87a43be26a6ca771"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41790de5ba730eef87a43be26a6ca771">&#9670;&nbsp;</a></span>NtStatus</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespace_process_memory_utilities_1_1_native.html#a41790de5ba730eef87a43be26a6ca771">ProcessMemoryUtilities.Native.NtStatus</a> : uint</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Contains all NTSTATUS codes that could possibly happen when using this library. These may be incomplete. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a41790de5ba730eef87a43be26a6ca771ad0749aaba8b833466dfcbb0428e4f89c"></a>SUCCESS&#160;</td><td class="fielddoc"><p>STATUS_SUCCESS </p>
</td></tr>
<tr><td class="fieldname"><a id="a41790de5ba730eef87a43be26a6ca771a832032de0dab53d762e9585c9ad29ab2"></a>DATATYPE_MISALIGNMENT&#160;</td><td class="fielddoc"><p>A datatype misalignment was detected in a load or store instruction. </p>
</td></tr>
<tr><td class="fieldname"><a id="a41790de5ba730eef87a43be26a6ca771a7578294c2394177f6fe01cda0999570a"></a>PARTIAL_COPY&#160;</td><td class="fielddoc"><p>Due to protection conflicts not all the requested bytes could be copied. </p>
</td></tr>
<tr><td class="fieldname"><a id="a41790de5ba730eef87a43be26a6ca771abc92e41646f576dd909e4d0fcf22b933"></a>ACCESS_VIOLATION&#160;</td><td class="fielddoc"><p>The instruction at 0xp referenced memory at 0xp. The memory could not be s. </p>
</td></tr>
<tr><td class="fieldname"><a id="a41790de5ba730eef87a43be26a6ca771a91bf81a15031ab01510ec064d6004db5"></a>INVALID_HANDLE&#160;</td><td class="fielddoc"><p>An invalid HANDLE was specified. </p>
</td></tr>
<tr><td class="fieldname"><a id="a41790de5ba730eef87a43be26a6ca771a2eaec33b2d6224f90e7222e4b7a49183"></a>ACCESS_DENIED&#160;</td><td class="fielddoc"><p>A process has requested access to an object, but has not been granted those access rights. </p>
</td></tr>
<tr><td class="fieldname"><a id="a41790de5ba730eef87a43be26a6ca771ab1f8483a215dbe1f25758d255986835c"></a>OBJECT_TYPE_MISMATCH&#160;</td><td class="fielddoc"><p>There is a mismatch between the type of object required by the requested operation and the type of object that is specified in the request. </p>
</td></tr>
<tr><td class="fieldname"><a id="a41790de5ba730eef87a43be26a6ca771a65d1d6f48a10e5dd3ec58098e285ada6"></a>INSUFFICIENT_RESOURCES&#160;</td><td class="fielddoc"><p>Insufficient system resources exist to complete the API. </p>
</td></tr>
<tr><td class="fieldname"><a id="a41790de5ba730eef87a43be26a6ca771a8978834081ef19e57f9317a10fcf5a95"></a>PROCESS_IS_TERMINATING&#160;</td><td class="fielddoc"><p>An attempt was made to access an exiting process. </p>
</td></tr>
</table>

</div>
</div>
<a id="abdfccb438f768cae26c138a43489d2ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdfccb438f768cae26c138a43489d2ff">&#9670;&nbsp;</a></span>ProcessAccessFlags</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespace_process_memory_utilities_1_1_native.html#abdfccb438f768cae26c138a43489d2ff">ProcessMemoryUtilities.Native.ProcessAccessFlags</a> : uint</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Defines process security and access rights. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="abdfccb438f768cae26c138a43489d2ffa4bbb8f967da6d1a610596d7257179c2b"></a>Invalid&#160;</td><td class="fielddoc"><p>An invalid value. </p>
</td></tr>
<tr><td class="fieldname"><a id="abdfccb438f768cae26c138a43489d2ffa056fa3d840f48b7bfbbd68c19a4797b3"></a>Terminate&#160;</td><td class="fielddoc"><p>Required to terminate a process using TerminateProcess. </p>
</td></tr>
<tr><td class="fieldname"><a id="abdfccb438f768cae26c138a43489d2ffad4b9bd5e20476116593b8b68fb08bf57"></a>CreateThread&#160;</td><td class="fielddoc"><p>Required to create a thread. </p>
</td></tr>
<tr><td class="fieldname"><a id="abdfccb438f768cae26c138a43489d2ffac9baacf6cca6c54626e594639081177f"></a>Allocate&#160;</td><td class="fielddoc"><p>Required to allocate memory in the address space of another process. </p>
</td></tr>
<tr><td class="fieldname"><a id="abdfccb438f768cae26c138a43489d2ffa03fce4e381fb206d3b66fa0efeaa65b9"></a>VirtualMemoryOperation&#160;</td><td class="fielddoc"><p>Required to perform an operation on the address space of a process (see VirtualProtectEx and WriteProcessMemory). </p>
</td></tr>
<tr><td class="fieldname"><a id="abdfccb438f768cae26c138a43489d2ffa7a1a5f3e79fdc91edf2f5ead9d66abb4"></a>Read&#160;</td><td class="fielddoc"><p>Required to read memory in a process using ReadProcessMemory. </p>
</td></tr>
<tr><td class="fieldname"><a id="abdfccb438f768cae26c138a43489d2ffa1097d94adf1ffb4f72859958d1e143fc"></a>VirtualMemoryRead&#160;</td><td class="fielddoc"><p>Required to read memory in a process using ReadProcessMemory. </p>
</td></tr>
<tr><td class="fieldname"><a id="abdfccb438f768cae26c138a43489d2ffad81b2f1b0d561c67eac1cfb40ee3b092"></a>VirtualMemoryWrite&#160;</td><td class="fielddoc"><p>Combine with VirtualMemoryOperation for Write access. </p>
</td></tr>
<tr><td class="fieldname"><a id="abdfccb438f768cae26c138a43489d2ffa1129c0e4d43f2d121652a7302712cff6"></a>Write&#160;</td><td class="fielddoc"><p>Required to write to memory in a process using WriteProcessMemory. </p>
</td></tr>
<tr><td class="fieldname"><a id="abdfccb438f768cae26c138a43489d2ffa70a2a84088d405a2e3f1e3accaa16723"></a>ReadWrite&#160;</td><td class="fielddoc"><p>Combines read and write access of a process memory. </p>
</td></tr>
<tr><td class="fieldname"><a id="abdfccb438f768cae26c138a43489d2ffa14433c840778ea3194b1d7642df60317"></a>DuplicateHandle&#160;</td><td class="fielddoc"><p>Required to duplicate a handle using DuplicateHandle. </p>
</td></tr>
<tr><td class="fieldname"><a id="abdfccb438f768cae26c138a43489d2ffac6b59bdabc4d10b6cd98e97dbd071549"></a>CreateProcess&#160;</td><td class="fielddoc"><p>Required to create a process. </p>
</td></tr>
<tr><td class="fieldname"><a id="abdfccb438f768cae26c138a43489d2ffacd7befb4aef8f46bbb823af1d99cde83"></a>SetQuota&#160;</td><td class="fielddoc"><p>Required to set memory limits using SetProcessWorkingSetSize. </p>
</td></tr>
<tr><td class="fieldname"><a id="abdfccb438f768cae26c138a43489d2ffafd76c8a174c8459590eb48380c4edc40"></a>SetInformation&#160;</td><td class="fielddoc"><p>Required to set certain information about a process, such as its priority class (see SetPriorityClass). </p>
</td></tr>
<tr><td class="fieldname"><a id="abdfccb438f768cae26c138a43489d2ffa37e8a064723ac3f5eec1e7482f5037f7"></a>QueryInformation&#160;</td><td class="fielddoc"><p>Required to retrieve certain information about a process, such as its token, exit code, and priority class (see OpenProcessToken). </p>
</td></tr>
<tr><td class="fieldname"><a id="abdfccb438f768cae26c138a43489d2ffa225c7a85340534236811e3cae22e885e"></a>SuspendResume&#160;</td><td class="fielddoc"><p>Required to set memory limits using SetProcessWorkingSetSize. </p>
</td></tr>
<tr><td class="fieldname"><a id="abdfccb438f768cae26c138a43489d2ffa2bb5376eb8926e511abaa1f99fed558c"></a>QueryLimitedInformation&#160;</td><td class="fielddoc"><p>Required to retrieve certain information about a process (see GetExitCodeProcess, GetPriorityClass, IsProcessInJob, QueryFullProcessImageName). A handle that has the PROCESS_QUERY_INFORMATION access right is automatically granted PROCESS_QUERY_LIMITED_INFORMATION.Windows Server 2003 and Windows XP: This access right is not supported. </p>
</td></tr>
<tr><td class="fieldname"><a id="abdfccb438f768cae26c138a43489d2ffaa82be0f551b8708bc08eb33cd9ded0cf"></a>Information&#160;</td><td class="fielddoc"><p>Required to query information from another process. </p>
</td></tr>
<tr><td class="fieldname"><a id="abdfccb438f768cae26c138a43489d2ffa40cd014b7b6251e3a22e6a45a73a64e1"></a>Execute&#160;</td><td class="fielddoc"><p>Required when using CreateRemoteThread(Ex) to execute code in a another process. </p>
</td></tr>
<tr><td class="fieldname"><a id="abdfccb438f768cae26c138a43489d2ffab18b960c57a784907dc1cd97ba8a8065"></a>Synchronize&#160;</td><td class="fielddoc"><p>Required to wait for the process to terminate using the wait functions. </p>
</td></tr>
<tr><td class="fieldname"><a id="abdfccb438f768cae26c138a43489d2ffab1c94ca2fbc3e78fc30069c8d0f01680"></a>All&#160;</td><td class="fielddoc"><p>All possible access rights for a process object.Windows Server 2003 and Windows XP: The size of the PROCESS_ALL_ACCESS flag increased on Windows Server 2008 and Windows Vista. If an application compiled for Windows Server 2008 and Windows Vista is run on Windows Server 2003 or Windows XP, the PROCESS_ALL_ACCESS flag is too large and the function specifying this flag fails with ERROR_ACCESS_DENIED. To avoid this problem, specify the minimum set of access rights required for the operation. If PROCESS_ALL_ACCESS must be used, set _WIN32_WINNT to the minimum operating system targeted by your application (for example, #define _WIN32_WINNT _WIN32_WINNT_WINXP). For more information, see Using the Windows Headers. </p>
</td></tr>
</table>

</div>
</div>
<a id="a28a597a806a5662bfe6ef8a30725f3f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28a597a806a5662bfe6ef8a30725f3f6">&#9670;&nbsp;</a></span>ThreadCreationFlags</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespace_process_memory_utilities_1_1_native.html#a28a597a806a5662bfe6ef8a30725f3f6">ProcessMemoryUtilities.Native.ThreadCreationFlags</a> : uint</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Defines flags that control the creation of a remote thread. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a28a597a806a5662bfe6ef8a30725f3f6afd83e0ccb3e6312a62f888dd496dd0a5"></a>Immediately&#160;</td><td class="fielddoc"><p>The thread runs immediately after creation. </p>
</td></tr>
<tr><td class="fieldname"><a id="a28a597a806a5662bfe6ef8a30725f3f6a8bf906833cc7aea8084f552217ed9c1d"></a>Suspended&#160;</td><td class="fielddoc"><p>The thread is created in a suspended state and does not run until the ResumeThread function is called. </p>
</td></tr>
<tr><td class="fieldname"><a id="a28a597a806a5662bfe6ef8a30725f3f6af07c7c4657761b4e01a2ab20ed51855b"></a>StackSizeParamIsAReservation&#160;</td><td class="fielddoc"><p>The dwStackSize parameter specifies the initial reserve size of the stack. If this flag is not specified, dwStackSize specifies the commit size. </p>
</td></tr>
</table>

</div>
</div>
<a id="a06054dd813bba2514407e29f39095dd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06054dd813bba2514407e29f39095dd7">&#9670;&nbsp;</a></span>WaitObjectResult</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespace_process_memory_utilities_1_1_native.html#a06054dd813bba2514407e29f39095dd7">ProcessMemoryUtilities.Native.WaitObjectResult</a> : uint</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Defines the events that cause a function like WaitForSingleObject to return. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a06054dd813bba2514407e29f39095dd7a505a83f220c02df2f85c3810cd9ceb38"></a>Success&#160;</td><td class="fielddoc"><p>The state of the specified object is signaled. </p>
</td></tr>
<tr><td class="fieldname"><a id="a06054dd813bba2514407e29f39095dd7a255de8cd6ee11ed4dc01a19844c1271e"></a>Abandoned&#160;</td><td class="fielddoc"><p>The specified object is a mutex object that was not released by the thread that owned the mutex object before the owning thread terminated. Ownership of the mutex object is granted to the calling thread and the mutex state is set to nonsignaled. If the mutex was protecting persistent state information, you should check it for consistency. </p>
</td></tr>
<tr><td class="fieldname"><a id="a06054dd813bba2514407e29f39095dd7ac85a251cc457840f1e032f1b733e9398"></a>Timeout&#160;</td><td class="fielddoc"><p>The time-out interval elapsed, and the object's state is nonsignaled. </p>
</td></tr>
<tr><td class="fieldname"><a id="a06054dd813bba2514407e29f39095dd7ad7c8c85bf79bbe1b7188497c32c3b0ca"></a>Failed&#160;</td><td class="fielddoc"><p>The function has failed. To get extended error information, call GetLastError. </p>
</td></tr>
</table>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_process_memory_utilities.html">ProcessMemoryUtilities</a></li><li class="navelem"><a class="el" href="namespace_process_memory_utilities_1_1_native.html">Native</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.15 </li>
  </ul>
</div>
</body>
</html>
