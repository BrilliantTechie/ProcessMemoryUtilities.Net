<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ProcessMemoryUtilities.Net: ProcessMemoryUtilities.Memory.ProcessMemory Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ProcessMemoryUtilities.Net
   &#160;<span id="projectnumber">1.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('class_process_memory_utilities_1_1_memory_1_1_process_memory.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="class_process_memory_utilities_1_1_memory_1_1_process_memory-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ProcessMemoryUtilities.Memory.ProcessMemory Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Provides methods to allocate, protect, free, read, write and execute memory in a remote process.  
 <a href="class_process_memory_utilities_1_1_memory_1_1_process_memory.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ae83c2bb0aed86f5c9a3c159e668b41ac"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_process_memory_utilities_1_1_memory_1_1_process_memory.html#ae83c2bb0aed86f5c9a3c159e668b41ac">CloseHandle</a> (IntPtr handle)</td></tr>
<tr class="memdesc:ae83c2bb0aed86f5c9a3c159e668b41ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes an open object handle.  <a href="#ae83c2bb0aed86f5c9a3c159e668b41ac">More...</a><br /></td></tr>
<tr class="separator:ae83c2bb0aed86f5c9a3c159e668b41ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb2dd6f4c830fbdab1ca8b00a2a3157f"><td class="memItemLeft" align="right" valign="top">static IntPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_process_memory_utilities_1_1_memory_1_1_process_memory.html#adb2dd6f4c830fbdab1ca8b00a2a3157f">CreateRemoteThreadEx</a> (IntPtr handle, IntPtr startAddress)</td></tr>
<tr class="memdesc:adb2dd6f4c830fbdab1ca8b00a2a3157f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a thread that runs in the virtual address space of another process and optionally specifies extended attributes such as processor group affinity.  <a href="#adb2dd6f4c830fbdab1ca8b00a2a3157f">More...</a><br /></td></tr>
<tr class="separator:adb2dd6f4c830fbdab1ca8b00a2a3157f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b322f0bcab0cc47584545a98c8a86b8"><td class="memItemLeft" align="right" valign="top">static IntPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_process_memory_utilities_1_1_memory_1_1_process_memory.html#a9b322f0bcab0cc47584545a98c8a86b8">CreateRemoteThreadEx</a> (IntPtr handle, IntPtr startAddress, IntPtr parameter)</td></tr>
<tr class="memdesc:a9b322f0bcab0cc47584545a98c8a86b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a thread that runs in the virtual address space of another process and optionally specifies extended attributes such as processor group affinity.  <a href="#a9b322f0bcab0cc47584545a98c8a86b8">More...</a><br /></td></tr>
<tr class="separator:a9b322f0bcab0cc47584545a98c8a86b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae29c24a67f19b7ab9ac16d7c768d2c3b"><td class="memItemLeft" align="right" valign="top">static IntPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_process_memory_utilities_1_1_memory_1_1_process_memory.html#ae29c24a67f19b7ab9ac16d7c768d2c3b">CreateRemoteThreadEx</a> (IntPtr handle, IntPtr threadAttributes, IntPtr stackSize, IntPtr startAddress, IntPtr parameter, <a class="el" href="namespace_process_memory_utilities_1_1_memory.html#a1435c2affc0afd3e35e72fbcc4c8fbb5">ThreadCreationFlags</a> creationFlags, IntPtr attributeList)</td></tr>
<tr class="memdesc:ae29c24a67f19b7ab9ac16d7c768d2c3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a thread that runs in the virtual address space of another process and optionally specifies extended attributes such as processor group affinity.  <a href="#ae29c24a67f19b7ab9ac16d7c768d2c3b">More...</a><br /></td></tr>
<tr class="separator:ae29c24a67f19b7ab9ac16d7c768d2c3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd372f5928bb673ba9ab6d0633848491"><td class="memItemLeft" align="right" valign="top">static IntPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_process_memory_utilities_1_1_memory_1_1_process_memory.html#afd372f5928bb673ba9ab6d0633848491">CreateRemoteThreadEx</a> (IntPtr handle, IntPtr threadAttributes, IntPtr stackSize, IntPtr startAddress, IntPtr parameter, <a class="el" href="namespace_process_memory_utilities_1_1_memory.html#a1435c2affc0afd3e35e72fbcc4c8fbb5">ThreadCreationFlags</a> creationFlags, IntPtr attributeList, ref uint threadId)</td></tr>
<tr class="memdesc:afd372f5928bb673ba9ab6d0633848491"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a thread that runs in the virtual address space of another process and optionally specifies extended attributes such as processor group affinity.  <a href="#afd372f5928bb673ba9ab6d0633848491">More...</a><br /></td></tr>
<tr class="separator:afd372f5928bb673ba9ab6d0633848491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafb78851ea5eb0f8b0dd4068bb3a8856"><td class="memItemLeft" align="right" valign="top">static IntPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_process_memory_utilities_1_1_memory_1_1_process_memory.html#aafb78851ea5eb0f8b0dd4068bb3a8856">OpenProcess</a> (<a class="el" href="namespace_process_memory_utilities_1_1_memory.html#a9c35275ab4b1a7ff9064f72bf3d5f41a">ProcessAccessFlags</a> desiredAccess, int processId)</td></tr>
<tr class="memdesc:aafb78851ea5eb0f8b0dd4068bb3a8856"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens an existing local process object.  <a href="#aafb78851ea5eb0f8b0dd4068bb3a8856">More...</a><br /></td></tr>
<tr class="separator:aafb78851ea5eb0f8b0dd4068bb3a8856"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae251523e331512e3b01e8a9db6c85f2"><td class="memItemLeft" align="right" valign="top">static IntPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_process_memory_utilities_1_1_memory_1_1_process_memory.html#aae251523e331512e3b01e8a9db6c85f2">OpenProcess</a> (<a class="el" href="namespace_process_memory_utilities_1_1_memory.html#a9c35275ab4b1a7ff9064f72bf3d5f41a">ProcessAccessFlags</a> desiredAccess, bool inheritHandle, int processId)</td></tr>
<tr class="memdesc:aae251523e331512e3b01e8a9db6c85f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens an existing local process object.  <a href="#aae251523e331512e3b01e8a9db6c85f2">More...</a><br /></td></tr>
<tr class="separator:aae251523e331512e3b01e8a9db6c85f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06a3864b54170e88527e9b8c277f4d7b"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_process_memory_utilities_1_1_memory_1_1_process_memory.html#a06a3864b54170e88527e9b8c277f4d7b">ReadProcessMemory</a> (IntPtr handle, IntPtr baseAddress, IntPtr buffer, IntPtr size)</td></tr>
<tr class="memdesc:a06a3864b54170e88527e9b8c277f4d7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads data from an area of memory in a specified process. The entire area to be read must be accessible or the operation fails.  <a href="#a06a3864b54170e88527e9b8c277f4d7b">More...</a><br /></td></tr>
<tr class="separator:a06a3864b54170e88527e9b8c277f4d7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc14f9e1bac56e4904ac3d1833099808"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_process_memory_utilities_1_1_memory_1_1_process_memory.html#adc14f9e1bac56e4904ac3d1833099808">ReadProcessMemory</a> (IntPtr handle, IntPtr baseAddress, IntPtr buffer, IntPtr size, ref IntPtr numberOfBytesRead)</td></tr>
<tr class="memdesc:adc14f9e1bac56e4904ac3d1833099808"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads data from an area of memory in a specified process. The entire area to be read must be accessible or the operation fails.  <a href="#adc14f9e1bac56e4904ac3d1833099808">More...</a><br /></td></tr>
<tr class="separator:adc14f9e1bac56e4904ac3d1833099808"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5f03ffc1989e20b58eaf73ad31e9f26"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_process_memory_utilities_1_1_memory_1_1_process_memory.html#ae5f03ffc1989e20b58eaf73ad31e9f26">ReadProcessMemory&lt; T &gt;</a> (IntPtr handle, IntPtr baseAddress, ref T buffer)</td></tr>
<tr class="memdesc:ae5f03ffc1989e20b58eaf73ad31e9f26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads data from an area of memory in a specified process. The entire area to be read must be accessible or the operation fails.  <a href="#ae5f03ffc1989e20b58eaf73ad31e9f26">More...</a><br /></td></tr>
<tr class="separator:ae5f03ffc1989e20b58eaf73ad31e9f26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33320fe8d4564b677c38ca2402b32ac0"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_process_memory_utilities_1_1_memory_1_1_process_memory.html#a33320fe8d4564b677c38ca2402b32ac0">ReadProcessMemory&lt; T &gt;</a> (IntPtr handle, IntPtr baseAddress, ref T buffer, ref IntPtr numberOfBytesRead)</td></tr>
<tr class="memdesc:a33320fe8d4564b677c38ca2402b32ac0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads data from an area of memory in a specified process. The entire area to be read must be accessible or the operation fails.  <a href="#a33320fe8d4564b677c38ca2402b32ac0">More...</a><br /></td></tr>
<tr class="separator:a33320fe8d4564b677c38ca2402b32ac0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a6289a9e5983787cf7d2931ddfa0b92"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_process_memory_utilities_1_1_memory_1_1_process_memory.html#a1a6289a9e5983787cf7d2931ddfa0b92">ReadProcessMemory&lt; T &gt;</a> (IntPtr handle, IntPtr baseAddress, T[] buffer)</td></tr>
<tr class="memdesc:a1a6289a9e5983787cf7d2931ddfa0b92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads data from an area of memory in a specified process. The entire area to be read must be accessible or the operation fails.  <a href="#a1a6289a9e5983787cf7d2931ddfa0b92">More...</a><br /></td></tr>
<tr class="separator:a1a6289a9e5983787cf7d2931ddfa0b92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1b492903d2574d10c3948763e77da98"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_process_memory_utilities_1_1_memory_1_1_process_memory.html#ad1b492903d2574d10c3948763e77da98">ReadProcessMemory&lt; T &gt;</a> (IntPtr handle, IntPtr baseAddress, T[] buffer, ref IntPtr numberOfBytesRead)</td></tr>
<tr class="memdesc:ad1b492903d2574d10c3948763e77da98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads data from an area of memory in a specified process. The entire area to be read must be accessible or the operation fails.  <a href="#ad1b492903d2574d10c3948763e77da98">More...</a><br /></td></tr>
<tr class="separator:ad1b492903d2574d10c3948763e77da98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5cc4e43f28a52aa0dd43d853bc16360"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_process_memory_utilities_1_1_memory_1_1_process_memory.html#ab5cc4e43f28a52aa0dd43d853bc16360">ReadProcessMemory&lt; T &gt;</a> (IntPtr handle, IntPtr baseAddress, T[] buffer, int offset, int length)</td></tr>
<tr class="memdesc:ab5cc4e43f28a52aa0dd43d853bc16360"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads data from an area of memory in a specified process. The entire area to be read must be accessible or the operation fails.  <a href="#ab5cc4e43f28a52aa0dd43d853bc16360">More...</a><br /></td></tr>
<tr class="separator:ab5cc4e43f28a52aa0dd43d853bc16360"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5d1ce2f5870e3ae6d377c796f6e6abe"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_process_memory_utilities_1_1_memory_1_1_process_memory.html#ab5d1ce2f5870e3ae6d377c796f6e6abe">ReadProcessMemory&lt; T &gt;</a> (IntPtr handle, IntPtr baseAddress, T[] buffer, int offset, int length, ref IntPtr numberOfBytesRead)</td></tr>
<tr class="memdesc:ab5d1ce2f5870e3ae6d377c796f6e6abe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads data from an area of memory in a specified process. The entire area to be read must be accessible or the operation fails.  <a href="#ab5d1ce2f5870e3ae6d377c796f6e6abe">More...</a><br /></td></tr>
<tr class="separator:ab5d1ce2f5870e3ae6d377c796f6e6abe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a724b06cd99f10c68c7e1fc8621ea806e"><td class="memItemLeft" align="right" valign="top">static IntPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_process_memory_utilities_1_1_memory_1_1_process_memory.html#a724b06cd99f10c68c7e1fc8621ea806e">VirtualAllocEx</a> (IntPtr handle, IntPtr baseAddress, IntPtr size, <a class="el" href="namespace_process_memory_utilities_1_1_memory.html#af0a9f9efd6fdb043adf94b1e4d29aff5">AllocationType</a> allocationType, <a class="el" href="namespace_process_memory_utilities_1_1_memory.html#abd2d2d8645ab563c46f8236ab8fe5c0b">MemoryProtectionFlags</a> memoryProtection)</td></tr>
<tr class="memdesc:a724b06cd99f10c68c7e1fc8621ea806e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserves, commits, or changes the state of a region of memory within the virtual address space of a specified process. The function initializes the memory it allocates to zero.  <a href="#a724b06cd99f10c68c7e1fc8621ea806e">More...</a><br /></td></tr>
<tr class="separator:a724b06cd99f10c68c7e1fc8621ea806e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa320b99608553ac1050c952e04c68951"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_process_memory_utilities_1_1_memory_1_1_process_memory.html#aa320b99608553ac1050c952e04c68951">VirtualFreeEx</a> (IntPtr handle, IntPtr address, IntPtr size, <a class="el" href="namespace_process_memory_utilities_1_1_memory.html#acc8b61a7fd031a58cd0679bb7830adcc">FreeType</a> freeType)</td></tr>
<tr class="memdesc:aa320b99608553ac1050c952e04c68951"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases, decommits, or releases and decommits a region of memory within the virtual address space of a specified process.  <a href="#aa320b99608553ac1050c952e04c68951">More...</a><br /></td></tr>
<tr class="separator:aa320b99608553ac1050c952e04c68951"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0002d5bc4f3356c68aea6c808a234df8"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_process_memory_utilities_1_1_memory_1_1_process_memory.html#a0002d5bc4f3356c68aea6c808a234df8">VirtualProtectEx</a> (IntPtr handle, IntPtr address, IntPtr size, <a class="el" href="namespace_process_memory_utilities_1_1_memory.html#abd2d2d8645ab563c46f8236ab8fe5c0b">MemoryProtectionFlags</a> newProtect, ref <a class="el" href="namespace_process_memory_utilities_1_1_memory.html#abd2d2d8645ab563c46f8236ab8fe5c0b">MemoryProtectionFlags</a> oldProtect)</td></tr>
<tr class="memdesc:a0002d5bc4f3356c68aea6c808a234df8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the protection on a region of committed pages in the virtual address space of a specified process.  <a href="#a0002d5bc4f3356c68aea6c808a234df8">More...</a><br /></td></tr>
<tr class="separator:a0002d5bc4f3356c68aea6c808a234df8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9455ae06dd79b621459fa669666e340f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespace_process_memory_utilities_1_1_memory.html#ae642cfe8e18ac29f66f74344aac5b302">WaitObjectResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_process_memory_utilities_1_1_memory_1_1_process_memory.html#a9455ae06dd79b621459fa669666e340f">WaitForSingleObject</a> (IntPtr handle, uint timeout)</td></tr>
<tr class="memdesc:a9455ae06dd79b621459fa669666e340f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits until the specified object is in the signaled state or the time-out interval elapses.  <a href="#a9455ae06dd79b621459fa669666e340f">More...</a><br /></td></tr>
<tr class="separator:a9455ae06dd79b621459fa669666e340f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94167b42fa5f7866376caa780d427b26"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_process_memory_utilities_1_1_memory_1_1_process_memory.html#a94167b42fa5f7866376caa780d427b26">WriteProcessMemory</a> (IntPtr handle, IntPtr baseAddress, IntPtr buffer, IntPtr size)</td></tr>
<tr class="memdesc:a94167b42fa5f7866376caa780d427b26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes data to an area of memory in a specified process. The entire area to be written to must be accessible or the operation fails.  <a href="#a94167b42fa5f7866376caa780d427b26">More...</a><br /></td></tr>
<tr class="separator:a94167b42fa5f7866376caa780d427b26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc0d34b32cae8c7643454d55be6563f6"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_process_memory_utilities_1_1_memory_1_1_process_memory.html#abc0d34b32cae8c7643454d55be6563f6">WriteProcessMemory</a> (IntPtr handle, IntPtr baseAddress, IntPtr buffer, IntPtr size, ref IntPtr numberOfBytesWritten)</td></tr>
<tr class="memdesc:abc0d34b32cae8c7643454d55be6563f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes data to an area of memory in a specified process. The entire area to be written to must be accessible or the operation fails.  <a href="#abc0d34b32cae8c7643454d55be6563f6">More...</a><br /></td></tr>
<tr class="separator:abc0d34b32cae8c7643454d55be6563f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a049334da6fdfcf29afdc7d489f15b731"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_process_memory_utilities_1_1_memory_1_1_process_memory.html#a049334da6fdfcf29afdc7d489f15b731">WriteProcessMemory&lt; T &gt;</a> (IntPtr handle, IntPtr baseAddress, T buffer)</td></tr>
<tr class="memdesc:a049334da6fdfcf29afdc7d489f15b731"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes data to an area of memory in a specified process. The entire area to be written to must be accessible or the operation fails.  <a href="#a049334da6fdfcf29afdc7d489f15b731">More...</a><br /></td></tr>
<tr class="separator:a049334da6fdfcf29afdc7d489f15b731"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2c50c0d4d5133cc3e6c78bcef7db0b6"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_process_memory_utilities_1_1_memory_1_1_process_memory.html#aa2c50c0d4d5133cc3e6c78bcef7db0b6">WriteProcessMemory&lt; T &gt;</a> (IntPtr handle, IntPtr baseAddress, T buffer, ref IntPtr numberOfBytesWritten)</td></tr>
<tr class="memdesc:aa2c50c0d4d5133cc3e6c78bcef7db0b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes data to an area of memory in a specified process. The entire area to be written to must be accessible or the operation fails.  <a href="#aa2c50c0d4d5133cc3e6c78bcef7db0b6">More...</a><br /></td></tr>
<tr class="separator:aa2c50c0d4d5133cc3e6c78bcef7db0b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dea90118559c5802493bf03fca8c7cb"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_process_memory_utilities_1_1_memory_1_1_process_memory.html#a5dea90118559c5802493bf03fca8c7cb">WriteProcessMemory&lt; T &gt;</a> (IntPtr handle, IntPtr baseAddress, T[] buffer)</td></tr>
<tr class="memdesc:a5dea90118559c5802493bf03fca8c7cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes data to an area of memory in a specified process. The entire area to be written to must be accessible or the operation fails.  <a href="#a5dea90118559c5802493bf03fca8c7cb">More...</a><br /></td></tr>
<tr class="separator:a5dea90118559c5802493bf03fca8c7cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dd68d680584092e67d233c1780b871a"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_process_memory_utilities_1_1_memory_1_1_process_memory.html#a9dd68d680584092e67d233c1780b871a">WriteProcessMemory&lt; T &gt;</a> (IntPtr handle, IntPtr baseAddress, T[] buffer, ref IntPtr numberOfBytesWritten)</td></tr>
<tr class="memdesc:a9dd68d680584092e67d233c1780b871a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes data to an area of memory in a specified process. The entire area to be written to must be accessible or the operation fails.  <a href="#a9dd68d680584092e67d233c1780b871a">More...</a><br /></td></tr>
<tr class="separator:a9dd68d680584092e67d233c1780b871a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25e7eb71212fe4336a55ef4159d191c7"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_process_memory_utilities_1_1_memory_1_1_process_memory.html#a25e7eb71212fe4336a55ef4159d191c7">WriteProcessMemory&lt; T &gt;</a> (IntPtr handle, IntPtr baseAddress, T[] buffer, int offset, int length)</td></tr>
<tr class="memdesc:a25e7eb71212fe4336a55ef4159d191c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes data to an area of memory in a specified process. The entire area to be written to must be accessible or the operation fails.  <a href="#a25e7eb71212fe4336a55ef4159d191c7">More...</a><br /></td></tr>
<tr class="separator:a25e7eb71212fe4336a55ef4159d191c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f50fab813e8c735d802b67c514504cc"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_process_memory_utilities_1_1_memory_1_1_process_memory.html#a3f50fab813e8c735d802b67c514504cc">WriteProcessMemory&lt; T &gt;</a> (IntPtr handle, IntPtr baseAddress, T[] buffer, int offset, int length, ref IntPtr numberOfBytesWritten)</td></tr>
<tr class="memdesc:a3f50fab813e8c735d802b67c514504cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes data to an area of memory in a specified process. The entire area to be written to must be accessible or the operation fails.  <a href="#a3f50fab813e8c735d802b67c514504cc">More...</a><br /></td></tr>
<tr class="separator:a3f50fab813e8c735d802b67c514504cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a1712c63291ca327449972d32a10ebd70"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespace_process_memory_utilities_1_1_memory.html#a9c35275ab4b1a7ff9064f72bf3d5f41a">ProcessAccessFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_process_memory_utilities_1_1_memory_1_1_process_memory.html#a1712c63291ca327449972d32a10ebd70">PROCESS_ALLOCATE_ACCESS</a> = <a class="el" href="namespace_process_memory_utilities_1_1_memory.html#a9c35275ab4b1a7ff9064f72bf3d5f41aa03fce4e381fb206d3b66fa0efeaa65b9">ProcessAccessFlags.VirtualMemoryOperation</a></td></tr>
<tr class="memdesc:a1712c63291ca327449972d32a10ebd70"><td class="mdescLeft">&#160;</td><td class="mdescRight">A constant to use with OpenProcess when requiring access to allocate memory.  <a href="#a1712c63291ca327449972d32a10ebd70">More...</a><br /></td></tr>
<tr class="separator:a1712c63291ca327449972d32a10ebd70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa933cd43cce65c170c898b0308d3b087"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespace_process_memory_utilities_1_1_memory.html#a9c35275ab4b1a7ff9064f72bf3d5f41a">ProcessAccessFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_process_memory_utilities_1_1_memory_1_1_process_memory.html#aa933cd43cce65c170c898b0308d3b087">PROCESS_EXECUTE_ACCESS</a> = <a class="el" href="class_process_memory_utilities_1_1_memory_1_1_process_memory.html#abd875146f1fa0deec6c58d4ffd18f9e8">PROCESS_READ_WRITE_ACCESS</a> | <a class="el" href="class_process_memory_utilities_1_1_memory_1_1_process_memory.html#abc709abb3291737161ebd8af53bbcc4e">PROCESS_INFORMATION_ACCESS</a> | <a class="el" href="namespace_process_memory_utilities_1_1_memory.html#a9c35275ab4b1a7ff9064f72bf3d5f41aad4b9bd5e20476116593b8b68fb08bf57">ProcessAccessFlags.CreateThread</a></td></tr>
<tr class="memdesc:aa933cd43cce65c170c898b0308d3b087"><td class="mdescLeft">&#160;</td><td class="mdescRight">A constant to use with OpenProcess when requiring access to execute memory.  <a href="#aa933cd43cce65c170c898b0308d3b087">More...</a><br /></td></tr>
<tr class="separator:aa933cd43cce65c170c898b0308d3b087"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc709abb3291737161ebd8af53bbcc4e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespace_process_memory_utilities_1_1_memory.html#a9c35275ab4b1a7ff9064f72bf3d5f41a">ProcessAccessFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_process_memory_utilities_1_1_memory_1_1_process_memory.html#abc709abb3291737161ebd8af53bbcc4e">PROCESS_INFORMATION_ACCESS</a> = <a class="el" href="namespace_process_memory_utilities_1_1_memory.html#a9c35275ab4b1a7ff9064f72bf3d5f41aa37e8a064723ac3f5eec1e7482f5037f7">ProcessAccessFlags.QueryInformation</a> | <a class="el" href="namespace_process_memory_utilities_1_1_memory.html#a9c35275ab4b1a7ff9064f72bf3d5f41aa2bb5376eb8926e511abaa1f99fed558c">ProcessAccessFlags.QueryLimitedInformation</a></td></tr>
<tr class="memdesc:abc709abb3291737161ebd8af53bbcc4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A constant to use with OpenProcess when requiring access to informations about the process and its memory.  <a href="#abc709abb3291737161ebd8af53bbcc4e">More...</a><br /></td></tr>
<tr class="separator:abc709abb3291737161ebd8af53bbcc4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0920c9338271a5d667cab792c1864d6"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespace_process_memory_utilities_1_1_memory.html#a9c35275ab4b1a7ff9064f72bf3d5f41a">ProcessAccessFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_process_memory_utilities_1_1_memory_1_1_process_memory.html#aa0920c9338271a5d667cab792c1864d6">PROCESS_READ_ACCESS</a> = <a class="el" href="namespace_process_memory_utilities_1_1_memory.html#a9c35275ab4b1a7ff9064f72bf3d5f41aa1097d94adf1ffb4f72859958d1e143fc">ProcessAccessFlags.VirtualMemoryRead</a></td></tr>
<tr class="memdesc:aa0920c9338271a5d667cab792c1864d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">A constant to be use with OpenProcess when requiring access to read memory.  <a href="#aa0920c9338271a5d667cab792c1864d6">More...</a><br /></td></tr>
<tr class="separator:aa0920c9338271a5d667cab792c1864d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd875146f1fa0deec6c58d4ffd18f9e8"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespace_process_memory_utilities_1_1_memory.html#a9c35275ab4b1a7ff9064f72bf3d5f41a">ProcessAccessFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_process_memory_utilities_1_1_memory_1_1_process_memory.html#abd875146f1fa0deec6c58d4ffd18f9e8">PROCESS_READ_WRITE_ACCESS</a> = <a class="el" href="class_process_memory_utilities_1_1_memory_1_1_process_memory.html#aa0920c9338271a5d667cab792c1864d6">PROCESS_READ_ACCESS</a> | <a class="el" href="class_process_memory_utilities_1_1_memory_1_1_process_memory.html#ab6cbbd17a6b8a953cea236e5a707e623">PROCESS_WRITE_ACCESS</a></td></tr>
<tr class="memdesc:abd875146f1fa0deec6c58d4ffd18f9e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">A constant to be use with OpenProcess when requiring access to read and write memory.  <a href="#abd875146f1fa0deec6c58d4ffd18f9e8">More...</a><br /></td></tr>
<tr class="separator:abd875146f1fa0deec6c58d4ffd18f9e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6cbbd17a6b8a953cea236e5a707e623"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespace_process_memory_utilities_1_1_memory.html#a9c35275ab4b1a7ff9064f72bf3d5f41a">ProcessAccessFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_process_memory_utilities_1_1_memory_1_1_process_memory.html#ab6cbbd17a6b8a953cea236e5a707e623">PROCESS_WRITE_ACCESS</a> = <a class="el" href="namespace_process_memory_utilities_1_1_memory.html#a9c35275ab4b1a7ff9064f72bf3d5f41aa03fce4e381fb206d3b66fa0efeaa65b9">ProcessAccessFlags.VirtualMemoryOperation</a> | <a class="el" href="namespace_process_memory_utilities_1_1_memory.html#a9c35275ab4b1a7ff9064f72bf3d5f41aad81b2f1b0d561c67eac1cfb40ee3b092">ProcessAccessFlags.VirtualMemoryWrite</a></td></tr>
<tr class="memdesc:ab6cbbd17a6b8a953cea236e5a707e623"><td class="mdescLeft">&#160;</td><td class="mdescRight">A constant to use with OpenProcess when requiring access to write memory.  <a href="#ab6cbbd17a6b8a953cea236e5a707e623">More...</a><br /></td></tr>
<tr class="separator:ab6cbbd17a6b8a953cea236e5a707e623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af46e48b0d74df93cf0b4ba5903c8a25a"><td class="memItemLeft" align="right" valign="top">const uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_process_memory_utilities_1_1_memory_1_1_process_memory.html#af46e48b0d74df93cf0b4ba5903c8a25a">WAIT_TIMEOUT_INFINITE</a> = uint.MaxValue</td></tr>
<tr class="memdesc:af46e48b0d74df93cf0b4ba5903c8a25a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A constant to use with WaitForSingleObject to wait for an infinite amount of time.  <a href="#af46e48b0d74df93cf0b4ba5903c8a25a">More...</a><br /></td></tr>
<tr class="separator:af46e48b0d74df93cf0b4ba5903c8a25a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Provides methods to allocate, protect, free, read, write and execute memory in a remote process. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="ae83c2bb0aed86f5c9a3c159e668b41ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae83c2bb0aed86f5c9a3c159e668b41ac">&#9670;&nbsp;</a></span>CloseHandle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool ProcessMemoryUtilities.Memory.ProcessMemory.CloseHandle </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Closes an open object handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A valid handle to an open object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the function succeeds; otherwise, <code>false</code>.</dd></dl>

</div>
</div>
<a id="adb2dd6f4c830fbdab1ca8b00a2a3157f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb2dd6f4c830fbdab1ca8b00a2a3157f">&#9670;&nbsp;</a></span>CreateRemoteThreadEx() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static IntPtr ProcessMemoryUtilities.Memory.ProcessMemory.CreateRemoteThreadEx </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>startAddress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a thread that runs in the virtual address space of another process and optionally specifies extended attributes such as processor group affinity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A handle to the process in which the thread is to be created. The handle must have the PROCESS_CREATE_THREAD, PROCESS_QUERY_INFORMATION, PROCESS_VM_OPERATION, PROCESS_VM_WRITE, and PROCESS_VM_READ access rights. </td></tr>
    <tr><td class="paramname">startAddress</td><td>A pointer to the application-defined function of type LPTHREAD_START_ROUTINE to be executed by the thread and represents the starting address of the thread in the remote process. The function must exist in the remote process. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the function succeeds, the return value is a handle to the new thread. If the function fails, the return value is NULL. </dd></dl>

</div>
</div>
<a id="a9b322f0bcab0cc47584545a98c8a86b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b322f0bcab0cc47584545a98c8a86b8">&#9670;&nbsp;</a></span>CreateRemoteThreadEx() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static IntPtr ProcessMemoryUtilities.Memory.ProcessMemory.CreateRemoteThreadEx </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>startAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>parameter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a thread that runs in the virtual address space of another process and optionally specifies extended attributes such as processor group affinity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A handle to the process in which the thread is to be created. The handle must have the PROCESS_CREATE_THREAD, PROCESS_QUERY_INFORMATION, PROCESS_VM_OPERATION, PROCESS_VM_WRITE, and PROCESS_VM_READ access rights. </td></tr>
    <tr><td class="paramname">startAddress</td><td>A pointer to the application-defined function of type LPTHREAD_START_ROUTINE to be executed by the thread and represents the starting address of the thread in the remote process. The function must exist in the remote process. </td></tr>
    <tr><td class="paramname">parameter</td><td>A pointer to a variable to be passed to the thread function pointed to by lpStartAddress. This parameter can be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the function succeeds, the return value is a handle to the new thread. If the function fails, the return value is NULL. </dd></dl>

</div>
</div>
<a id="ae29c24a67f19b7ab9ac16d7c768d2c3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae29c24a67f19b7ab9ac16d7c768d2c3b">&#9670;&nbsp;</a></span>CreateRemoteThreadEx() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static IntPtr ProcessMemoryUtilities.Memory.ProcessMemory.CreateRemoteThreadEx </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>threadAttributes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>stackSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>startAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>parameter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_process_memory_utilities_1_1_memory.html#a1435c2affc0afd3e35e72fbcc4c8fbb5">ThreadCreationFlags</a>&#160;</td>
          <td class="paramname"><em>creationFlags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>attributeList</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a thread that runs in the virtual address space of another process and optionally specifies extended attributes such as processor group affinity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A handle to the process in which the thread is to be created. The handle must have the PROCESS_CREATE_THREAD, PROCESS_QUERY_INFORMATION, PROCESS_VM_OPERATION, PROCESS_VM_WRITE, and PROCESS_VM_READ access rights. </td></tr>
    <tr><td class="paramname">threadAttributes</td><td>A pointer to a SECURITY_ATTRIBUTES structure that specifies a security descriptor for the new thread and determines whether child processes can inherit the returned handle. If lpThreadAttributes is NULL, the thread gets a default security descriptor and the handle cannot be inherited. The access control lists (ACL) in the default security descriptor for a thread come from the primary token of the creator. </td></tr>
    <tr><td class="paramname">stackSize</td><td>The initial size of the stack, in bytes. The system rounds this value to the nearest page. If this parameter is 0 (zero), the new thread uses the default size for the executable. For more information, see Thread Stack Size. </td></tr>
    <tr><td class="paramname">startAddress</td><td>A pointer to the application-defined function of type LPTHREAD_START_ROUTINE to be executed by the thread and represents the starting address of the thread in the remote process. The function must exist in the remote process. </td></tr>
    <tr><td class="paramname">parameter</td><td>A pointer to a variable to be passed to the thread function pointed to by lpStartAddress. This parameter can be NULL. </td></tr>
    <tr><td class="paramname">creationFlags</td><td>The flags that control the creation of the thread.</td></tr>
    <tr><td class="paramname">attributeList</td><td>An attribute list that contains additional parameters for the new thread. This list is created by the InitializeProcThreadAttributeList function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the function succeeds, the return value is a handle to the new thread. If the function fails, the return value is NULL. </dd></dl>

</div>
</div>
<a id="afd372f5928bb673ba9ab6d0633848491"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd372f5928bb673ba9ab6d0633848491">&#9670;&nbsp;</a></span>CreateRemoteThreadEx() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static IntPtr ProcessMemoryUtilities.Memory.ProcessMemory.CreateRemoteThreadEx </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>threadAttributes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>stackSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>startAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>parameter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_process_memory_utilities_1_1_memory.html#a1435c2affc0afd3e35e72fbcc4c8fbb5">ThreadCreationFlags</a>&#160;</td>
          <td class="paramname"><em>creationFlags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>attributeList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ref uint&#160;</td>
          <td class="paramname"><em>threadId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a thread that runs in the virtual address space of another process and optionally specifies extended attributes such as processor group affinity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A handle to the process in which the thread is to be created. The handle must have the PROCESS_CREATE_THREAD, PROCESS_QUERY_INFORMATION, PROCESS_VM_OPERATION, PROCESS_VM_WRITE, and PROCESS_VM_READ access rights. </td></tr>
    <tr><td class="paramname">threadAttributes</td><td>A pointer to a SECURITY_ATTRIBUTES structure that specifies a security descriptor for the new thread and determines whether child processes can inherit the returned handle. If lpThreadAttributes is NULL, the thread gets a default security descriptor and the handle cannot be inherited. The access control lists (ACL) in the default security descriptor for a thread come from the primary token of the creator. </td></tr>
    <tr><td class="paramname">stackSize</td><td>The initial size of the stack, in bytes. The system rounds this value to the nearest page. If this parameter is 0 (zero), the new thread uses the default size for the executable. For more information, see Thread Stack Size. </td></tr>
    <tr><td class="paramname">startAddress</td><td>A pointer to the application-defined function of type LPTHREAD_START_ROUTINE to be executed by the thread and represents the starting address of the thread in the remote process. The function must exist in the remote process. </td></tr>
    <tr><td class="paramname">parameter</td><td>A pointer to a variable to be passed to the thread function pointed to by lpStartAddress. This parameter can be NULL. </td></tr>
    <tr><td class="paramname">creationFlags</td><td>The flags that control the creation of the thread.</td></tr>
    <tr><td class="paramname">attributeList</td><td>An attribute list that contains additional parameters for the new thread. This list is created by the InitializeProcThreadAttributeList function. </td></tr>
    <tr><td class="paramname">threadId</td><td>A variable that receives the thread identifier.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the function succeeds, the return value is a handle to the new thread. If the function fails, the return value is NULL. </dd></dl>

</div>
</div>
<a id="aafb78851ea5eb0f8b0dd4068bb3a8856"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafb78851ea5eb0f8b0dd4068bb3a8856">&#9670;&nbsp;</a></span>OpenProcess() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static IntPtr ProcessMemoryUtilities.Memory.ProcessMemory.OpenProcess </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_process_memory_utilities_1_1_memory.html#a9c35275ab4b1a7ff9064f72bf3d5f41a">ProcessAccessFlags</a>&#160;</td>
          <td class="paramname"><em>desiredAccess</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>processId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Opens an existing local process object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desiredAccess</td><td>The access to the process object. This access right is checked against the security descriptor for the process. This parameter can be one or more of the process access rights. </td></tr>
    <tr><td class="paramname">processId</td><td>The identifier of the local process to be opened.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the function succeeds, the return value is an open handle to the specified process. If the function fails, the return value is NULL. </dd></dl>

</div>
</div>
<a id="aae251523e331512e3b01e8a9db6c85f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae251523e331512e3b01e8a9db6c85f2">&#9670;&nbsp;</a></span>OpenProcess() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static IntPtr ProcessMemoryUtilities.Memory.ProcessMemory.OpenProcess </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_process_memory_utilities_1_1_memory.html#a9c35275ab4b1a7ff9064f72bf3d5f41a">ProcessAccessFlags</a>&#160;</td>
          <td class="paramname"><em>desiredAccess</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>inheritHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>processId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Opens an existing local process object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desiredAccess</td><td>The access to the process object. This access right is checked against the security descriptor for the process. This parameter can be one or more of the process access rights. </td></tr>
    <tr><td class="paramname">inheritHandle</td><td>If this value is TRUE, processes created by this process will inherit the handle. Otherwise, the processes do not inherit this handle. </td></tr>
    <tr><td class="paramname">processId</td><td>The identifier of the local process to be opened.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the function succeeds, the return value is an open handle to the specified process. If the function fails, the return value is NULL. </dd></dl>

</div>
</div>
<a id="a06a3864b54170e88527e9b8c277f4d7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06a3864b54170e88527e9b8c277f4d7b">&#9670;&nbsp;</a></span>ReadProcessMemory() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool ProcessMemoryUtilities.Memory.ProcessMemory.ReadProcessMemory </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>baseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads data from an area of memory in a specified process. The entire area to be read must be accessible or the operation fails. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A handle to the process with memory that is being read. The handle must have PROCESS_VM_READ access to the process. </td></tr>
    <tr><td class="paramname">baseAddress</td><td>A pointer to the base address in the specified process from which to read. Before any data transfer occurs, the system verifies that all data in the base address and memory of the specified size is accessible for read access, and if it is not accessible the function fails. </td></tr>
    <tr><td class="paramname">buffer</td><td>A pointer to a buffer that receives the contents from the address space of the specified process.</td></tr>
    <tr><td class="paramname">size</td><td>The number of bytes to be read from the specified process.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the function succeeds; otherwise, <code>false</code>.</dd></dl>

</div>
</div>
<a id="adc14f9e1bac56e4904ac3d1833099808"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc14f9e1bac56e4904ac3d1833099808">&#9670;&nbsp;</a></span>ReadProcessMemory() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool ProcessMemoryUtilities.Memory.ProcessMemory.ReadProcessMemory </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>baseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ref IntPtr&#160;</td>
          <td class="paramname"><em>numberOfBytesRead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads data from an area of memory in a specified process. The entire area to be read must be accessible or the operation fails. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A handle to the process with memory that is being read. The handle must have PROCESS_VM_READ access to the process. </td></tr>
    <tr><td class="paramname">baseAddress</td><td>A pointer to the base address in the specified process from which to read. Before any data transfer occurs, the system verifies that all data in the base address and memory of the specified size is accessible for read access, and if it is not accessible the function fails. </td></tr>
    <tr><td class="paramname">buffer</td><td>A pointer to a buffer that receives the contents from the address space of the specified process.</td></tr>
    <tr><td class="paramname">size</td><td>The number of bytes to be read from the specified process.</td></tr>
    <tr><td class="paramname">numberOfBytesRead</td><td>A pointer to a variable that receives the number of bytes transferred into the specified buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the function succeeds; otherwise, <code>false</code>.</dd></dl>

</div>
</div>
<a id="ae5f03ffc1989e20b58eaf73ad31e9f26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5f03ffc1989e20b58eaf73ad31e9f26">&#9670;&nbsp;</a></span>ReadProcessMemory&lt; T &gt;() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool <a class="el" href="class_process_memory_utilities_1_1_memory_1_1_process_memory.html#a06a3864b54170e88527e9b8c277f4d7b">ProcessMemoryUtilities.Memory.ProcessMemory.ReadProcessMemory</a>&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>baseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ref T&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads data from an area of memory in a specified process. The entire area to be read must be accessible or the operation fails. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the data to return.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A handle to the process with memory that is being read. The handle must have PROCESS_VM_READ access to the process. </td></tr>
    <tr><td class="paramname">baseAddress</td><td>A pointer to the base address in the specified process from which to read. Before any data transfer occurs, the system verifies that all data in the base address and memory of the specified size is accessible for read access, and if it is not accessible the function fails. </td></tr>
    <tr><td class="paramname">buffer</td><td>A pointer to a buffer that receives the contents from the address space of the specified process.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the function succeeds; otherwise, <code>false</code>.</dd></dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>struct</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="a33320fe8d4564b677c38ca2402b32ac0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33320fe8d4564b677c38ca2402b32ac0">&#9670;&nbsp;</a></span>ReadProcessMemory&lt; T &gt;() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool <a class="el" href="class_process_memory_utilities_1_1_memory_1_1_process_memory.html#a06a3864b54170e88527e9b8c277f4d7b">ProcessMemoryUtilities.Memory.ProcessMemory.ReadProcessMemory</a>&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>baseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ref T&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ref IntPtr&#160;</td>
          <td class="paramname"><em>numberOfBytesRead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads data from an area of memory in a specified process. The entire area to be read must be accessible or the operation fails. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the data to return.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A handle to the process with memory that is being read. The handle must have PROCESS_VM_READ access to the process. </td></tr>
    <tr><td class="paramname">baseAddress</td><td>A pointer to the base address in the specified process from which to read. Before any data transfer occurs, the system verifies that all data in the base address and memory of the specified size is accessible for read access, and if it is not accessible the function fails. </td></tr>
    <tr><td class="paramname">buffer</td><td>A pointer to a buffer that receives the contents from the address space of the specified process.</td></tr>
    <tr><td class="paramname">numberOfBytesRead</td><td>A pointer to a variable that receives the number of bytes transferred into the specified buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the function succeeds; otherwise, <code>false</code>.</dd></dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>struct</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="a1a6289a9e5983787cf7d2931ddfa0b92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a6289a9e5983787cf7d2931ddfa0b92">&#9670;&nbsp;</a></span>ReadProcessMemory&lt; T &gt;() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool <a class="el" href="class_process_memory_utilities_1_1_memory_1_1_process_memory.html#a06a3864b54170e88527e9b8c277f4d7b">ProcessMemoryUtilities.Memory.ProcessMemory.ReadProcessMemory</a>&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>baseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T []&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads data from an area of memory in a specified process. The entire area to be read must be accessible or the operation fails. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the data to return.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A handle to the process with memory that is being read. The handle must have PROCESS_VM_READ access to the process. </td></tr>
    <tr><td class="paramname">baseAddress</td><td>A pointer to the base address in the specified process from which to read. Before any data transfer occurs, the system verifies that all data in the base address and memory of the specified size is accessible for read access, and if it is not accessible the function fails. </td></tr>
    <tr><td class="paramname">buffer</td><td>A pointer to a buffer that receives the contents from the address space of the specified process.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the function succeeds; otherwise, <code>false</code>.</dd></dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>struct</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="ad1b492903d2574d10c3948763e77da98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1b492903d2574d10c3948763e77da98">&#9670;&nbsp;</a></span>ReadProcessMemory&lt; T &gt;() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool <a class="el" href="class_process_memory_utilities_1_1_memory_1_1_process_memory.html#a06a3864b54170e88527e9b8c277f4d7b">ProcessMemoryUtilities.Memory.ProcessMemory.ReadProcessMemory</a>&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>baseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T []&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ref IntPtr&#160;</td>
          <td class="paramname"><em>numberOfBytesRead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads data from an area of memory in a specified process. The entire area to be read must be accessible or the operation fails. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the data to return.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A handle to the process with memory that is being read. The handle must have PROCESS_VM_READ access to the process. </td></tr>
    <tr><td class="paramname">baseAddress</td><td>A pointer to the base address in the specified process from which to read. Before any data transfer occurs, the system verifies that all data in the base address and memory of the specified size is accessible for read access, and if it is not accessible the function fails. </td></tr>
    <tr><td class="paramname">buffer</td><td>A pointer to a buffer that receives the contents from the address space of the specified process.</td></tr>
    <tr><td class="paramname">numberOfBytesRead</td><td>A pointer to a variable that receives the number of bytes transferred into the specified buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the function succeeds; otherwise, <code>false</code>.</dd></dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>struct</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="ab5cc4e43f28a52aa0dd43d853bc16360"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5cc4e43f28a52aa0dd43d853bc16360">&#9670;&nbsp;</a></span>ReadProcessMemory&lt; T &gt;() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool <a class="el" href="class_process_memory_utilities_1_1_memory_1_1_process_memory.html#a06a3864b54170e88527e9b8c277f4d7b">ProcessMemoryUtilities.Memory.ProcessMemory.ReadProcessMemory</a>&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>baseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T []&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads data from an area of memory in a specified process. The entire area to be read must be accessible or the operation fails. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the data to return.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A handle to the process with memory that is being read. The handle must have PROCESS_VM_READ access to the process. </td></tr>
    <tr><td class="paramname">baseAddress</td><td>A pointer to the base address in the specified process from which to read. Before any data transfer occurs, the system verifies that all data in the base address and memory of the specified size is accessible for read access, and if it is not accessible the function fails. </td></tr>
    <tr><td class="paramname">buffer</td><td>A pointer to a buffer that receives the contents from the address space of the specified process.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset inside the buffer to read the data to.</td></tr>
    <tr><td class="paramname">length</td><td>The length of the buffer to fill after the offset.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the function succeeds; otherwise, <code>false</code>.</dd></dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>struct</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="ab5d1ce2f5870e3ae6d377c796f6e6abe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5d1ce2f5870e3ae6d377c796f6e6abe">&#9670;&nbsp;</a></span>ReadProcessMemory&lt; T &gt;() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool <a class="el" href="class_process_memory_utilities_1_1_memory_1_1_process_memory.html#a06a3864b54170e88527e9b8c277f4d7b">ProcessMemoryUtilities.Memory.ProcessMemory.ReadProcessMemory</a>&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>baseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T []&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ref IntPtr&#160;</td>
          <td class="paramname"><em>numberOfBytesRead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads data from an area of memory in a specified process. The entire area to be read must be accessible or the operation fails. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the data to return.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A handle to the process with memory that is being read. The handle must have PROCESS_VM_READ access to the process. </td></tr>
    <tr><td class="paramname">baseAddress</td><td>A pointer to the base address in the specified process from which to read. Before any data transfer occurs, the system verifies that all data in the base address and memory of the specified size is accessible for read access, and if it is not accessible the function fails. </td></tr>
    <tr><td class="paramname">buffer</td><td>A pointer to a buffer that receives the contents from the address space of the specified process.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset inside the buffer to read the data to.</td></tr>
    <tr><td class="paramname">length</td><td>The length of the buffer to fill after the offset.</td></tr>
    <tr><td class="paramname">numberOfBytesRead</td><td>A pointer to a variable that receives the number of bytes transferred into the specified buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the function succeeds; otherwise, <code>false</code>.</dd></dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>struct</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="a724b06cd99f10c68c7e1fc8621ea806e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a724b06cd99f10c68c7e1fc8621ea806e">&#9670;&nbsp;</a></span>VirtualAllocEx()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static IntPtr ProcessMemoryUtilities.Memory.ProcessMemory.VirtualAllocEx </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>baseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_process_memory_utilities_1_1_memory.html#af0a9f9efd6fdb043adf94b1e4d29aff5">AllocationType</a>&#160;</td>
          <td class="paramname"><em>allocationType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_process_memory_utilities_1_1_memory.html#abd2d2d8645ab563c46f8236ab8fe5c0b">MemoryProtectionFlags</a>&#160;</td>
          <td class="paramname"><em>memoryProtection</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reserves, commits, or changes the state of a region of memory within the virtual address space of a specified process. The function initializes the memory it allocates to zero. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>The handle to a process. The function allocates memory within the virtual address space of this process. The handle must have the PROCESS_VM_OPERATION access right.For more information, see Process Security and Access Rights. </td></tr>
    <tr><td class="paramname">baseAddress</td><td>The pointer that specifies a desired starting address for the region of pages that you want to allocate.</td></tr>
    <tr><td class="paramname">size</td><td>The size of the region of memory to allocate, in bytes.</td></tr>
    <tr><td class="paramname">allocationType</td><td>The type of memory allocation.</td></tr>
    <tr><td class="paramname">memoryProtection</td><td>The memory protection for the region of pages to be allocated. If the pages are being committed, you can specify any one of the memory protection constants. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the function succeeds, the return value is the base address of the allocated region of pages. If the function fails, the return value is NULL. </dd></dl>

</div>
</div>
<a id="aa320b99608553ac1050c952e04c68951"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa320b99608553ac1050c952e04c68951">&#9670;&nbsp;</a></span>VirtualFreeEx()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool ProcessMemoryUtilities.Memory.ProcessMemory.VirtualFreeEx </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_process_memory_utilities_1_1_memory.html#acc8b61a7fd031a58cd0679bb7830adcc">FreeType</a>&#160;</td>
          <td class="paramname"><em>freeType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Releases, decommits, or releases and decommits a region of memory within the virtual address space of a specified process. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A handle to a process. The function frees memory within the virtual address space of the process. The handle must have the PROCESS_VM_OPERATION access right.For more information, see Process Security and Access Rights. </td></tr>
    <tr><td class="paramname">address</td><td>A pointer to the starting address of the region of memory to be freed.</td></tr>
    <tr><td class="paramname">size</td><td>The size of the region of memory to free, in bytes. If the dwFreeType parameter is MEM_RELEASE, dwSize must be 0 (zero). </td></tr>
    <tr><td class="paramname">freeType</td><td>The type of free operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the function succeeds; otherwise, <code>false</code>.</dd></dl>

</div>
</div>
<a id="a0002d5bc4f3356c68aea6c808a234df8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0002d5bc4f3356c68aea6c808a234df8">&#9670;&nbsp;</a></span>VirtualProtectEx()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool ProcessMemoryUtilities.Memory.ProcessMemory.VirtualProtectEx </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_process_memory_utilities_1_1_memory.html#abd2d2d8645ab563c46f8236ab8fe5c0b">MemoryProtectionFlags</a>&#160;</td>
          <td class="paramname"><em>newProtect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ref <a class="el" href="namespace_process_memory_utilities_1_1_memory.html#abd2d2d8645ab563c46f8236ab8fe5c0b">MemoryProtectionFlags</a>&#160;</td>
          <td class="paramname"><em>oldProtect</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Changes the protection on a region of committed pages in the virtual address space of a specified process. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A handle to the process whose memory protection is to be changed. The handle must have the PROCESS_VM_OPERATION access right. For more information, see Process Security and Access Rights. </td></tr>
    <tr><td class="paramname">address</td><td>A pointer to the base address of the region of pages whose access protection attributes are to be changed.</td></tr>
    <tr><td class="paramname">size</td><td>The size of the region whose access protection attributes are changed, in bytes.</td></tr>
    <tr><td class="paramname">newProtect</td><td>The memory protection option. This parameter can be one of the memory protection constants.</td></tr>
    <tr><td class="paramname">oldProtect</td><td>A pointer to a variable that receives the previous access protection of the first page in the specified region of pages. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the function succeeds; otherwise, <code>false</code>.</dd></dl>

</div>
</div>
<a id="a9455ae06dd79b621459fa669666e340f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9455ae06dd79b621459fa669666e340f">&#9670;&nbsp;</a></span>WaitForSingleObject()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="namespace_process_memory_utilities_1_1_memory.html#ae642cfe8e18ac29f66f74344aac5b302">WaitObjectResult</a> ProcessMemoryUtilities.Memory.ProcessMemory.WaitForSingleObject </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Waits until the specified object is in the signaled state or the time-out interval elapses. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A handle to the object. For a list of the object types whose handles can be specified, see the following Remarks section. If this handle is closed while the wait is still pending, the function's behavior is undefined. The handle must have the SYNCHRONIZE access right. For more information, see Standard Access Rights. </td></tr>
    <tr><td class="paramname">timeout</td><td>The time-out interval, in milliseconds. If a nonzero value is specified, the function waits until the object is signaled or the interval elapses. If dwMilliseconds is zero, the function does not enter a wait state if the object is not signaled; it always returns immediately. If dwMilliseconds is INFINITE, the function will return only when the object is signaled. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A WaitObjectResult representing the event caused WaitForSingleObject to return.</dd></dl>

</div>
</div>
<a id="a94167b42fa5f7866376caa780d427b26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94167b42fa5f7866376caa780d427b26">&#9670;&nbsp;</a></span>WriteProcessMemory() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool ProcessMemoryUtilities.Memory.ProcessMemory.WriteProcessMemory </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>baseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes data to an area of memory in a specified process. The entire area to be written to must be accessible or the operation fails. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A handle to the process memory to be modified. The handle must have PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process. </td></tr>
    <tr><td class="paramname">baseAddress</td><td>A pointer to the base address in the specified process to which data is written. Before data transfer occurs, the system verifies that all data in the base address and memory of the specified size is accessible for write access, and if it is not accessible, the function fails. </td></tr>
    <tr><td class="paramname">buffer</td><td>A pointer to the buffer that contains data to be written in the address space of the specified process.</td></tr>
    <tr><td class="paramname">size</td><td>The number of bytes to be written to the specified process.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the function succeeds; otherwise, <code>false</code>.</dd></dl>

</div>
</div>
<a id="abc0d34b32cae8c7643454d55be6563f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc0d34b32cae8c7643454d55be6563f6">&#9670;&nbsp;</a></span>WriteProcessMemory() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool ProcessMemoryUtilities.Memory.ProcessMemory.WriteProcessMemory </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>baseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ref IntPtr&#160;</td>
          <td class="paramname"><em>numberOfBytesWritten</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes data to an area of memory in a specified process. The entire area to be written to must be accessible or the operation fails. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A handle to the process memory to be modified. The handle must have PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process. </td></tr>
    <tr><td class="paramname">baseAddress</td><td>A pointer to the base address in the specified process to which data is written. Before data transfer occurs, the system verifies that all data in the base address and memory of the specified size is accessible for write access, and if it is not accessible, the function fails. </td></tr>
    <tr><td class="paramname">buffer</td><td>A pointer to the buffer that contains data to be written in the address space of the specified process.</td></tr>
    <tr><td class="paramname">size</td><td>The number of bytes to be written to the specified process.</td></tr>
    <tr><td class="paramname">numberOfBytesWritten</td><td>A pointer to a variable that receives the number of bytes transferred into the specified process. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the function succeeds; otherwise, <code>false</code>.</dd></dl>

</div>
</div>
<a id="a049334da6fdfcf29afdc7d489f15b731"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a049334da6fdfcf29afdc7d489f15b731">&#9670;&nbsp;</a></span>WriteProcessMemory&lt; T &gt;() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool <a class="el" href="class_process_memory_utilities_1_1_memory_1_1_process_memory.html#a94167b42fa5f7866376caa780d427b26">ProcessMemoryUtilities.Memory.ProcessMemory.WriteProcessMemory</a>&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>baseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes data to an area of memory in a specified process. The entire area to be written to must be accessible or the operation fails. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the data to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A handle to the process memory to be modified. The handle must have PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process. </td></tr>
    <tr><td class="paramname">baseAddress</td><td>A pointer to the base address in the specified process to which data is written. Before data transfer occurs, the system verifies that all data in the base address and memory of the specified size is accessible for write access, and if it is not accessible, the function fails. </td></tr>
    <tr><td class="paramname">buffer</td><td>A pointer to the buffer that contains data to be written in the address space of the specified process.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the function succeeds; otherwise, <code>false</code>.</dd></dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>struct</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="aa2c50c0d4d5133cc3e6c78bcef7db0b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2c50c0d4d5133cc3e6c78bcef7db0b6">&#9670;&nbsp;</a></span>WriteProcessMemory&lt; T &gt;() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool <a class="el" href="class_process_memory_utilities_1_1_memory_1_1_process_memory.html#a94167b42fa5f7866376caa780d427b26">ProcessMemoryUtilities.Memory.ProcessMemory.WriteProcessMemory</a>&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>baseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ref IntPtr&#160;</td>
          <td class="paramname"><em>numberOfBytesWritten</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes data to an area of memory in a specified process. The entire area to be written to must be accessible or the operation fails. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the data to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A handle to the process memory to be modified. The handle must have PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process. </td></tr>
    <tr><td class="paramname">baseAddress</td><td>A pointer to the base address in the specified process to which data is written. Before data transfer occurs, the system verifies that all data in the base address and memory of the specified size is accessible for write access, and if it is not accessible, the function fails. </td></tr>
    <tr><td class="paramname">buffer</td><td>A pointer to the buffer that contains data to be written in the address space of the specified process.</td></tr>
    <tr><td class="paramname">numberOfBytesWritten</td><td>A pointer to a variable that receives the number of bytes transferred into the specified process. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the function succeeds; otherwise, <code>false</code>.</dd></dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>struct</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="a5dea90118559c5802493bf03fca8c7cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dea90118559c5802493bf03fca8c7cb">&#9670;&nbsp;</a></span>WriteProcessMemory&lt; T &gt;() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool <a class="el" href="class_process_memory_utilities_1_1_memory_1_1_process_memory.html#a94167b42fa5f7866376caa780d427b26">ProcessMemoryUtilities.Memory.ProcessMemory.WriteProcessMemory</a>&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>baseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T []&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes data to an area of memory in a specified process. The entire area to be written to must be accessible or the operation fails. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the data to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A handle to the process memory to be modified. The handle must have PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process. </td></tr>
    <tr><td class="paramname">baseAddress</td><td>A pointer to the base address in the specified process to which data is written. Before data transfer occurs, the system verifies that all data in the base address and memory of the specified size is accessible for write access, and if it is not accessible, the function fails. </td></tr>
    <tr><td class="paramname">buffer</td><td>A pointer to the buffer that contains data to be written in the address space of the specified process.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a variable that receives the number of bytes transferred into the specified process.</dd></dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>struct</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="a9dd68d680584092e67d233c1780b871a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dd68d680584092e67d233c1780b871a">&#9670;&nbsp;</a></span>WriteProcessMemory&lt; T &gt;() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool <a class="el" href="class_process_memory_utilities_1_1_memory_1_1_process_memory.html#a94167b42fa5f7866376caa780d427b26">ProcessMemoryUtilities.Memory.ProcessMemory.WriteProcessMemory</a>&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>baseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T []&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ref IntPtr&#160;</td>
          <td class="paramname"><em>numberOfBytesWritten</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes data to an area of memory in a specified process. The entire area to be written to must be accessible or the operation fails. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the data to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A handle to the process memory to be modified. The handle must have PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process. </td></tr>
    <tr><td class="paramname">baseAddress</td><td>A pointer to the base address in the specified process to which data is written. Before data transfer occurs, the system verifies that all data in the base address and memory of the specified size is accessible for write access, and if it is not accessible, the function fails. </td></tr>
    <tr><td class="paramname">buffer</td><td>A pointer to the buffer that contains data to be written in the address space of the specified process.</td></tr>
    <tr><td class="paramname">numberOfBytesWritten</td><td>A pointer to a variable that receives the number of bytes transferred into the specified process. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the function succeeds; otherwise, <code>false</code>.</dd></dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>struct</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="a25e7eb71212fe4336a55ef4159d191c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25e7eb71212fe4336a55ef4159d191c7">&#9670;&nbsp;</a></span>WriteProcessMemory&lt; T &gt;() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool <a class="el" href="class_process_memory_utilities_1_1_memory_1_1_process_memory.html#a94167b42fa5f7866376caa780d427b26">ProcessMemoryUtilities.Memory.ProcessMemory.WriteProcessMemory</a>&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>baseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T []&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes data to an area of memory in a specified process. The entire area to be written to must be accessible or the operation fails. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the data to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A handle to the process memory to be modified. The handle must have PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process. </td></tr>
    <tr><td class="paramname">baseAddress</td><td>A pointer to the base address in the specified process to which data is written. Before data transfer occurs, the system verifies that all data in the base address and memory of the specified size is accessible for write access, and if it is not accessible, the function fails. </td></tr>
    <tr><td class="paramname">buffer</td><td>A pointer to the buffer that contains data to be written in the address space of the specified process.</td></tr>
    <tr><td class="paramname">offset</td><td>The start offset in the buffer array to write data from.</td></tr>
    <tr><td class="paramname">length</td><td>The length of the the buffer to write starting from the offset.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the function succeeds; otherwise, <code>false</code>.</dd></dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>struct</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="a3f50fab813e8c735d802b67c514504cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f50fab813e8c735d802b67c514504cc">&#9670;&nbsp;</a></span>WriteProcessMemory&lt; T &gt;() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool <a class="el" href="class_process_memory_utilities_1_1_memory_1_1_process_memory.html#a94167b42fa5f7866376caa780d427b26">ProcessMemoryUtilities.Memory.ProcessMemory.WriteProcessMemory</a>&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>baseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T []&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ref IntPtr&#160;</td>
          <td class="paramname"><em>numberOfBytesWritten</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes data to an area of memory in a specified process. The entire area to be written to must be accessible or the operation fails. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the data to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A handle to the process memory to be modified. The handle must have PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process. </td></tr>
    <tr><td class="paramname">baseAddress</td><td>A pointer to the base address in the specified process to which data is written. Before data transfer occurs, the system verifies that all data in the base address and memory of the specified size is accessible for write access, and if it is not accessible, the function fails. </td></tr>
    <tr><td class="paramname">buffer</td><td>A pointer to the buffer that contains data to be written in the address space of the specified process.</td></tr>
    <tr><td class="paramname">offset</td><td>The start offset in the buffer array to write data from.</td></tr>
    <tr><td class="paramname">length</td><td>The length of the the buffer to write starting from the offset.</td></tr>
    <tr><td class="paramname">numberOfBytesWritten</td><td>A pointer to a variable that receives the number of bytes transferred into the specified process. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the function succeeds; otherwise, <code>false</code>.</dd></dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>struct</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a1712c63291ca327449972d32a10ebd70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1712c63291ca327449972d32a10ebd70">&#9670;&nbsp;</a></span>PROCESS_ALLOCATE_ACCESS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespace_process_memory_utilities_1_1_memory.html#a9c35275ab4b1a7ff9064f72bf3d5f41a">ProcessAccessFlags</a> ProcessMemoryUtilities.Memory.ProcessMemory.PROCESS_ALLOCATE_ACCESS = <a class="el" href="namespace_process_memory_utilities_1_1_memory.html#a9c35275ab4b1a7ff9064f72bf3d5f41aa03fce4e381fb206d3b66fa0efeaa65b9">ProcessAccessFlags.VirtualMemoryOperation</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A constant to use with OpenProcess when requiring access to allocate memory. </p>

</div>
</div>
<a id="aa933cd43cce65c170c898b0308d3b087"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa933cd43cce65c170c898b0308d3b087">&#9670;&nbsp;</a></span>PROCESS_EXECUTE_ACCESS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespace_process_memory_utilities_1_1_memory.html#a9c35275ab4b1a7ff9064f72bf3d5f41a">ProcessAccessFlags</a> ProcessMemoryUtilities.Memory.ProcessMemory.PROCESS_EXECUTE_ACCESS = <a class="el" href="class_process_memory_utilities_1_1_memory_1_1_process_memory.html#abd875146f1fa0deec6c58d4ffd18f9e8">PROCESS_READ_WRITE_ACCESS</a> | <a class="el" href="class_process_memory_utilities_1_1_memory_1_1_process_memory.html#abc709abb3291737161ebd8af53bbcc4e">PROCESS_INFORMATION_ACCESS</a> | <a class="el" href="namespace_process_memory_utilities_1_1_memory.html#a9c35275ab4b1a7ff9064f72bf3d5f41aad4b9bd5e20476116593b8b68fb08bf57">ProcessAccessFlags.CreateThread</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A constant to use with OpenProcess when requiring access to execute memory. </p>

</div>
</div>
<a id="abc709abb3291737161ebd8af53bbcc4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc709abb3291737161ebd8af53bbcc4e">&#9670;&nbsp;</a></span>PROCESS_INFORMATION_ACCESS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespace_process_memory_utilities_1_1_memory.html#a9c35275ab4b1a7ff9064f72bf3d5f41a">ProcessAccessFlags</a> ProcessMemoryUtilities.Memory.ProcessMemory.PROCESS_INFORMATION_ACCESS = <a class="el" href="namespace_process_memory_utilities_1_1_memory.html#a9c35275ab4b1a7ff9064f72bf3d5f41aa37e8a064723ac3f5eec1e7482f5037f7">ProcessAccessFlags.QueryInformation</a> | <a class="el" href="namespace_process_memory_utilities_1_1_memory.html#a9c35275ab4b1a7ff9064f72bf3d5f41aa2bb5376eb8926e511abaa1f99fed558c">ProcessAccessFlags.QueryLimitedInformation</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A constant to use with OpenProcess when requiring access to informations about the process and its memory. </p>

</div>
</div>
<a id="aa0920c9338271a5d667cab792c1864d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0920c9338271a5d667cab792c1864d6">&#9670;&nbsp;</a></span>PROCESS_READ_ACCESS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespace_process_memory_utilities_1_1_memory.html#a9c35275ab4b1a7ff9064f72bf3d5f41a">ProcessAccessFlags</a> ProcessMemoryUtilities.Memory.ProcessMemory.PROCESS_READ_ACCESS = <a class="el" href="namespace_process_memory_utilities_1_1_memory.html#a9c35275ab4b1a7ff9064f72bf3d5f41aa1097d94adf1ffb4f72859958d1e143fc">ProcessAccessFlags.VirtualMemoryRead</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A constant to be use with OpenProcess when requiring access to read memory. </p>

</div>
</div>
<a id="abd875146f1fa0deec6c58d4ffd18f9e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd875146f1fa0deec6c58d4ffd18f9e8">&#9670;&nbsp;</a></span>PROCESS_READ_WRITE_ACCESS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespace_process_memory_utilities_1_1_memory.html#a9c35275ab4b1a7ff9064f72bf3d5f41a">ProcessAccessFlags</a> ProcessMemoryUtilities.Memory.ProcessMemory.PROCESS_READ_WRITE_ACCESS = <a class="el" href="class_process_memory_utilities_1_1_memory_1_1_process_memory.html#aa0920c9338271a5d667cab792c1864d6">PROCESS_READ_ACCESS</a> | <a class="el" href="class_process_memory_utilities_1_1_memory_1_1_process_memory.html#ab6cbbd17a6b8a953cea236e5a707e623">PROCESS_WRITE_ACCESS</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A constant to be use with OpenProcess when requiring access to read and write memory. </p>

</div>
</div>
<a id="ab6cbbd17a6b8a953cea236e5a707e623"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6cbbd17a6b8a953cea236e5a707e623">&#9670;&nbsp;</a></span>PROCESS_WRITE_ACCESS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespace_process_memory_utilities_1_1_memory.html#a9c35275ab4b1a7ff9064f72bf3d5f41a">ProcessAccessFlags</a> ProcessMemoryUtilities.Memory.ProcessMemory.PROCESS_WRITE_ACCESS = <a class="el" href="namespace_process_memory_utilities_1_1_memory.html#a9c35275ab4b1a7ff9064f72bf3d5f41aa03fce4e381fb206d3b66fa0efeaa65b9">ProcessAccessFlags.VirtualMemoryOperation</a> | <a class="el" href="namespace_process_memory_utilities_1_1_memory.html#a9c35275ab4b1a7ff9064f72bf3d5f41aad81b2f1b0d561c67eac1cfb40ee3b092">ProcessAccessFlags.VirtualMemoryWrite</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A constant to use with OpenProcess when requiring access to write memory. </p>

</div>
</div>
<a id="af46e48b0d74df93cf0b4ba5903c8a25a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af46e48b0d74df93cf0b4ba5903c8a25a">&#9670;&nbsp;</a></span>WAIT_TIMEOUT_INFINITE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint ProcessMemoryUtilities.Memory.ProcessMemory.WAIT_TIMEOUT_INFINITE = uint.MaxValue</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A constant to use with WaitForSingleObject to wait for an infinite amount of time. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>ProcessMemory.cs</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_process_memory_utilities.html">ProcessMemoryUtilities</a></li><li class="navelem"><a class="el" href="namespace_process_memory_utilities_1_1_memory.html">Memory</a></li><li class="navelem"><a class="el" href="class_process_memory_utilities_1_1_memory_1_1_process_memory.html">ProcessMemory</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.15 </li>
  </ul>
</div>
</body>
</html>
