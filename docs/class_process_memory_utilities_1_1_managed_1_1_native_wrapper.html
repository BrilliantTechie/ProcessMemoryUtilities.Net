<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ProcessMemoryUtilities.Net: ProcessMemoryUtilities.Managed.NativeWrapper Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ProcessMemoryUtilities.Net
   &#160;<span id="projectnumber">1.3.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('class_process_memory_utilities_1_1_managed_1_1_native_wrapper.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#properties">Properties</a> &#124;
<a href="class_process_memory_utilities_1_1_managed_1_1_native_wrapper-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ProcessMemoryUtilities.Managed.NativeWrapper Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Provides methods that replicate the behaviour of Kernel32 by using NtDll methods and applies basic error checking.  
 <a href="class_process_memory_utilities_1_1_managed_1_1_native_wrapper.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:adb20652db5b48708aa393508929cf5b2"><td class="memItemLeft" align="right" valign="top">static IntPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_process_memory_utilities_1_1_managed_1_1_native_wrapper.html#adb20652db5b48708aa393508929cf5b2">CreateRemoteThread</a> (IntPtr handle, IntPtr threadAttributes, IntPtr stackSize, IntPtr startAddress, IntPtr parameter, <a class="el" href="namespace_process_memory_utilities_1_1_native.html#a28a597a806a5662bfe6ef8a30725f3f6">ThreadCreationFlags</a> creationFlags, IntPtr threadId)</td></tr>
<tr class="memdesc:adb20652db5b48708aa393508929cf5b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a thread that runs in the virtual address space of another process.  <a href="#adb20652db5b48708aa393508929cf5b2">More...</a><br /></td></tr>
<tr class="separator:adb20652db5b48708aa393508929cf5b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa68430b8589bbf15de26361adc1312c"><td class="memItemLeft" align="right" valign="top">static IntPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_process_memory_utilities_1_1_managed_1_1_native_wrapper.html#afa68430b8589bbf15de26361adc1312c">CreateRemoteThread</a> (IntPtr handle, IntPtr threadAttributes, IntPtr stackSize, IntPtr startAddress, IntPtr parameter, <a class="el" href="namespace_process_memory_utilities_1_1_native.html#a28a597a806a5662bfe6ef8a30725f3f6">ThreadCreationFlags</a> creationFlags, out uint threadId)</td></tr>
<tr class="memdesc:afa68430b8589bbf15de26361adc1312c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a thread that runs in the virtual address space of another process.  <a href="#afa68430b8589bbf15de26361adc1312c">More...</a><br /></td></tr>
<tr class="separator:afa68430b8589bbf15de26361adc1312c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa339b14ac7aa9aa5bd392ef1449e7a6e"><td class="memItemLeft" align="right" valign="top">static IntPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_process_memory_utilities_1_1_managed_1_1_native_wrapper.html#aa339b14ac7aa9aa5bd392ef1449e7a6e">CreateRemoteThread</a> (IntPtr handle, IntPtr startAddress, IntPtr parameter, <a class="el" href="namespace_process_memory_utilities_1_1_native.html#a28a597a806a5662bfe6ef8a30725f3f6">ThreadCreationFlags</a> creationFlags)</td></tr>
<tr class="memdesc:aa339b14ac7aa9aa5bd392ef1449e7a6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a thread that runs in the virtual address space of another process.  <a href="#aa339b14ac7aa9aa5bd392ef1449e7a6e">More...</a><br /></td></tr>
<tr class="separator:aa339b14ac7aa9aa5bd392ef1449e7a6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87c13c086ddcd1e24af645df013b1898"><td class="memItemLeft" align="right" valign="top">static IntPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_process_memory_utilities_1_1_managed_1_1_native_wrapper.html#a87c13c086ddcd1e24af645df013b1898">CreateRemoteThread</a> (IntPtr handle, IntPtr startAddress, IntPtr parameter, <a class="el" href="namespace_process_memory_utilities_1_1_native.html#a28a597a806a5662bfe6ef8a30725f3f6">ThreadCreationFlags</a> creationFlags, out uint threadId)</td></tr>
<tr class="memdesc:a87c13c086ddcd1e24af645df013b1898"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a thread that runs in the virtual address space of another process.  <a href="#a87c13c086ddcd1e24af645df013b1898">More...</a><br /></td></tr>
<tr class="separator:a87c13c086ddcd1e24af645df013b1898"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a821dad005027861a9702eb6d0a5ec2ee"><td class="memItemLeft" align="right" valign="top">static IntPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_process_memory_utilities_1_1_managed_1_1_native_wrapper.html#a821dad005027861a9702eb6d0a5ec2ee">CreateRemoteThread</a> (IntPtr handle, IntPtr startAddress, IntPtr parameter)</td></tr>
<tr class="memdesc:a821dad005027861a9702eb6d0a5ec2ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a thread that runs in the virtual address space of another process.  <a href="#a821dad005027861a9702eb6d0a5ec2ee">More...</a><br /></td></tr>
<tr class="separator:a821dad005027861a9702eb6d0a5ec2ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab896a0dabdfb0733246b0a58152b4ef3"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespace_process_memory_utilities_1_1_native.html#a06054dd813bba2514407e29f39095dd7">WaitObjectResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_process_memory_utilities_1_1_managed_1_1_native_wrapper.html#ab896a0dabdfb0733246b0a58152b4ef3">WaitForSingleObject</a> (IntPtr handle, uint timeout)</td></tr>
<tr class="memdesc:ab896a0dabdfb0733246b0a58152b4ef3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits until the specified object is in the signaled state or the time-out interval elapses.  <a href="#ab896a0dabdfb0733246b0a58152b4ef3">More...</a><br /></td></tr>
<tr class="separator:ab896a0dabdfb0733246b0a58152b4ef3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c1c17e9a97888121a4156e65f6a8324"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespace_process_memory_utilities_1_1_native.html#a06054dd813bba2514407e29f39095dd7">WaitObjectResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_process_memory_utilities_1_1_managed_1_1_native_wrapper.html#a7c1c17e9a97888121a4156e65f6a8324">GetRealWaitObjectResult</a> (<a class="el" href="namespace_process_memory_utilities_1_1_native.html#a06054dd813bba2514407e29f39095dd7">WaitObjectResult</a> value)</td></tr>
<tr class="memdesc:a7c1c17e9a97888121a4156e65f6a8324"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turns the given WaitObjectResult into one of the defined enum values by stripping the objects index.  <a href="#a7c1c17e9a97888121a4156e65f6a8324">More...</a><br /></td></tr>
<tr class="separator:a7c1c17e9a97888121a4156e65f6a8324"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbfb32f9450f7b5ac3368a1947364b2b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespace_process_memory_utilities_1_1_native.html#a06054dd813bba2514407e29f39095dd7">WaitObjectResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_process_memory_utilities_1_1_managed_1_1_native_wrapper.html#acbfb32f9450f7b5ac3368a1947364b2b">GetRealWaitObjectResult</a> (<a class="el" href="namespace_process_memory_utilities_1_1_native.html#a06054dd813bba2514407e29f39095dd7">WaitObjectResult</a> value, out int index)</td></tr>
<tr class="memdesc:acbfb32f9450f7b5ac3368a1947364b2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turns the given WaitObjectResult into one of the defined enum values and returns the objects index.  <a href="#acbfb32f9450f7b5ac3368a1947364b2b">More...</a><br /></td></tr>
<tr class="separator:acbfb32f9450f7b5ac3368a1947364b2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab821e7e67ea07fc9e7d16cda454bbf06"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_process_memory_utilities_1_1_managed_1_1_native_wrapper.html#ab821e7e67ea07fc9e7d16cda454bbf06">CloseHandle</a> (IntPtr handle)</td></tr>
<tr class="memdesc:ab821e7e67ea07fc9e7d16cda454bbf06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes an open object handle.  <a href="#ab821e7e67ea07fc9e7d16cda454bbf06">More...</a><br /></td></tr>
<tr class="separator:ab821e7e67ea07fc9e7d16cda454bbf06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a124ac6635ca029c0e7d2ae8da8961328"><td class="memItemLeft" align="right" valign="top">static IntPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_process_memory_utilities_1_1_managed_1_1_native_wrapper.html#a124ac6635ca029c0e7d2ae8da8961328">OpenProcess</a> (<a class="el" href="namespace_process_memory_utilities_1_1_native.html#abdfccb438f768cae26c138a43489d2ff">ProcessAccessFlags</a> desiredAccess, bool inheritHandle, int processId)</td></tr>
<tr class="memdesc:a124ac6635ca029c0e7d2ae8da8961328"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens an existing local process object.  <a href="#a124ac6635ca029c0e7d2ae8da8961328">More...</a><br /></td></tr>
<tr class="separator:a124ac6635ca029c0e7d2ae8da8961328"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c15196764d44ecf1b7b3b75bea2c37c"><td class="memItemLeft" align="right" valign="top">static IntPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_process_memory_utilities_1_1_managed_1_1_native_wrapper.html#a7c15196764d44ecf1b7b3b75bea2c37c">OpenProcess</a> (<a class="el" href="namespace_process_memory_utilities_1_1_native.html#abdfccb438f768cae26c138a43489d2ff">ProcessAccessFlags</a> desiredAccess, int processId)</td></tr>
<tr class="memdesc:a7c15196764d44ecf1b7b3b75bea2c37c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens an existing local process object.  <a href="#a7c15196764d44ecf1b7b3b75bea2c37c">More...</a><br /></td></tr>
<tr class="separator:a7c15196764d44ecf1b7b3b75bea2c37c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acff20133812ec266c51b2b3aa0c4f233"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_process_memory_utilities_1_1_managed_1_1_native_wrapper.html#acff20133812ec266c51b2b3aa0c4f233">ReadProcessMemory</a> (IntPtr handle, IntPtr baseAddress, IntPtr buffer, IntPtr size)</td></tr>
<tr class="memdesc:acff20133812ec266c51b2b3aa0c4f233"><td class="mdescLeft">&#160;</td><td class="mdescRight">ReadProcessMemory copies the data in the specified address range from the address space of the specified process into the specified buffer of the current process. Any process that has a handle with PROCESS_VM_READ access can call the function. The entire area to be read must be accessible, and if it is not accessible, the function fails.  <a href="#acff20133812ec266c51b2b3aa0c4f233">More...</a><br /></td></tr>
<tr class="separator:acff20133812ec266c51b2b3aa0c4f233"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac912a12aa0fdf76cc6af2bb3c3b42d17"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_process_memory_utilities_1_1_managed_1_1_native_wrapper.html#ac912a12aa0fdf76cc6af2bb3c3b42d17">ReadProcessMemory</a> (IntPtr handle, IntPtr baseAddress, IntPtr buffer, IntPtr size, IntPtr numberOfBytesRead)</td></tr>
<tr class="memdesc:ac912a12aa0fdf76cc6af2bb3c3b42d17"><td class="mdescLeft">&#160;</td><td class="mdescRight">ReadProcessMemory copies the data in the specified address range from the address space of the specified process into the specified buffer of the current process. Any process that has a handle with PROCESS_VM_READ access can call the function. The entire area to be read must be accessible, and if it is not accessible, the function fails.  <a href="#ac912a12aa0fdf76cc6af2bb3c3b42d17">More...</a><br /></td></tr>
<tr class="separator:ac912a12aa0fdf76cc6af2bb3c3b42d17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03602a286de615dcbea639c63a86c82c"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_process_memory_utilities_1_1_managed_1_1_native_wrapper.html#a03602a286de615dcbea639c63a86c82c">ReadProcessMemory</a> (IntPtr handle, IntPtr baseAddress, IntPtr buffer, IntPtr size, out IntPtr numberOfBytesRead)</td></tr>
<tr class="memdesc:a03602a286de615dcbea639c63a86c82c"><td class="mdescLeft">&#160;</td><td class="mdescRight">ReadProcessMemory copies the data in the specified address range from the address space of the specified process into the specified buffer of the current process. Any process that has a handle with PROCESS_VM_READ access can call the function. The entire area to be read must be accessible, and if it is not accessible, the function fails.  <a href="#a03602a286de615dcbea639c63a86c82c">More...</a><br /></td></tr>
<tr class="separator:a03602a286de615dcbea639c63a86c82c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcb57ffe44a9195e1a3dbeba7cf5d616"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_process_memory_utilities_1_1_managed_1_1_native_wrapper.html#afcb57ffe44a9195e1a3dbeba7cf5d616">ReadProcessMemory&lt; T &gt;</a> (IntPtr handle, IntPtr baseAddress, ref T buffer)</td></tr>
<tr class="memdesc:afcb57ffe44a9195e1a3dbeba7cf5d616"><td class="mdescLeft">&#160;</td><td class="mdescRight">ReadProcessMemory copies the data in the specified address range from the address space of the specified process into the specified buffer of the current process. Any process that has a handle with PROCESS_VM_READ access can call the function. The entire area to be read must be accessible, and if it is not accessible, the function fails.  <a href="#afcb57ffe44a9195e1a3dbeba7cf5d616">More...</a><br /></td></tr>
<tr class="separator:afcb57ffe44a9195e1a3dbeba7cf5d616"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfed5fb5f0e53735af91a1b3877b77d3"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_process_memory_utilities_1_1_managed_1_1_native_wrapper.html#adfed5fb5f0e53735af91a1b3877b77d3">ReadProcessMemory&lt; T &gt;</a> (IntPtr handle, IntPtr baseAddress, ref T buffer, out IntPtr numberOfBytesRead)</td></tr>
<tr class="memdesc:adfed5fb5f0e53735af91a1b3877b77d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">ReadProcessMemory copies the data in the specified address range from the address space of the specified process into the specified buffer of the current process. Any process that has a handle with PROCESS_VM_READ access can call the function. The entire area to be read must be accessible, and if it is not accessible, the function fails.  <a href="#adfed5fb5f0e53735af91a1b3877b77d3">More...</a><br /></td></tr>
<tr class="separator:adfed5fb5f0e53735af91a1b3877b77d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5096df2cd0981c4e5658e93ad336ec5d"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_process_memory_utilities_1_1_managed_1_1_native_wrapper.html#a5096df2cd0981c4e5658e93ad336ec5d">ReadProcessMemoryArray&lt; T &gt;</a> (IntPtr handle, IntPtr baseAddress, T[] buffer)</td></tr>
<tr class="memdesc:a5096df2cd0981c4e5658e93ad336ec5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">ReadProcessMemory copies the data in the specified address range from the address space of the specified process into the specified buffer of the current process. Any process that has a handle with PROCESS_VM_READ access can call the function. The entire area to be read must be accessible, and if it is not accessible, the function fails.  <a href="#a5096df2cd0981c4e5658e93ad336ec5d">More...</a><br /></td></tr>
<tr class="separator:a5096df2cd0981c4e5658e93ad336ec5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8bf9082edfa319a6c707c34aef3678a"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_process_memory_utilities_1_1_managed_1_1_native_wrapper.html#af8bf9082edfa319a6c707c34aef3678a">ReadProcessMemoryArray&lt; T &gt;</a> (IntPtr handle, IntPtr baseAddress, T[] buffer, int offset)</td></tr>
<tr class="memdesc:af8bf9082edfa319a6c707c34aef3678a"><td class="mdescLeft">&#160;</td><td class="mdescRight">ReadProcessMemory copies the data in the specified address range from the address space of the specified process into the specified buffer of the current process. Any process that has a handle with PROCESS_VM_READ access can call the function. The entire area to be read must be accessible, and if it is not accessible, the function fails.  <a href="#af8bf9082edfa319a6c707c34aef3678a">More...</a><br /></td></tr>
<tr class="separator:af8bf9082edfa319a6c707c34aef3678a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a66a9e197e2b7298812e9914ec2af54"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_process_memory_utilities_1_1_managed_1_1_native_wrapper.html#a0a66a9e197e2b7298812e9914ec2af54">ReadProcessMemoryArray&lt; T &gt;</a> (IntPtr handle, IntPtr baseAddress, T[] buffer, out IntPtr numberOfBytesRead)</td></tr>
<tr class="memdesc:a0a66a9e197e2b7298812e9914ec2af54"><td class="mdescLeft">&#160;</td><td class="mdescRight">ReadProcessMemory copies the data in the specified address range from the address space of the specified process into the specified buffer of the current process. Any process that has a handle with PROCESS_VM_READ access can call the function. The entire area to be read must be accessible, and if it is not accessible, the function fails.  <a href="#a0a66a9e197e2b7298812e9914ec2af54">More...</a><br /></td></tr>
<tr class="separator:a0a66a9e197e2b7298812e9914ec2af54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12165e424a3fa98668db371418067482"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_process_memory_utilities_1_1_managed_1_1_native_wrapper.html#a12165e424a3fa98668db371418067482">ReadProcessMemoryArray&lt; T &gt;</a> (IntPtr handle, IntPtr baseAddress, T[] buffer, int offset, int length)</td></tr>
<tr class="memdesc:a12165e424a3fa98668db371418067482"><td class="mdescLeft">&#160;</td><td class="mdescRight">ReadProcessMemory copies the data in the specified address range from the address space of the specified process into the specified buffer of the current process. Any process that has a handle with PROCESS_VM_READ access can call the function. The entire area to be read must be accessible, and if it is not accessible, the function fails.  <a href="#a12165e424a3fa98668db371418067482">More...</a><br /></td></tr>
<tr class="separator:a12165e424a3fa98668db371418067482"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6434b29145d7205e0cb5065bb475a935"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_process_memory_utilities_1_1_managed_1_1_native_wrapper.html#a6434b29145d7205e0cb5065bb475a935">ReadProcessMemoryArray&lt; T &gt;</a> (IntPtr handle, IntPtr baseAddress, T[] buffer, int offset, out IntPtr numberOfBytesRead)</td></tr>
<tr class="memdesc:a6434b29145d7205e0cb5065bb475a935"><td class="mdescLeft">&#160;</td><td class="mdescRight">ReadProcessMemory copies the data in the specified address range from the address space of the specified process into the specified buffer of the current process. Any process that has a handle with PROCESS_VM_READ access can call the function. The entire area to be read must be accessible, and if it is not accessible, the function fails.  <a href="#a6434b29145d7205e0cb5065bb475a935">More...</a><br /></td></tr>
<tr class="separator:a6434b29145d7205e0cb5065bb475a935"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfb3ca33e82573e948ac81768f5a0ab6"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_process_memory_utilities_1_1_managed_1_1_native_wrapper.html#abfb3ca33e82573e948ac81768f5a0ab6">ReadProcessMemoryArray&lt; T &gt;</a> (IntPtr handle, IntPtr baseAddress, T[] buffer, int offset, int length, out IntPtr numberOfBytesRead)</td></tr>
<tr class="memdesc:abfb3ca33e82573e948ac81768f5a0ab6"><td class="mdescLeft">&#160;</td><td class="mdescRight">ReadProcessMemory copies the data in the specified address range from the address space of the specified process into the specified buffer of the current process. Any process that has a handle with PROCESS_VM_READ access can call the function. The entire area to be read must be accessible, and if it is not accessible, the function fails.  <a href="#abfb3ca33e82573e948ac81768f5a0ab6">More...</a><br /></td></tr>
<tr class="separator:abfb3ca33e82573e948ac81768f5a0ab6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c8564de38950e24e1a4936a4b4147fa"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_process_memory_utilities_1_1_managed_1_1_native_wrapper.html#a9c8564de38950e24e1a4936a4b4147fa">ReadProcessMemoryPartial&lt; T &gt;</a> (IntPtr handle, IntPtr baseAddress, ref T buffer, int offset)</td></tr>
<tr class="memdesc:a9c8564de38950e24e1a4936a4b4147fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">ReadProcessMemory copies the data in the specified address range from the address space of the specified process into the specified buffer of the current process. Any process that has a handle with PROCESS_VM_READ access can call the function. The entire area to be read must be accessible, and if it is not accessible, the function fails.  <a href="#a9c8564de38950e24e1a4936a4b4147fa">More...</a><br /></td></tr>
<tr class="separator:a9c8564de38950e24e1a4936a4b4147fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c02ddfbe6a8cdfea10a6d03d5041259"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_process_memory_utilities_1_1_managed_1_1_native_wrapper.html#a0c02ddfbe6a8cdfea10a6d03d5041259">ReadProcessMemoryPartial&lt; T &gt;</a> (IntPtr handle, IntPtr baseAddress, ref T buffer, int offset, int length)</td></tr>
<tr class="memdesc:a0c02ddfbe6a8cdfea10a6d03d5041259"><td class="mdescLeft">&#160;</td><td class="mdescRight">ReadProcessMemory copies the data in the specified address range from the address space of the specified process into the specified buffer of the current process. Any process that has a handle with PROCESS_VM_READ access can call the function. The entire area to be read must be accessible, and if it is not accessible, the function fails.  <a href="#a0c02ddfbe6a8cdfea10a6d03d5041259">More...</a><br /></td></tr>
<tr class="separator:a0c02ddfbe6a8cdfea10a6d03d5041259"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15e98789a60efea90b1ec84c04c46e75"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_process_memory_utilities_1_1_managed_1_1_native_wrapper.html#a15e98789a60efea90b1ec84c04c46e75">ReadProcessMemoryPartial&lt; T &gt;</a> (IntPtr handle, IntPtr baseAddress, ref T buffer, int offset, out IntPtr numberOfBytesRead)</td></tr>
<tr class="memdesc:a15e98789a60efea90b1ec84c04c46e75"><td class="mdescLeft">&#160;</td><td class="mdescRight">ReadProcessMemory copies the data in the specified address range from the address space of the specified process into the specified buffer of the current process. Any process that has a handle with PROCESS_VM_READ access can call the function. The entire area to be read must be accessible, and if it is not accessible, the function fails.  <a href="#a15e98789a60efea90b1ec84c04c46e75">More...</a><br /></td></tr>
<tr class="separator:a15e98789a60efea90b1ec84c04c46e75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17332ff1c1f71050406f14794099fd9d"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_process_memory_utilities_1_1_managed_1_1_native_wrapper.html#a17332ff1c1f71050406f14794099fd9d">ReadProcessMemoryPartial&lt; T &gt;</a> (IntPtr handle, IntPtr baseAddress, ref T buffer, int offset, int length, out IntPtr numberOfBytesRead)</td></tr>
<tr class="memdesc:a17332ff1c1f71050406f14794099fd9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">ReadProcessMemory copies the data in the specified address range from the address space of the specified process into the specified buffer of the current process. Any process that has a handle with PROCESS_VM_READ access can call the function. The entire area to be read must be accessible, and if it is not accessible, the function fails.  <a href="#a17332ff1c1f71050406f14794099fd9d">More...</a><br /></td></tr>
<tr class="separator:a17332ff1c1f71050406f14794099fd9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f6f90b68dfc121d515d10b6be5211e2"><td class="memItemLeft" align="right" valign="top">static IntPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_process_memory_utilities_1_1_managed_1_1_native_wrapper.html#a1f6f90b68dfc121d515d10b6be5211e2">VirtualAllocEx</a> (IntPtr handle, IntPtr address, IntPtr size, <a class="el" href="namespace_process_memory_utilities_1_1_native.html#a0729ee4af770ea067d43d9761df4cbdb">AllocationType</a> allocationType, <a class="el" href="namespace_process_memory_utilities_1_1_native.html#a253e5867c7af9a40486194ce6ab3cf53">MemoryProtectionFlags</a> memoryProtection)</td></tr>
<tr class="memdesc:a1f6f90b68dfc121d515d10b6be5211e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserves, commits, or changes the state of a region of memory within the virtual address space of a specified process. The function initializes the memory it allocates to zero.  <a href="#a1f6f90b68dfc121d515d10b6be5211e2">More...</a><br /></td></tr>
<tr class="separator:a1f6f90b68dfc121d515d10b6be5211e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fd48ae1b89c03df5c0f9e8bddff04be"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_process_memory_utilities_1_1_managed_1_1_native_wrapper.html#a3fd48ae1b89c03df5c0f9e8bddff04be">VirtualFreeEx</a> (IntPtr handle, IntPtr address, IntPtr size, <a class="el" href="namespace_process_memory_utilities_1_1_native.html#adb58001ff27279e48c274189fcab7293">FreeType</a> freeType)</td></tr>
<tr class="memdesc:a3fd48ae1b89c03df5c0f9e8bddff04be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases, decommits, or releases and decommits a region of memory within the virtual address space of a specified process.  <a href="#a3fd48ae1b89c03df5c0f9e8bddff04be">More...</a><br /></td></tr>
<tr class="separator:a3fd48ae1b89c03df5c0f9e8bddff04be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82e16f721cdab8076df60e86cf79c037"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_process_memory_utilities_1_1_managed_1_1_native_wrapper.html#a82e16f721cdab8076df60e86cf79c037">VirtualProtectEx</a> (IntPtr handle, IntPtr address, IntPtr size, <a class="el" href="namespace_process_memory_utilities_1_1_native.html#a253e5867c7af9a40486194ce6ab3cf53">MemoryProtectionFlags</a> newProtect, out <a class="el" href="namespace_process_memory_utilities_1_1_native.html#a253e5867c7af9a40486194ce6ab3cf53">MemoryProtectionFlags</a> oldProtect)</td></tr>
<tr class="memdesc:a82e16f721cdab8076df60e86cf79c037"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the protection on a region of committed pages in the virtual address space of a specified process.  <a href="#a82e16f721cdab8076df60e86cf79c037">More...</a><br /></td></tr>
<tr class="separator:a82e16f721cdab8076df60e86cf79c037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f1dad17da6e726c557e73dee12da987"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_process_memory_utilities_1_1_managed_1_1_native_wrapper.html#a0f1dad17da6e726c557e73dee12da987">WriteProcessMemory</a> (IntPtr handle, IntPtr baseAddress, IntPtr buffer, IntPtr size)</td></tr>
<tr class="memdesc:a0f1dad17da6e726c557e73dee12da987"><td class="mdescLeft">&#160;</td><td class="mdescRight">WriteProcessMemory copies the data from the specified buffer in the current process to the address range of the specified process. Any process that has a handle with PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process to be written to can call the function. Typically but not always, the process with address space that is being written to is being debugged. The entire area to be written to must be accessible, and if it is not accessible, the function fails.  <a href="#a0f1dad17da6e726c557e73dee12da987">More...</a><br /></td></tr>
<tr class="separator:a0f1dad17da6e726c557e73dee12da987"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae73367ec26c6fddc69393d1d287e51dd"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_process_memory_utilities_1_1_managed_1_1_native_wrapper.html#ae73367ec26c6fddc69393d1d287e51dd">WriteProcessMemory</a> (IntPtr handle, IntPtr baseAddress, IntPtr buffer, IntPtr size, IntPtr numberOfBytesWritten)</td></tr>
<tr class="memdesc:ae73367ec26c6fddc69393d1d287e51dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">WriteProcessMemory copies the data from the specified buffer in the current process to the address range of the specified process. Any process that has a handle with PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process to be written to can call the function. Typically but not always, the process with address space that is being written to is being debugged. The entire area to be written to must be accessible, and if it is not accessible, the function fails.  <a href="#ae73367ec26c6fddc69393d1d287e51dd">More...</a><br /></td></tr>
<tr class="separator:ae73367ec26c6fddc69393d1d287e51dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1273a16a34ee99062748694ed81103e3"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_process_memory_utilities_1_1_managed_1_1_native_wrapper.html#a1273a16a34ee99062748694ed81103e3">WriteProcessMemory</a> (IntPtr handle, IntPtr baseAddress, IntPtr buffer, IntPtr size, out IntPtr numberOfBytesWritten)</td></tr>
<tr class="memdesc:a1273a16a34ee99062748694ed81103e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">WriteProcessMemory copies the data from the specified buffer in the current process to the address range of the specified process. Any process that has a handle with PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process to be written to can call the function. Typically but not always, the process with address space that is being written to is being debugged. The entire area to be written to must be accessible, and if it is not accessible, the function fails.  <a href="#a1273a16a34ee99062748694ed81103e3">More...</a><br /></td></tr>
<tr class="separator:a1273a16a34ee99062748694ed81103e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a569e2c9363f3576870c616ba2c913f91"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_process_memory_utilities_1_1_managed_1_1_native_wrapper.html#a569e2c9363f3576870c616ba2c913f91">WriteProcessMemory&lt; T &gt;</a> (IntPtr handle, IntPtr baseAddress, ref T buffer)</td></tr>
<tr class="memdesc:a569e2c9363f3576870c616ba2c913f91"><td class="mdescLeft">&#160;</td><td class="mdescRight">WriteProcessMemory copies the data from the specified buffer in the current process to the address range of the specified process. Any process that has a handle with PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process to be written to can call the function. Typically but not always, the process with address space that is being written to is being debugged. The entire area to be written to must be accessible, and if it is not accessible, the function fails.  <a href="#a569e2c9363f3576870c616ba2c913f91">More...</a><br /></td></tr>
<tr class="separator:a569e2c9363f3576870c616ba2c913f91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba19108ae34c75275e5c47c2d9c8d41f"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_process_memory_utilities_1_1_managed_1_1_native_wrapper.html#aba19108ae34c75275e5c47c2d9c8d41f">WriteProcessMemory&lt; T &gt;</a> (IntPtr handle, IntPtr baseAddress, ref T buffer, out IntPtr numberOfBytesWritten)</td></tr>
<tr class="memdesc:aba19108ae34c75275e5c47c2d9c8d41f"><td class="mdescLeft">&#160;</td><td class="mdescRight">WriteProcessMemory copies the data from the specified buffer in the current process to the address range of the specified process. Any process that has a handle with PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process to be written to can call the function. Typically but not always, the process with address space that is being written to is being debugged. The entire area to be written to must be accessible, and if it is not accessible, the function fails.  <a href="#aba19108ae34c75275e5c47c2d9c8d41f">More...</a><br /></td></tr>
<tr class="separator:aba19108ae34c75275e5c47c2d9c8d41f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adadd980912376194f29733793663af46"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_process_memory_utilities_1_1_managed_1_1_native_wrapper.html#adadd980912376194f29733793663af46">WriteProcessMemoryArray&lt; T &gt;</a> (IntPtr handle, IntPtr baseAddress, T[] buffer)</td></tr>
<tr class="memdesc:adadd980912376194f29733793663af46"><td class="mdescLeft">&#160;</td><td class="mdescRight">WriteProcessMemory copies the data from the specified buffer in the current process to the address range of the specified process. Any process that has a handle with PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process to be written to can call the function. Typically but not always, the process with address space that is being written to is being debugged. The entire area to be written to must be accessible, and if it is not accessible, the function fails.  <a href="#adadd980912376194f29733793663af46">More...</a><br /></td></tr>
<tr class="separator:adadd980912376194f29733793663af46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56e55cb15045110682306bbd987d62b9"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_process_memory_utilities_1_1_managed_1_1_native_wrapper.html#a56e55cb15045110682306bbd987d62b9">WriteProcessMemoryArray&lt; T &gt;</a> (IntPtr handle, IntPtr baseAddress, T[] buffer, int offset)</td></tr>
<tr class="memdesc:a56e55cb15045110682306bbd987d62b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">WriteProcessMemory copies the data from the specified buffer in the current process to the address range of the specified process. Any process that has a handle with PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process to be written to can call the function. Typically but not always, the process with address space that is being written to is being debugged. The entire area to be written to must be accessible, and if it is not accessible, the function fails.  <a href="#a56e55cb15045110682306bbd987d62b9">More...</a><br /></td></tr>
<tr class="separator:a56e55cb15045110682306bbd987d62b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc2e07dc25f1b6a9cccb545e8570785e"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_process_memory_utilities_1_1_managed_1_1_native_wrapper.html#afc2e07dc25f1b6a9cccb545e8570785e">WriteProcessMemoryArray&lt; T &gt;</a> (IntPtr handle, IntPtr baseAddress, T[] buffer, out IntPtr numberOfBytesWritten)</td></tr>
<tr class="memdesc:afc2e07dc25f1b6a9cccb545e8570785e"><td class="mdescLeft">&#160;</td><td class="mdescRight">WriteProcessMemory copies the data from the specified buffer in the current process to the address range of the specified process. Any process that has a handle with PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process to be written to can call the function. Typically but not always, the process with address space that is being written to is being debugged. The entire area to be written to must be accessible, and if it is not accessible, the function fails.  <a href="#afc2e07dc25f1b6a9cccb545e8570785e">More...</a><br /></td></tr>
<tr class="separator:afc2e07dc25f1b6a9cccb545e8570785e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d83446ef8807252a24671e2a23be409"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_process_memory_utilities_1_1_managed_1_1_native_wrapper.html#a3d83446ef8807252a24671e2a23be409">WriteProcessMemoryArray&lt; T &gt;</a> (IntPtr handle, IntPtr baseAddress, T[] buffer, int offset, int length)</td></tr>
<tr class="memdesc:a3d83446ef8807252a24671e2a23be409"><td class="mdescLeft">&#160;</td><td class="mdescRight">WriteProcessMemory copies the data from the specified buffer in the current process to the address range of the specified process. Any process that has a handle with PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process to be written to can call the function. Typically but not always, the process with address space that is being written to is being debugged. The entire area to be written to must be accessible, and if it is not accessible, the function fails.  <a href="#a3d83446ef8807252a24671e2a23be409">More...</a><br /></td></tr>
<tr class="separator:a3d83446ef8807252a24671e2a23be409"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f802e4bc396ae91859e26092e32f670"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_process_memory_utilities_1_1_managed_1_1_native_wrapper.html#a1f802e4bc396ae91859e26092e32f670">WriteProcessMemoryArray&lt; T &gt;</a> (IntPtr handle, IntPtr baseAddress, T[] buffer, int offset, out IntPtr numberOfBytesWritten)</td></tr>
<tr class="memdesc:a1f802e4bc396ae91859e26092e32f670"><td class="mdescLeft">&#160;</td><td class="mdescRight">WriteProcessMemory copies the data from the specified buffer in the current process to the address range of the specified process. Any process that has a handle with PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process to be written to can call the function. Typically but not always, the process with address space that is being written to is being debugged. The entire area to be written to must be accessible, and if it is not accessible, the function fails.  <a href="#a1f802e4bc396ae91859e26092e32f670">More...</a><br /></td></tr>
<tr class="separator:a1f802e4bc396ae91859e26092e32f670"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab89dd53f15cd037288cda51255385343"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_process_memory_utilities_1_1_managed_1_1_native_wrapper.html#ab89dd53f15cd037288cda51255385343">WriteProcessMemoryArray&lt; T &gt;</a> (IntPtr handle, IntPtr baseAddress, T[] buffer, int offset, int length, out IntPtr numberOfBytesWritten)</td></tr>
<tr class="memdesc:ab89dd53f15cd037288cda51255385343"><td class="mdescLeft">&#160;</td><td class="mdescRight">WriteProcessMemory copies the data from the specified buffer in the current process to the address range of the specified process. Any process that has a handle with PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process to be written to can call the function. Typically but not always, the process with address space that is being written to is being debugged. The entire area to be written to must be accessible, and if it is not accessible, the function fails.  <a href="#ab89dd53f15cd037288cda51255385343">More...</a><br /></td></tr>
<tr class="separator:ab89dd53f15cd037288cda51255385343"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a176b201c8312fe19a24bf4b641e434a3"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_process_memory_utilities_1_1_managed_1_1_native_wrapper.html#a176b201c8312fe19a24bf4b641e434a3">WriteProcessMemoryPartial&lt; T &gt;</a> (IntPtr handle, IntPtr baseAddress, ref T buffer, int offset)</td></tr>
<tr class="memdesc:a176b201c8312fe19a24bf4b641e434a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">WriteProcessMemory copies the data from the specified buffer in the current process to the address range of the specified process. Any process that has a handle with PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process to be written to can call the function. Typically but not always, the process with address space that is being written to is being debugged. The entire area to be written to must be accessible, and if it is not accessible, the function fails.  <a href="#a176b201c8312fe19a24bf4b641e434a3">More...</a><br /></td></tr>
<tr class="separator:a176b201c8312fe19a24bf4b641e434a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff408e636055f64b89e8a80e1f02175b"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_process_memory_utilities_1_1_managed_1_1_native_wrapper.html#aff408e636055f64b89e8a80e1f02175b">WriteProcessMemoryPartial&lt; T &gt;</a> (IntPtr handle, IntPtr baseAddress, ref T buffer, int offset, int length)</td></tr>
<tr class="memdesc:aff408e636055f64b89e8a80e1f02175b"><td class="mdescLeft">&#160;</td><td class="mdescRight">WriteProcessMemory copies the data from the specified buffer in the current process to the address range of the specified process. Any process that has a handle with PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process to be written to can call the function. Typically but not always, the process with address space that is being written to is being debugged. The entire area to be written to must be accessible, and if it is not accessible, the function fails.  <a href="#aff408e636055f64b89e8a80e1f02175b">More...</a><br /></td></tr>
<tr class="separator:aff408e636055f64b89e8a80e1f02175b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa066859002c8c3f8a31e80140e15c73c"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_process_memory_utilities_1_1_managed_1_1_native_wrapper.html#aa066859002c8c3f8a31e80140e15c73c">WriteProcessMemoryPartial&lt; T &gt;</a> (IntPtr handle, IntPtr baseAddress, ref T buffer, int offset, out IntPtr numberOfBytesWritten)</td></tr>
<tr class="memdesc:aa066859002c8c3f8a31e80140e15c73c"><td class="mdescLeft">&#160;</td><td class="mdescRight">WriteProcessMemory copies the data from the specified buffer in the current process to the address range of the specified process. Any process that has a handle with PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process to be written to can call the function. Typically but not always, the process with address space that is being written to is being debugged. The entire area to be written to must be accessible, and if it is not accessible, the function fails.  <a href="#aa066859002c8c3f8a31e80140e15c73c">More...</a><br /></td></tr>
<tr class="separator:aa066859002c8c3f8a31e80140e15c73c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad618f03e3466e000ea8e7b5c58200867"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_process_memory_utilities_1_1_managed_1_1_native_wrapper.html#ad618f03e3466e000ea8e7b5c58200867">WriteProcessMemoryPartial&lt; T &gt;</a> (IntPtr handle, IntPtr baseAddress, ref T buffer, int offset, int length, out IntPtr numberOfBytesWritten)</td></tr>
<tr class="memdesc:ad618f03e3466e000ea8e7b5c58200867"><td class="mdescLeft">&#160;</td><td class="mdescRight">WriteProcessMemory copies the data from the specified buffer in the current process to the address range of the specified process. Any process that has a handle with PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process to be written to can call the function. Typically but not always, the process with address space that is being written to is being debugged. The entire area to be written to must be accessible, and if it is not accessible, the function fails.  <a href="#ad618f03e3466e000ea8e7b5c58200867">More...</a><br /></td></tr>
<tr class="separator:ad618f03e3466e000ea8e7b5c58200867"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:ae385d060ad80a299cceb4a8a25a9c10a"><td class="memItemLeft" align="right" valign="top">const uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_process_memory_utilities_1_1_managed_1_1_native_wrapper.html#ae385d060ad80a299cceb4a8a25a9c10a">INFINITE</a> = uint.MaxValue</td></tr>
<tr class="memdesc:ae385d060ad80a299cceb4a8a25a9c10a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A constant used to specify an infinite waiting period  <a href="#ae385d060ad80a299cceb4a8a25a9c10a">More...</a><br /></td></tr>
<tr class="separator:ae385d060ad80a299cceb4a8a25a9c10a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a6ba549f844c192db7badb048f39533c5"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_process_memory_utilities_1_1_managed_1_1_native_wrapper.html#a6ba549f844c192db7badb048f39533c5">HasError</a> =&gt; _lastError != 0</td></tr>
<tr class="memdesc:a6ba549f844c192db7badb048f39533c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the previously called method on this thread was successful.  <a href="#a6ba549f844c192db7badb048f39533c5">More...</a><br /></td></tr>
<tr class="separator:a6ba549f844c192db7badb048f39533c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="properties"></a>
Properties</h2></td></tr>
<tr class="memitem:a66041f257d175ab349e2333d875d6198"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_process_memory_utilities_1_1_managed_1_1_native_wrapper.html#a66041f257d175ab349e2333d875d6198">CaptureErrors</a><code> [get, set]</code></td></tr>
<tr class="memdesc:a66041f257d175ab349e2333d875d6198"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether to capture the "LastError".  <a href="#a66041f257d175ab349e2333d875d6198">More...</a><br /></td></tr>
<tr class="separator:a66041f257d175ab349e2333d875d6198"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91bd57e60e710712659cbe994a3034ce"><td class="memItemLeft" align="right" valign="top">static int?&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_process_memory_utilities_1_1_managed_1_1_native_wrapper.html#a91bd57e60e710712659cbe994a3034ce">LastError</a><code> [get]</code></td></tr>
<tr class="memdesc:a91bd57e60e710712659cbe994a3034ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the win32 error code set by the last failed method on this thread.  <a href="#a91bd57e60e710712659cbe994a3034ce">More...</a><br /></td></tr>
<tr class="separator:a91bd57e60e710712659cbe994a3034ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Provides methods that replicate the behaviour of Kernel32 by using NtDll methods and applies basic error checking. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="ab821e7e67ea07fc9e7d16cda454bbf06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab821e7e67ea07fc9e7d16cda454bbf06">&#9670;&nbsp;</a></span>CloseHandle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool ProcessMemoryUtilities.Managed.NativeWrapper.CloseHandle </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Closes an open object handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A valid handle to an open object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the function succeeds, the return value is nonzero. If the function fails, the return value is zero.To get extended error information, call GetLastError.</dd></dl>

</div>
</div>
<a id="adb20652db5b48708aa393508929cf5b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb20652db5b48708aa393508929cf5b2">&#9670;&nbsp;</a></span>CreateRemoteThread() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static IntPtr ProcessMemoryUtilities.Managed.NativeWrapper.CreateRemoteThread </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>threadAttributes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>stackSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>startAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>parameter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_process_memory_utilities_1_1_native.html#a28a597a806a5662bfe6ef8a30725f3f6">ThreadCreationFlags</a>&#160;</td>
          <td class="paramname"><em>creationFlags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>threadId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a thread that runs in the virtual address space of another process. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A handle to the process in which the thread is to be created. The handle must have the PROCESS_CREATE_THREAD, PROCESS_QUERY_INFORMATION, PROCESS_VM_OPERATION, PROCESS_VM_WRITE, and PROCESS_VM_READ access rights, and may fail without these rights on certain platforms. For more information, see Process Security and Access Rights.</td></tr>
    <tr><td class="paramname">threadAttributes</td><td>A pointer to a SECURITY_ATTRIBUTES structure that specifies a security descriptor for the new thread and determines whether child processes can inherit the returned handle. If lpThreadAttributes is NULL, the thread gets a default security descriptor and the handle cannot be inherited. The access control lists (ACL) in the default security descriptor for a thread come from the primary token of the creator.</td></tr>
    <tr><td class="paramname">stackSize</td><td>The initial size of the stack, in bytes. The system rounds this value to the nearest page. If this parameter is 0 (zero), the new thread uses the default size for the executable.</td></tr>
    <tr><td class="paramname">startAddress</td><td>A pointer to the application-defined function of type LPTHREAD_START_ROUTINE to be executed by the thread and represents the starting address of the thread in the remote process. The function must exist in the remote process.</td></tr>
    <tr><td class="paramname">parameter</td><td>A pointer to a variable to be passed to the thread function.</td></tr>
    <tr><td class="paramname">creationFlags</td><td></td></tr>
    <tr><td class="paramname">threadId</td><td>A pointer to a variable that receives the thread identifier. If this parameter is NULL, the thread identifier is not returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the function succeeds, the return value is a handle to the new thread. If the function fails, the return value is IntPtr.Zero.To get extended error information, call GetLastError.</dd></dl>

</div>
</div>
<a id="afa68430b8589bbf15de26361adc1312c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa68430b8589bbf15de26361adc1312c">&#9670;&nbsp;</a></span>CreateRemoteThread() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static IntPtr ProcessMemoryUtilities.Managed.NativeWrapper.CreateRemoteThread </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>threadAttributes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>stackSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>startAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>parameter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_process_memory_utilities_1_1_native.html#a28a597a806a5662bfe6ef8a30725f3f6">ThreadCreationFlags</a>&#160;</td>
          <td class="paramname"><em>creationFlags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out uint&#160;</td>
          <td class="paramname"><em>threadId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a thread that runs in the virtual address space of another process. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A handle to the process in which the thread is to be created. The handle must have the PROCESS_CREATE_THREAD, PROCESS_QUERY_INFORMATION, PROCESS_VM_OPERATION, PROCESS_VM_WRITE, and PROCESS_VM_READ access rights, and may fail without these rights on certain platforms. For more information, see Process Security and Access Rights.</td></tr>
    <tr><td class="paramname">threadAttributes</td><td>A pointer to a SECURITY_ATTRIBUTES structure that specifies a security descriptor for the new thread and determines whether child processes can inherit the returned handle. If lpThreadAttributes is NULL, the thread gets a default security descriptor and the handle cannot be inherited. The access control lists (ACL) in the default security descriptor for a thread come from the primary token of the creator.</td></tr>
    <tr><td class="paramname">stackSize</td><td>The initial size of the stack, in bytes. The system rounds this value to the nearest page. If this parameter is 0 (zero), the new thread uses the default size for the executable.</td></tr>
    <tr><td class="paramname">startAddress</td><td>A pointer to the application-defined function of type LPTHREAD_START_ROUTINE to be executed by the thread and represents the starting address of the thread in the remote process. The function must exist in the remote process.</td></tr>
    <tr><td class="paramname">parameter</td><td>A pointer to a variable to be passed to the thread function.</td></tr>
    <tr><td class="paramname">creationFlags</td><td></td></tr>
    <tr><td class="paramname">threadId</td><td>A pointer to a variable that receives the thread identifier. If this parameter is NULL, the thread identifier is not returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the function succeeds, the return value is a handle to the new thread. If the function fails, the return value is IntPtr.Zero.To get extended error information, call GetLastError.</dd></dl>

</div>
</div>
<a id="aa339b14ac7aa9aa5bd392ef1449e7a6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa339b14ac7aa9aa5bd392ef1449e7a6e">&#9670;&nbsp;</a></span>CreateRemoteThread() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static IntPtr ProcessMemoryUtilities.Managed.NativeWrapper.CreateRemoteThread </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>startAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>parameter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_process_memory_utilities_1_1_native.html#a28a597a806a5662bfe6ef8a30725f3f6">ThreadCreationFlags</a>&#160;</td>
          <td class="paramname"><em>creationFlags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a thread that runs in the virtual address space of another process. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A handle to the process in which the thread is to be created. The handle must have the PROCESS_CREATE_THREAD, PROCESS_QUERY_INFORMATION, PROCESS_VM_OPERATION, PROCESS_VM_WRITE, and PROCESS_VM_READ access rights, and may fail without these rights on certain platforms. For more information, see Process Security and Access Rights.</td></tr>
    <tr><td class="paramname">startAddress</td><td>A pointer to the application-defined function of type LPTHREAD_START_ROUTINE to be executed by the thread and represents the starting address of the thread in the remote process. The function must exist in the remote process.</td></tr>
    <tr><td class="paramname">parameter</td><td>A pointer to a variable to be passed to the thread function.</td></tr>
    <tr><td class="paramname">creationFlags</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the function succeeds, the return value is a handle to the new thread. If the function fails, the return value is IntPtr.Zero.To get extended error information, call GetLastError.</dd></dl>

</div>
</div>
<a id="a87c13c086ddcd1e24af645df013b1898"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87c13c086ddcd1e24af645df013b1898">&#9670;&nbsp;</a></span>CreateRemoteThread() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static IntPtr ProcessMemoryUtilities.Managed.NativeWrapper.CreateRemoteThread </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>startAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>parameter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_process_memory_utilities_1_1_native.html#a28a597a806a5662bfe6ef8a30725f3f6">ThreadCreationFlags</a>&#160;</td>
          <td class="paramname"><em>creationFlags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out uint&#160;</td>
          <td class="paramname"><em>threadId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a thread that runs in the virtual address space of another process. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A handle to the process in which the thread is to be created. The handle must have the PROCESS_CREATE_THREAD, PROCESS_QUERY_INFORMATION, PROCESS_VM_OPERATION, PROCESS_VM_WRITE, and PROCESS_VM_READ access rights, and may fail without these rights on certain platforms. For more information, see Process Security and Access Rights.</td></tr>
    <tr><td class="paramname">startAddress</td><td>A pointer to the application-defined function of type LPTHREAD_START_ROUTINE to be executed by the thread and represents the starting address of the thread in the remote process. The function must exist in the remote process.</td></tr>
    <tr><td class="paramname">parameter</td><td>A pointer to a variable to be passed to the thread function.</td></tr>
    <tr><td class="paramname">creationFlags</td><td></td></tr>
    <tr><td class="paramname">threadId</td><td>A pointer to a variable that receives the thread identifier. If this parameter is NULL, the thread identifier is not returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the function succeeds, the return value is a handle to the new thread. If the function fails, the return value is IntPtr.Zero.To get extended error information, call GetLastError.</dd></dl>

</div>
</div>
<a id="a821dad005027861a9702eb6d0a5ec2ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a821dad005027861a9702eb6d0a5ec2ee">&#9670;&nbsp;</a></span>CreateRemoteThread() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static IntPtr ProcessMemoryUtilities.Managed.NativeWrapper.CreateRemoteThread </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>startAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>parameter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a thread that runs in the virtual address space of another process. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A handle to the process in which the thread is to be created. The handle must have the PROCESS_CREATE_THREAD, PROCESS_QUERY_INFORMATION, PROCESS_VM_OPERATION, PROCESS_VM_WRITE, and PROCESS_VM_READ access rights, and may fail without these rights on certain platforms. For more information, see Process Security and Access Rights.</td></tr>
    <tr><td class="paramname">startAddress</td><td>A pointer to the application-defined function of type LPTHREAD_START_ROUTINE to be executed by the thread and represents the starting address of the thread in the remote process. The function must exist in the remote process.</td></tr>
    <tr><td class="paramname">parameter</td><td>A pointer to a variable to be passed to the thread function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the function succeeds, the return value is a handle to the new thread. If the function fails, the return value is IntPtr.Zero.To get extended error information, call GetLastError.</dd></dl>

</div>
</div>
<a id="a7c1c17e9a97888121a4156e65f6a8324"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c1c17e9a97888121a4156e65f6a8324">&#9670;&nbsp;</a></span>GetRealWaitObjectResult() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="namespace_process_memory_utilities_1_1_native.html#a06054dd813bba2514407e29f39095dd7">WaitObjectResult</a> ProcessMemoryUtilities.Managed.NativeWrapper.GetRealWaitObjectResult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_process_memory_utilities_1_1_native.html#a06054dd813bba2514407e29f39095dd7">WaitObjectResult</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Turns the given WaitObjectResult into one of the defined enum values by stripping the objects index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>A WaitObjectResult.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A WaitObjectResult which is guaranteed to be one of the defined enum values.</dd></dl>

</div>
</div>
<a id="acbfb32f9450f7b5ac3368a1947364b2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbfb32f9450f7b5ac3368a1947364b2b">&#9670;&nbsp;</a></span>GetRealWaitObjectResult() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="namespace_process_memory_utilities_1_1_native.html#a06054dd813bba2514407e29f39095dd7">WaitObjectResult</a> ProcessMemoryUtilities.Managed.NativeWrapper.GetRealWaitObjectResult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_process_memory_utilities_1_1_native.html#a06054dd813bba2514407e29f39095dd7">WaitObjectResult</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Turns the given WaitObjectResult into one of the defined enum values and returns the objects index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>A WaitObjectResult</td></tr>
    <tr><td class="paramname">index</td><td>A variable that receives the index of the awaited object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A WaitObjectResult which is guaranteed to be one of the defined enum values.</dd></dl>

</div>
</div>
<a id="a124ac6635ca029c0e7d2ae8da8961328"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a124ac6635ca029c0e7d2ae8da8961328">&#9670;&nbsp;</a></span>OpenProcess() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static IntPtr ProcessMemoryUtilities.Managed.NativeWrapper.OpenProcess </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_process_memory_utilities_1_1_native.html#abdfccb438f768cae26c138a43489d2ff">ProcessAccessFlags</a>&#160;</td>
          <td class="paramname"><em>desiredAccess</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>inheritHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>processId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Opens an existing local process object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desiredAccess</td><td>The access to the process object. This access right is checked against the security descriptor for the process.</td></tr>
    <tr><td class="paramname">inheritHandle</td><td>If this value is TRUE, processes created by this process will inherit the handle. Otherwise, the processes do not inherit this handle.</td></tr>
    <tr><td class="paramname">processId</td><td>The identifier of the local process to be opened.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the function succeeds, the return value is an open handle to the specified process. If the function fails, the return value is IntPtr.Zero. To get extended error information, call GetLastError.</dd></dl>

</div>
</div>
<a id="a7c15196764d44ecf1b7b3b75bea2c37c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c15196764d44ecf1b7b3b75bea2c37c">&#9670;&nbsp;</a></span>OpenProcess() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static IntPtr ProcessMemoryUtilities.Managed.NativeWrapper.OpenProcess </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_process_memory_utilities_1_1_native.html#abdfccb438f768cae26c138a43489d2ff">ProcessAccessFlags</a>&#160;</td>
          <td class="paramname"><em>desiredAccess</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>processId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Opens an existing local process object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desiredAccess</td><td>The access to the process object. This access right is checked against the security descriptor for the process.</td></tr>
    <tr><td class="paramname">processId</td><td>The identifier of the local process to be opened.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the function succeeds, the return value is an open handle to the specified process. If the function fails, the return value is IntPtr.Zero. To get extended error information, call GetLastError.</dd></dl>

</div>
</div>
<a id="acff20133812ec266c51b2b3aa0c4f233"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acff20133812ec266c51b2b3aa0c4f233">&#9670;&nbsp;</a></span>ReadProcessMemory() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool ProcessMemoryUtilities.Managed.NativeWrapper.ReadProcessMemory </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>baseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>ReadProcessMemory copies the data in the specified address range from the address space of the specified process into the specified buffer of the current process. Any process that has a handle with PROCESS_VM_READ access can call the function. The entire area to be read must be accessible, and if it is not accessible, the function fails. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A handle to the process with memory that is being read. The handle must have PROCESS_VM_READ access to the process.</td></tr>
    <tr><td class="paramname">baseAddress</td><td>A pointer to the base address in the specified process from which to read. Before any data transfer occurs, the system verifies that all data in the base address and memory of the specified size is accessible for read access, and if it is not accessible the function fails.</td></tr>
    <tr><td class="paramname">buffer</td><td>A pointer to a buffer that receives the contents from the address space of the specified process.</td></tr>
    <tr><td class="paramname">size</td><td>The number of bytes to be read from the specified process.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true when the function succeeds; otherwise false. To get extended error information, call GetLastError.</dd></dl>

</div>
</div>
<a id="ac912a12aa0fdf76cc6af2bb3c3b42d17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac912a12aa0fdf76cc6af2bb3c3b42d17">&#9670;&nbsp;</a></span>ReadProcessMemory() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool ProcessMemoryUtilities.Managed.NativeWrapper.ReadProcessMemory </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>baseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>numberOfBytesRead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>ReadProcessMemory copies the data in the specified address range from the address space of the specified process into the specified buffer of the current process. Any process that has a handle with PROCESS_VM_READ access can call the function. The entire area to be read must be accessible, and if it is not accessible, the function fails. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A handle to the process with memory that is being read. The handle must have PROCESS_VM_READ access to the process.</td></tr>
    <tr><td class="paramname">baseAddress</td><td>A pointer to the base address in the specified process from which to read. Before any data transfer occurs, the system verifies that all data in the base address and memory of the specified size is accessible for read access, and if it is not accessible the function fails.</td></tr>
    <tr><td class="paramname">buffer</td><td>A pointer to a buffer that receives the contents from the address space of the specified process.</td></tr>
    <tr><td class="paramname">size</td><td>The number of bytes to be read from the specified process.</td></tr>
    <tr><td class="paramname">numberOfBytesRead</td><td>A pointer to a variable that receives the number of bytes transferred into the specified buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true when the function succeeds; otherwise false. To get extended error information, call GetLastError.</dd></dl>

</div>
</div>
<a id="a03602a286de615dcbea639c63a86c82c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03602a286de615dcbea639c63a86c82c">&#9670;&nbsp;</a></span>ReadProcessMemory() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool ProcessMemoryUtilities.Managed.NativeWrapper.ReadProcessMemory </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>baseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out IntPtr&#160;</td>
          <td class="paramname"><em>numberOfBytesRead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>ReadProcessMemory copies the data in the specified address range from the address space of the specified process into the specified buffer of the current process. Any process that has a handle with PROCESS_VM_READ access can call the function. The entire area to be read must be accessible, and if it is not accessible, the function fails. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A handle to the process with memory that is being read. The handle must have PROCESS_VM_READ access to the process.</td></tr>
    <tr><td class="paramname">baseAddress</td><td>A pointer to the base address in the specified process from which to read. Before any data transfer occurs, the system verifies that all data in the base address and memory of the specified size is accessible for read access, and if it is not accessible the function fails.</td></tr>
    <tr><td class="paramname">buffer</td><td>A pointer to a buffer that receives the contents from the address space of the specified process.</td></tr>
    <tr><td class="paramname">size</td><td>The number of bytes to be read from the specified process.</td></tr>
    <tr><td class="paramname">numberOfBytesRead</td><td>A pointer to a variable that receives the number of bytes transferred into the specified buffer. If lpNumberOfBytesRead is IntPtr.Zero, the parameter is ignored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true when the function succeeds; otherwise false. To get extended error information, call GetLastError.</dd></dl>

</div>
</div>
<a id="afcb57ffe44a9195e1a3dbeba7cf5d616"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcb57ffe44a9195e1a3dbeba7cf5d616">&#9670;&nbsp;</a></span>ReadProcessMemory&lt; T &gt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool <a class="el" href="class_process_memory_utilities_1_1_managed_1_1_native_wrapper.html#acff20133812ec266c51b2b3aa0c4f233">ProcessMemoryUtilities.Managed.NativeWrapper.ReadProcessMemory</a>&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>baseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ref T&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>ReadProcessMemory copies the data in the specified address range from the address space of the specified process into the specified buffer of the current process. Any process that has a handle with PROCESS_VM_READ access can call the function. The entire area to be read must be accessible, and if it is not accessible, the function fails. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A handle to the process with memory that is being read. The handle must have PROCESS_VM_READ access to the process.</td></tr>
    <tr><td class="paramname">baseAddress</td><td>A pointer to the base address in the specified process from which to read. Before any data transfer occurs, the system verifies that all data in the base address and memory of the specified size is accessible for read access, and if it is not accessible the function fails.</td></tr>
    <tr><td class="paramname">buffer</td><td>A pointer to a buffer that receives the contents from the address space of the specified process.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true when the function succeeds; otherwise false. To get extended error information, call GetLastError.</dd></dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>unmanaged</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>ReadProcessMemory</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>handle</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>baseAddress</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>ref</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>buffer</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>out</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>var</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>_</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="adfed5fb5f0e53735af91a1b3877b77d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfed5fb5f0e53735af91a1b3877b77d3">&#9670;&nbsp;</a></span>ReadProcessMemory&lt; T &gt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool <a class="el" href="class_process_memory_utilities_1_1_managed_1_1_native_wrapper.html#acff20133812ec266c51b2b3aa0c4f233">ProcessMemoryUtilities.Managed.NativeWrapper.ReadProcessMemory</a>&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>baseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ref T&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out IntPtr&#160;</td>
          <td class="paramname"><em>numberOfBytesRead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>ReadProcessMemory copies the data in the specified address range from the address space of the specified process into the specified buffer of the current process. Any process that has a handle with PROCESS_VM_READ access can call the function. The entire area to be read must be accessible, and if it is not accessible, the function fails. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A handle to the process with memory that is being read. The handle must have PROCESS_VM_READ access to the process.</td></tr>
    <tr><td class="paramname">baseAddress</td><td>A pointer to the base address in the specified process from which to read. Before any data transfer occurs, the system verifies that all data in the base address and memory of the specified size is accessible for read access, and if it is not accessible the function fails.</td></tr>
    <tr><td class="paramname">buffer</td><td>A pointer to a buffer that receives the contents from the address space of the specified process.</td></tr>
    <tr><td class="paramname">numberOfBytesRead</td><td>A pointer to a variable that receives the number of bytes transferred into the specified buffer. If lpNumberOfBytesRead is IntPtr.Zero, the parameter is ignored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true when the function succeeds; otherwise false. To get extended error information, call GetLastError.</dd></dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>unmanaged</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="a5096df2cd0981c4e5658e93ad336ec5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5096df2cd0981c4e5658e93ad336ec5d">&#9670;&nbsp;</a></span>ReadProcessMemoryArray&lt; T &gt;() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool ProcessMemoryUtilities.Managed.NativeWrapper.ReadProcessMemoryArray&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>baseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T []&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>ReadProcessMemory copies the data in the specified address range from the address space of the specified process into the specified buffer of the current process. Any process that has a handle with PROCESS_VM_READ access can call the function. The entire area to be read must be accessible, and if it is not accessible, the function fails. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A handle to the process with memory that is being read. The handle must have PROCESS_VM_READ access to the process.</td></tr>
    <tr><td class="paramname">baseAddress</td><td>A pointer to the base address in the specified process from which to read. Before any data transfer occurs, the system verifies that all data in the base address and memory of the specified size is accessible for read access, and if it is not accessible the function fails.</td></tr>
    <tr><td class="paramname">buffer</td><td>A pointer to a buffer that receives the contents from the address space of the specified process.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true when the function succeeds; otherwise false. To get extended error information, call GetLastError.</dd></dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>unmanaged</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>ReadProcessMemoryArray</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>handle</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>baseAddress</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>buffer</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>buffer.Length</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>out</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>var</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>_</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="af8bf9082edfa319a6c707c34aef3678a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8bf9082edfa319a6c707c34aef3678a">&#9670;&nbsp;</a></span>ReadProcessMemoryArray&lt; T &gt;() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool ProcessMemoryUtilities.Managed.NativeWrapper.ReadProcessMemoryArray&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>baseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T []&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>ReadProcessMemory copies the data in the specified address range from the address space of the specified process into the specified buffer of the current process. Any process that has a handle with PROCESS_VM_READ access can call the function. The entire area to be read must be accessible, and if it is not accessible, the function fails. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A handle to the process with memory that is being read. The handle must have PROCESS_VM_READ access to the process.</td></tr>
    <tr><td class="paramname">baseAddress</td><td>A pointer to the base address in the specified process from which to read. Before any data transfer occurs, the system verifies that all data in the base address and memory of the specified size is accessible for read access, and if it is not accessible the function fails.</td></tr>
    <tr><td class="paramname">buffer</td><td>A pointer to a buffer that receives the contents from the address space of the specified process.</td></tr>
    <tr><td class="paramname">offset</td><td>A byte offset from inside the array to copy to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true when the function succeeds; otherwise false. To get extended error information, call GetLastError.</dd></dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>unmanaged</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>ReadProcessMemoryArray</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>handle</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>baseAddress</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>buffer</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>offset</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>buffer.Length</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>offset</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>out</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>var</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>_</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="a0a66a9e197e2b7298812e9914ec2af54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a66a9e197e2b7298812e9914ec2af54">&#9670;&nbsp;</a></span>ReadProcessMemoryArray&lt; T &gt;() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool ProcessMemoryUtilities.Managed.NativeWrapper.ReadProcessMemoryArray&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>baseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T []&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out IntPtr&#160;</td>
          <td class="paramname"><em>numberOfBytesRead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>ReadProcessMemory copies the data in the specified address range from the address space of the specified process into the specified buffer of the current process. Any process that has a handle with PROCESS_VM_READ access can call the function. The entire area to be read must be accessible, and if it is not accessible, the function fails. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A handle to the process with memory that is being read. The handle must have PROCESS_VM_READ access to the process.</td></tr>
    <tr><td class="paramname">baseAddress</td><td>A pointer to the base address in the specified process from which to read. Before any data transfer occurs, the system verifies that all data in the base address and memory of the specified size is accessible for read access, and if it is not accessible the function fails.</td></tr>
    <tr><td class="paramname">buffer</td><td>A pointer to a buffer that receives the contents from the address space of the specified process.</td></tr>
    <tr><td class="paramname">numberOfBytesRead</td><td>A pointer to a variable that receives the number of bytes transferred into the specified buffer. If lpNumberOfBytesRead is IntPtr.Zero, the parameter is ignored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true when the function succeeds; otherwise false. To get extended error information, call GetLastError.</dd></dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>unmanaged</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>ReadProcessMemoryArray</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>handle</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>baseAddress</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>buffer</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>buffer.Length</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>out</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>numberOfBytesRead</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="a12165e424a3fa98668db371418067482"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12165e424a3fa98668db371418067482">&#9670;&nbsp;</a></span>ReadProcessMemoryArray&lt; T &gt;() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool ProcessMemoryUtilities.Managed.NativeWrapper.ReadProcessMemoryArray&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>baseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T []&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>ReadProcessMemory copies the data in the specified address range from the address space of the specified process into the specified buffer of the current process. Any process that has a handle with PROCESS_VM_READ access can call the function. The entire area to be read must be accessible, and if it is not accessible, the function fails. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A handle to the process with memory that is being read. The handle must have PROCESS_VM_READ access to the process.</td></tr>
    <tr><td class="paramname">baseAddress</td><td>A pointer to the base address in the specified process from which to read. Before any data transfer occurs, the system verifies that all data in the base address and memory of the specified size is accessible for read access, and if it is not accessible the function fails.</td></tr>
    <tr><td class="paramname">buffer</td><td>A pointer to a buffer that receives the contents from the address space of the specified process.</td></tr>
    <tr><td class="paramname">offset</td><td>A byte offset from inside the array to copy to.</td></tr>
    <tr><td class="paramname">length</td><td>The number of bytes to copy to the array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true when the function succeeds; otherwise false. To get extended error information, call GetLastError.</dd></dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>unmanaged</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>ReadProcessMemoryArray</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>handle</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>baseAddress</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>buffer</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>offset</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>length</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>out</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>var</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>_</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="a6434b29145d7205e0cb5065bb475a935"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6434b29145d7205e0cb5065bb475a935">&#9670;&nbsp;</a></span>ReadProcessMemoryArray&lt; T &gt;() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool ProcessMemoryUtilities.Managed.NativeWrapper.ReadProcessMemoryArray&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>baseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T []&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out IntPtr&#160;</td>
          <td class="paramname"><em>numberOfBytesRead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>ReadProcessMemory copies the data in the specified address range from the address space of the specified process into the specified buffer of the current process. Any process that has a handle with PROCESS_VM_READ access can call the function. The entire area to be read must be accessible, and if it is not accessible, the function fails. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A handle to the process with memory that is being read. The handle must have PROCESS_VM_READ access to the process.</td></tr>
    <tr><td class="paramname">baseAddress</td><td>A pointer to the base address in the specified process from which to read. Before any data transfer occurs, the system verifies that all data in the base address and memory of the specified size is accessible for read access, and if it is not accessible the function fails.</td></tr>
    <tr><td class="paramname">buffer</td><td>A pointer to a buffer that receives the contents from the address space of the specified process.</td></tr>
    <tr><td class="paramname">offset</td><td>A byte offset from inside the array to copy to.</td></tr>
    <tr><td class="paramname">numberOfBytesRead</td><td>A pointer to a variable that receives the number of bytes transferred into the specified buffer. If lpNumberOfBytesRead is IntPtr.Zero, the parameter is ignored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true when the function succeeds; otherwise false. To get extended error information, call GetLastError.</dd></dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>unmanaged</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>ReadProcessMemoryArray</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>handle</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>baseAddress</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>buffer</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>offset</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>buffer.Length</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>offset</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>out</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>numberOfBytesRead</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="abfb3ca33e82573e948ac81768f5a0ab6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfb3ca33e82573e948ac81768f5a0ab6">&#9670;&nbsp;</a></span>ReadProcessMemoryArray&lt; T &gt;() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool ProcessMemoryUtilities.Managed.NativeWrapper.ReadProcessMemoryArray&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>baseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T []&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out IntPtr&#160;</td>
          <td class="paramname"><em>numberOfBytesRead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>ReadProcessMemory copies the data in the specified address range from the address space of the specified process into the specified buffer of the current process. Any process that has a handle with PROCESS_VM_READ access can call the function. The entire area to be read must be accessible, and if it is not accessible, the function fails. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A handle to the process with memory that is being read. The handle must have PROCESS_VM_READ access to the process.</td></tr>
    <tr><td class="paramname">baseAddress</td><td>A pointer to the base address in the specified process from which to read. Before any data transfer occurs, the system verifies that all data in the base address and memory of the specified size is accessible for read access, and if it is not accessible the function fails.</td></tr>
    <tr><td class="paramname">buffer</td><td>A pointer to a buffer that receives the contents from the address space of the specified process.</td></tr>
    <tr><td class="paramname">offset</td><td>A byte offset from inside the array to copy to.</td></tr>
    <tr><td class="paramname">length</td><td>The number of bytes to copy to the array.</td></tr>
    <tr><td class="paramname">numberOfBytesRead</td><td>A pointer to a variable that receives the number of bytes transferred into the specified buffer. If lpNumberOfBytesRead is IntPtr.Zero, the parameter is ignored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true when the function succeeds; otherwise false. To get extended error information, call GetLastError.</dd></dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>unmanaged</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="a9c8564de38950e24e1a4936a4b4147fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c8564de38950e24e1a4936a4b4147fa">&#9670;&nbsp;</a></span>ReadProcessMemoryPartial&lt; T &gt;() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool ProcessMemoryUtilities.Managed.NativeWrapper.ReadProcessMemoryPartial&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>baseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ref T&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>ReadProcessMemory copies the data in the specified address range from the address space of the specified process into the specified buffer of the current process. Any process that has a handle with PROCESS_VM_READ access can call the function. The entire area to be read must be accessible, and if it is not accessible, the function fails. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A handle to the process with memory that is being read. The handle must have PROCESS_VM_READ access to the process.</td></tr>
    <tr><td class="paramname">baseAddress</td><td>A pointer to the base address in the specified process from which to read. Before any data transfer occurs, the system verifies that all data in the base address and memory of the specified size is accessible for read access, and if it is not accessible the function fails.</td></tr>
    <tr><td class="paramname">buffer</td><td>A pointer to a buffer that receives the contents from the address space of the specified process.</td></tr>
    <tr><td class="paramname">offset</td><td>A byte offset from the start of the buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true when the function succeeds; otherwise false. To get extended error information, call GetLastError.</dd></dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>unmanaged</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>ReadProcessMemoryPartial</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>handle</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>baseAddress</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>ref</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>buffer</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>offset</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>out</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>var</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>_</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="a0c02ddfbe6a8cdfea10a6d03d5041259"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c02ddfbe6a8cdfea10a6d03d5041259">&#9670;&nbsp;</a></span>ReadProcessMemoryPartial&lt; T &gt;() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool ProcessMemoryUtilities.Managed.NativeWrapper.ReadProcessMemoryPartial&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>baseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ref T&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>ReadProcessMemory copies the data in the specified address range from the address space of the specified process into the specified buffer of the current process. Any process that has a handle with PROCESS_VM_READ access can call the function. The entire area to be read must be accessible, and if it is not accessible, the function fails. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A handle to the process with memory that is being read. The handle must have PROCESS_VM_READ access to the process.</td></tr>
    <tr><td class="paramname">baseAddress</td><td>A pointer to the base address in the specified process from which to read. Before any data transfer occurs, the system verifies that all data in the base address and memory of the specified size is accessible for read access, and if it is not accessible the function fails.</td></tr>
    <tr><td class="paramname">buffer</td><td>A pointer to a buffer that receives the contents from the address space of the specified process.</td></tr>
    <tr><td class="paramname">offset</td><td>A byte offset from the start of the buffer.</td></tr>
    <tr><td class="paramname">length</td><td>The number of bytes to copy to the buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true when the function succeeds; otherwise false. To get extended error information, call GetLastError.</dd></dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>unmanaged</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>ReadProcessMemoryPartial</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>handle</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>baseAddress</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>ref</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>buffer</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>offset</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>length</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>out</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>var</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>_</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="a15e98789a60efea90b1ec84c04c46e75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15e98789a60efea90b1ec84c04c46e75">&#9670;&nbsp;</a></span>ReadProcessMemoryPartial&lt; T &gt;() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool ProcessMemoryUtilities.Managed.NativeWrapper.ReadProcessMemoryPartial&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>baseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ref T&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out IntPtr&#160;</td>
          <td class="paramname"><em>numberOfBytesRead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>ReadProcessMemory copies the data in the specified address range from the address space of the specified process into the specified buffer of the current process. Any process that has a handle with PROCESS_VM_READ access can call the function. The entire area to be read must be accessible, and if it is not accessible, the function fails. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A handle to the process with memory that is being read. The handle must have PROCESS_VM_READ access to the process.</td></tr>
    <tr><td class="paramname">baseAddress</td><td>A pointer to the base address in the specified process from which to read. Before any data transfer occurs, the system verifies that all data in the base address and memory of the specified size is accessible for read access, and if it is not accessible the function fails.</td></tr>
    <tr><td class="paramname">buffer</td><td>A pointer to a buffer that receives the contents from the address space of the specified process.</td></tr>
    <tr><td class="paramname">offset</td><td>A byte offset from the start of the buffer.</td></tr>
    <tr><td class="paramname">numberOfBytesRead</td><td>A pointer to a variable that receives the number of bytes transferred into the specified buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true when the function succeeds; otherwise false. To get extended error information, call GetLastError.</dd></dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>unmanaged</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>ReadProcessMemoryPartial</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>handle</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>baseAddress</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>ref</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>buffer</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>offset</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>InternalHelper.SizeOf&lt;T&gt;()</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>offset</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>out</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>numberOfBytesRead</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="a17332ff1c1f71050406f14794099fd9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17332ff1c1f71050406f14794099fd9d">&#9670;&nbsp;</a></span>ReadProcessMemoryPartial&lt; T &gt;() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool ProcessMemoryUtilities.Managed.NativeWrapper.ReadProcessMemoryPartial&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>baseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ref T&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out IntPtr&#160;</td>
          <td class="paramname"><em>numberOfBytesRead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>ReadProcessMemory copies the data in the specified address range from the address space of the specified process into the specified buffer of the current process. Any process that has a handle with PROCESS_VM_READ access can call the function. The entire area to be read must be accessible, and if it is not accessible, the function fails. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A handle to the process with memory that is being read. The handle must have PROCESS_VM_READ access to the process.</td></tr>
    <tr><td class="paramname">baseAddress</td><td>A pointer to the base address in the specified process from which to read. Before any data transfer occurs, the system verifies that all data in the base address and memory of the specified size is accessible for read access, and if it is not accessible the function fails.</td></tr>
    <tr><td class="paramname">buffer</td><td>A pointer to a buffer that receives the contents from the address space of the specified process.</td></tr>
    <tr><td class="paramname">offset</td><td>A byte offset from the start of the buffer.</td></tr>
    <tr><td class="paramname">length</td><td>The number of bytes to copy to the buffer.</td></tr>
    <tr><td class="paramname">numberOfBytesRead</td><td>A pointer to a variable that receives the number of bytes transferred into the specified buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true when the function succeeds; otherwise false. To get extended error information, call GetLastError.</dd></dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>unmanaged</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="a1f6f90b68dfc121d515d10b6be5211e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f6f90b68dfc121d515d10b6be5211e2">&#9670;&nbsp;</a></span>VirtualAllocEx()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static IntPtr ProcessMemoryUtilities.Managed.NativeWrapper.VirtualAllocEx </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_process_memory_utilities_1_1_native.html#a0729ee4af770ea067d43d9761df4cbdb">AllocationType</a>&#160;</td>
          <td class="paramname"><em>allocationType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_process_memory_utilities_1_1_native.html#a253e5867c7af9a40486194ce6ab3cf53">MemoryProtectionFlags</a>&#160;</td>
          <td class="paramname"><em>memoryProtection</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reserves, commits, or changes the state of a region of memory within the virtual address space of a specified process. The function initializes the memory it allocates to zero. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>The handle to a process. The function allocates memory within the virtual address space of this process. The handle must have the PROCESS_VM_OPERATION access right.For more information, see Process Security and Access Rights.</td></tr>
    <tr><td class="paramname">address</td><td>The pointer that specifies a desired starting address for the region of pages that you want to allocate. If you are reserving memory, the function rounds this address down to the nearest multiple of the allocation granularity. If you are committing memory that is already reserved, the function rounds this address down to the nearest page boundary.To determine the size of a page and the allocation granularity on the host computer, use the GetSystemInfo function. If lpAddress is NULL, the function determines where to allocate the region. If this address is within an enclave that you have not initialized by calling InitializeEnclave, VirtualAllocEx allocates a page of zeros for the enclave at that address.The page must be previously uncommitted, and will not be measured with the EEXTEND instruction of the Intel Software Guard Extensions programming model. If the address in within an enclave that you initialized, then the allocation operation fails with the ERROR_INVALID_ADDRESS error.</td></tr>
    <tr><td class="paramname">size</td><td>The size of the region of memory to allocate, in bytes. If lpAddress is NULL, the function rounds dwSize up to the next page boundary. If lpAddress is not NULL, the function allocates all pages that contain one or more bytes in the range from lpAddress to lpAddress+dwSize.This means, for example, that a 2-byte range that straddles a page boundary causes the function to allocate both pages.</td></tr>
    <tr><td class="paramname">allocationType</td><td>The type of memory allocation. This parameter must contain one of the following values.</td></tr>
    <tr><td class="paramname">memoryProtection</td><td>The memory protection for the region of pages to be allocated. If the pages are being committed, you can specify any one of the memory protection constants.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the function succeeds, the return value is the base address of the allocated region of pages. If the function fails, the return value is NULL.To get extended error information, call GetLastError.</dd></dl>

</div>
</div>
<a id="a3fd48ae1b89c03df5c0f9e8bddff04be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fd48ae1b89c03df5c0f9e8bddff04be">&#9670;&nbsp;</a></span>VirtualFreeEx()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool ProcessMemoryUtilities.Managed.NativeWrapper.VirtualFreeEx </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_process_memory_utilities_1_1_native.html#adb58001ff27279e48c274189fcab7293">FreeType</a>&#160;</td>
          <td class="paramname"><em>freeType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Releases, decommits, or releases and decommits a region of memory within the virtual address space of a specified process. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A handle to a process. The function frees memory within the virtual address space of the process. The handle must have the PROCESS_VM_OPERATION access right.For more information, see Process Security and Access Rights.</td></tr>
    <tr><td class="paramname">address</td><td>A pointer to the starting address of the region of memory to be freed. If the dwFreeType parameter is MEM_RELEASE, lpAddress must be the base address returned by the VirtualAllocEx function when the region is reserved.</td></tr>
    <tr><td class="paramname">size</td><td>The size of the region of memory to free, in bytes. If the dwFreeType parameter is MEM_RELEASE, dwSize must be 0 (zero). The function frees the entire region that is reserved in the initial allocation call to VirtualAllocEx. If dwFreeType is MEM_DECOMMIT, the function decommits all memory pages that contain one or more bytes in the range from the lpAddress parameter to (lpAddress+dwSize). This means, for example, that a 2-byte region of memory that straddles a page boundary causes both pages to be decommitted.If lpAddress is the base address returned by VirtualAllocEx and dwSize is 0 (zero), the function decommits the entire region that is allocated by VirtualAllocEx.After that, the entire region is in the reserved state.</td></tr>
    <tr><td class="paramname">freeType</td><td>The type of free operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the function succeeds, the return value is true. If the function fails, the return value is false. To get extended error information, call GetLastError.</dd></dl>

</div>
</div>
<a id="a82e16f721cdab8076df60e86cf79c037"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82e16f721cdab8076df60e86cf79c037">&#9670;&nbsp;</a></span>VirtualProtectEx()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool ProcessMemoryUtilities.Managed.NativeWrapper.VirtualProtectEx </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_process_memory_utilities_1_1_native.html#a253e5867c7af9a40486194ce6ab3cf53">MemoryProtectionFlags</a>&#160;</td>
          <td class="paramname"><em>newProtect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out <a class="el" href="namespace_process_memory_utilities_1_1_native.html#a253e5867c7af9a40486194ce6ab3cf53">MemoryProtectionFlags</a>&#160;</td>
          <td class="paramname"><em>oldProtect</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Changes the protection on a region of committed pages in the virtual address space of a specified process. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A handle to the process whose memory protection is to be changed. The handle must have the PROCESS_VM_OPERATION access right. For more information, see Process Security and Access Rights.</td></tr>
    <tr><td class="paramname">address</td><td>A pointer to the base address of the region of pages whose access protection attributes are to be changed. All pages in the specified region must be within the same reserved region allocated when calling the VirtualAlloc or VirtualAllocEx function using MEM_RESERVE. The pages cannot span adjacent reserved regions that were allocated by separate calls to VirtualAlloc or VirtualAllocEx using MEM_RESERVE.</td></tr>
    <tr><td class="paramname">size</td><td>The size of the region whose access protection attributes are changed, in bytes. The region of affected pages includes all pages containing one or more bytes in the range from the lpAddress parameter to (lpAddress+dwSize). This means that a 2-byte range straddling a page boundary causes the protection attributes of both pages to be changed.</td></tr>
    <tr><td class="paramname">newProtect</td><td>The memory protection option. This parameter can be one of the memory protection constants. For mapped views, this value must be compatible with the access protection specified when the view was mapped(see MapViewOfFile, MapViewOfFileEx, and MapViewOfFileExNuma).</td></tr>
    <tr><td class="paramname">oldProtect</td><td>A pointer to a variable that receives the previous access protection of the first page in the specified region of pages. If this parameter is NULL or does not point to a valid variable, the function fails.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the function succeeds, the return value is true. If the function fails, the return value is false. To get extended error information, call GetLastError.</dd></dl>

</div>
</div>
<a id="ab896a0dabdfb0733246b0a58152b4ef3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab896a0dabdfb0733246b0a58152b4ef3">&#9670;&nbsp;</a></span>WaitForSingleObject()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="namespace_process_memory_utilities_1_1_native.html#a06054dd813bba2514407e29f39095dd7">WaitObjectResult</a> ProcessMemoryUtilities.Managed.NativeWrapper.WaitForSingleObject </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Waits until the specified object is in the signaled state or the time-out interval elapses. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A handle to the object.</td></tr>
    <tr><td class="paramname">timeout</td><td>The time-out interval, in milliseconds. If a nonzero value is specified, the function waits until the object is signaled or the interval elapses. If dwMilliseconds is zero, the function does not enter a wait state if the object is not signaled; it always returns immediately. If dwMilliseconds is INFINITE, the function will return only when the object is signaled.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the function succeeds, the return value indicates the event that caused the function to return.</dd></dl>

</div>
</div>
<a id="a0f1dad17da6e726c557e73dee12da987"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f1dad17da6e726c557e73dee12da987">&#9670;&nbsp;</a></span>WriteProcessMemory() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool ProcessMemoryUtilities.Managed.NativeWrapper.WriteProcessMemory </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>baseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>WriteProcessMemory copies the data from the specified buffer in the current process to the address range of the specified process. Any process that has a handle with PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process to be written to can call the function. Typically but not always, the process with address space that is being written to is being debugged. The entire area to be written to must be accessible, and if it is not accessible, the function fails. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A handle to the process memory to be modified. The handle must have PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process.</td></tr>
    <tr><td class="paramname">baseAddress</td><td>A pointer to the base address in the specified process to which data is written. Before data transfer occurs, the system verifies that all data in the base address and memory of the specified size is accessible for write access, and if it is not accessible, the function fails.</td></tr>
    <tr><td class="paramname">buffer</td><td>A pointer to the buffer that contains data to be written in the address space of the specified process.</td></tr>
    <tr><td class="paramname">size</td><td>The number of bytes to be written to the specified process.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true when the function succeeds; otherwise false. To get extended error information, call GetLastError.</dd></dl>

</div>
</div>
<a id="ae73367ec26c6fddc69393d1d287e51dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae73367ec26c6fddc69393d1d287e51dd">&#9670;&nbsp;</a></span>WriteProcessMemory() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool ProcessMemoryUtilities.Managed.NativeWrapper.WriteProcessMemory </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>baseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>numberOfBytesWritten</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>WriteProcessMemory copies the data from the specified buffer in the current process to the address range of the specified process. Any process that has a handle with PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process to be written to can call the function. Typically but not always, the process with address space that is being written to is being debugged. The entire area to be written to must be accessible, and if it is not accessible, the function fails. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A handle to the process memory to be modified. The handle must have PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process.</td></tr>
    <tr><td class="paramname">baseAddress</td><td>A pointer to the base address in the specified process to which data is written. Before data transfer occurs, the system verifies that all data in the base address and memory of the specified size is accessible for write access, and if it is not accessible, the function fails.</td></tr>
    <tr><td class="paramname">buffer</td><td>A pointer to the buffer that contains data to be written in the address space of the specified process.</td></tr>
    <tr><td class="paramname">size</td><td>The number of bytes to be written to the specified process.</td></tr>
    <tr><td class="paramname">numberOfBytesWritten</td><td>A pointer to a variable that receives the number of bytes transferred into the specified process. This parameter is optional. If lpNumberOfBytesWritten is IntPtr.Zero, the parameter is ignored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true when the function succeeds; otherwise false. To get extended error information, call GetLastError.</dd></dl>

</div>
</div>
<a id="a1273a16a34ee99062748694ed81103e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1273a16a34ee99062748694ed81103e3">&#9670;&nbsp;</a></span>WriteProcessMemory() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool ProcessMemoryUtilities.Managed.NativeWrapper.WriteProcessMemory </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>baseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out IntPtr&#160;</td>
          <td class="paramname"><em>numberOfBytesWritten</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>WriteProcessMemory copies the data from the specified buffer in the current process to the address range of the specified process. Any process that has a handle with PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process to be written to can call the function. Typically but not always, the process with address space that is being written to is being debugged. The entire area to be written to must be accessible, and if it is not accessible, the function fails. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A handle to the process memory to be modified. The handle must have PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process.</td></tr>
    <tr><td class="paramname">baseAddress</td><td>A pointer to the base address in the specified process to which data is written. Before data transfer occurs, the system verifies that all data in the base address and memory of the specified size is accessible for write access, and if it is not accessible, the function fails.</td></tr>
    <tr><td class="paramname">buffer</td><td>A pointer to the buffer that contains data to be written in the address space of the specified process.</td></tr>
    <tr><td class="paramname">size</td><td>The number of bytes to be written to the specified process.</td></tr>
    <tr><td class="paramname">numberOfBytesWritten</td><td>A pointer to a variable that receives the number of bytes transferred into the specified process. This parameter is optional. If lpNumberOfBytesWritten is IntPtr.Zero, the parameter is ignored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true when the function succeeds; otherwise false. To get extended error information, call GetLastError.</dd></dl>

</div>
</div>
<a id="a569e2c9363f3576870c616ba2c913f91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a569e2c9363f3576870c616ba2c913f91">&#9670;&nbsp;</a></span>WriteProcessMemory&lt; T &gt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool <a class="el" href="class_process_memory_utilities_1_1_managed_1_1_native_wrapper.html#a0f1dad17da6e726c557e73dee12da987">ProcessMemoryUtilities.Managed.NativeWrapper.WriteProcessMemory</a>&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>baseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ref T&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>WriteProcessMemory copies the data from the specified buffer in the current process to the address range of the specified process. Any process that has a handle with PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process to be written to can call the function. Typically but not always, the process with address space that is being written to is being debugged. The entire area to be written to must be accessible, and if it is not accessible, the function fails. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A handle to the process memory to be modified. The handle must have PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process.</td></tr>
    <tr><td class="paramname">baseAddress</td><td>A pointer to the base address in the specified process to which data is written. Before data transfer occurs, the system verifies that all data in the base address and memory of the specified size is accessible for write access, and if it is not accessible, the function fails.</td></tr>
    <tr><td class="paramname">buffer</td><td>A pointer to the buffer that contains data to be written in the address space of the specified process.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true when the function succeeds; otherwise false. To get extended error information, call GetLastError.</dd></dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>unmanaged</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>WriteProcessMemory</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>handle</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>baseAddress</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>ref</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>buffer</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>out</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>var</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>_</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="aba19108ae34c75275e5c47c2d9c8d41f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba19108ae34c75275e5c47c2d9c8d41f">&#9670;&nbsp;</a></span>WriteProcessMemory&lt; T &gt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool <a class="el" href="class_process_memory_utilities_1_1_managed_1_1_native_wrapper.html#a0f1dad17da6e726c557e73dee12da987">ProcessMemoryUtilities.Managed.NativeWrapper.WriteProcessMemory</a>&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>baseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ref T&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out IntPtr&#160;</td>
          <td class="paramname"><em>numberOfBytesWritten</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>WriteProcessMemory copies the data from the specified buffer in the current process to the address range of the specified process. Any process that has a handle with PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process to be written to can call the function. Typically but not always, the process with address space that is being written to is being debugged. The entire area to be written to must be accessible, and if it is not accessible, the function fails. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A handle to the process memory to be modified. The handle must have PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process.</td></tr>
    <tr><td class="paramname">baseAddress</td><td>A pointer to the base address in the specified process to which data is written. Before data transfer occurs, the system verifies that all data in the base address and memory of the specified size is accessible for write access, and if it is not accessible, the function fails.</td></tr>
    <tr><td class="paramname">buffer</td><td>A pointer to the buffer that contains data to be written in the address space of the specified process.</td></tr>
    <tr><td class="paramname">numberOfBytesWritten</td><td>A pointer to a variable that receives the number of bytes transferred into the specified process. This parameter is optional. If lpNumberOfBytesWritten is IntPtr.Zero, the parameter is ignored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true when the function succeeds; otherwise false. To get extended error information, call GetLastError.</dd></dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>unmanaged</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="adadd980912376194f29733793663af46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adadd980912376194f29733793663af46">&#9670;&nbsp;</a></span>WriteProcessMemoryArray&lt; T &gt;() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool ProcessMemoryUtilities.Managed.NativeWrapper.WriteProcessMemoryArray&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>baseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T []&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>WriteProcessMemory copies the data from the specified buffer in the current process to the address range of the specified process. Any process that has a handle with PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process to be written to can call the function. Typically but not always, the process with address space that is being written to is being debugged. The entire area to be written to must be accessible, and if it is not accessible, the function fails. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A handle to the process memory to be modified. The handle must have PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process.</td></tr>
    <tr><td class="paramname">baseAddress</td><td>A pointer to the base address in the specified process to which data is written. Before data transfer occurs, the system verifies that all data in the base address and memory of the specified size is accessible for write access, and if it is not accessible, the function fails.</td></tr>
    <tr><td class="paramname">buffer</td><td>A pointer to the buffer that contains data to be written in the address space of the specified process.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true when the function succeeds; otherwise false. To get extended error information, call GetLastError.</dd></dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>unmanaged</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>WriteProcessMemoryArray</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>handle</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>baseAddress</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>buffer</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>buffer.Length</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>out</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>var</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>_</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="a56e55cb15045110682306bbd987d62b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56e55cb15045110682306bbd987d62b9">&#9670;&nbsp;</a></span>WriteProcessMemoryArray&lt; T &gt;() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool ProcessMemoryUtilities.Managed.NativeWrapper.WriteProcessMemoryArray&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>baseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T []&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>WriteProcessMemory copies the data from the specified buffer in the current process to the address range of the specified process. Any process that has a handle with PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process to be written to can call the function. Typically but not always, the process with address space that is being written to is being debugged. The entire area to be written to must be accessible, and if it is not accessible, the function fails. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A handle to the process memory to be modified. The handle must have PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process.</td></tr>
    <tr><td class="paramname">baseAddress</td><td>A pointer to the base address in the specified process to which data is written. Before data transfer occurs, the system verifies that all data in the base address and memory of the specified size is accessible for write access, and if it is not accessible, the function fails.</td></tr>
    <tr><td class="paramname">buffer</td><td>A pointer to the buffer that contains data to be written in the address space of the specified process.</td></tr>
    <tr><td class="paramname">offset</td><td>A byte offset from inside the array to copy from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true when the function succeeds; otherwise false. To get extended error information, call GetLastError.</dd></dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>unmanaged</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>WriteProcessMemoryArray</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>handle</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>baseAddress</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>buffer</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>offset</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>buffer.Length</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>offset</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>out</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>var</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>_</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="afc2e07dc25f1b6a9cccb545e8570785e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc2e07dc25f1b6a9cccb545e8570785e">&#9670;&nbsp;</a></span>WriteProcessMemoryArray&lt; T &gt;() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool ProcessMemoryUtilities.Managed.NativeWrapper.WriteProcessMemoryArray&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>baseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T []&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out IntPtr&#160;</td>
          <td class="paramname"><em>numberOfBytesWritten</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>WriteProcessMemory copies the data from the specified buffer in the current process to the address range of the specified process. Any process that has a handle with PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process to be written to can call the function. Typically but not always, the process with address space that is being written to is being debugged. The entire area to be written to must be accessible, and if it is not accessible, the function fails. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A handle to the process memory to be modified. The handle must have PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process.</td></tr>
    <tr><td class="paramname">baseAddress</td><td>A pointer to the base address in the specified process to which data is written. Before data transfer occurs, the system verifies that all data in the base address and memory of the specified size is accessible for write access, and if it is not accessible, the function fails.</td></tr>
    <tr><td class="paramname">buffer</td><td>A pointer to the buffer that contains data to be written in the address space of the specified process.</td></tr>
    <tr><td class="paramname">numberOfBytesWritten</td><td>A pointer to a variable that receives the number of bytes transferred into the specified process. This parameter is optional. If lpNumberOfBytesWritten is IntPtr.Zero, the parameter is ignored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true when the function succeeds; otherwise false. To get extended error information, call GetLastError.</dd></dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>unmanaged</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>WriteProcessMemoryArray</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>handle</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>baseAddress</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>buffer</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>buffer.Length</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>out</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>numberOfBytesWritten</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="a3d83446ef8807252a24671e2a23be409"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d83446ef8807252a24671e2a23be409">&#9670;&nbsp;</a></span>WriteProcessMemoryArray&lt; T &gt;() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool ProcessMemoryUtilities.Managed.NativeWrapper.WriteProcessMemoryArray&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>baseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T []&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>WriteProcessMemory copies the data from the specified buffer in the current process to the address range of the specified process. Any process that has a handle with PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process to be written to can call the function. Typically but not always, the process with address space that is being written to is being debugged. The entire area to be written to must be accessible, and if it is not accessible, the function fails. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A handle to the process memory to be modified. The handle must have PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process.</td></tr>
    <tr><td class="paramname">baseAddress</td><td>A pointer to the base address in the specified process to which data is written. Before data transfer occurs, the system verifies that all data in the base address and memory of the specified size is accessible for write access, and if it is not accessible, the function fails.</td></tr>
    <tr><td class="paramname">buffer</td><td>A pointer to the buffer that contains data to be written in the address space of the specified process.</td></tr>
    <tr><td class="paramname">offset</td><td>A byte offset from inside the array to copy from.</td></tr>
    <tr><td class="paramname">length</td><td>The number of bytes to copy from the array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true when the function succeeds; otherwise false. To get extended error information, call GetLastError.</dd></dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>unmanaged</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>WriteProcessMemoryArray</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>handle</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>baseAddress</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>buffer</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>offset</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>length</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>out</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>var</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>_</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="a1f802e4bc396ae91859e26092e32f670"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f802e4bc396ae91859e26092e32f670">&#9670;&nbsp;</a></span>WriteProcessMemoryArray&lt; T &gt;() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool ProcessMemoryUtilities.Managed.NativeWrapper.WriteProcessMemoryArray&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>baseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T []&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out IntPtr&#160;</td>
          <td class="paramname"><em>numberOfBytesWritten</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>WriteProcessMemory copies the data from the specified buffer in the current process to the address range of the specified process. Any process that has a handle with PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process to be written to can call the function. Typically but not always, the process with address space that is being written to is being debugged. The entire area to be written to must be accessible, and if it is not accessible, the function fails. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A handle to the process memory to be modified. The handle must have PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process.</td></tr>
    <tr><td class="paramname">baseAddress</td><td>A pointer to the base address in the specified process to which data is written. Before data transfer occurs, the system verifies that all data in the base address and memory of the specified size is accessible for write access, and if it is not accessible, the function fails.</td></tr>
    <tr><td class="paramname">buffer</td><td>A pointer to the buffer that contains data to be written in the address space of the specified process.</td></tr>
    <tr><td class="paramname">offset</td><td>A byte offset from inside the array to copy from.</td></tr>
    <tr><td class="paramname">numberOfBytesWritten</td><td>A pointer to a variable that receives the number of bytes transferred into the specified process. This parameter is optional. If lpNumberOfBytesWritten is IntPtr.Zero, the parameter is ignored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true when the function succeeds; otherwise false. To get extended error information, call GetLastError.</dd></dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>unmanaged</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>WriteProcessMemoryArray</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>handle</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>baseAddress</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>buffer</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>offset</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>buffer.Length</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>offset</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>out</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>numberOfBytesWritten</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="ab89dd53f15cd037288cda51255385343"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab89dd53f15cd037288cda51255385343">&#9670;&nbsp;</a></span>WriteProcessMemoryArray&lt; T &gt;() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool ProcessMemoryUtilities.Managed.NativeWrapper.WriteProcessMemoryArray&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>baseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T []&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out IntPtr&#160;</td>
          <td class="paramname"><em>numberOfBytesWritten</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>WriteProcessMemory copies the data from the specified buffer in the current process to the address range of the specified process. Any process that has a handle with PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process to be written to can call the function. Typically but not always, the process with address space that is being written to is being debugged. The entire area to be written to must be accessible, and if it is not accessible, the function fails. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A handle to the process memory to be modified. The handle must have PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process.</td></tr>
    <tr><td class="paramname">baseAddress</td><td>A pointer to the base address in the specified process to which data is written. Before data transfer occurs, the system verifies that all data in the base address and memory of the specified size is accessible for write access, and if it is not accessible, the function fails.</td></tr>
    <tr><td class="paramname">buffer</td><td>A pointer to the buffer that contains data to be written in the address space of the specified process.</td></tr>
    <tr><td class="paramname">offset</td><td>A byte offset from inside the array to copy from.</td></tr>
    <tr><td class="paramname">length</td><td>The number of bytes to copy from the array.</td></tr>
    <tr><td class="paramname">numberOfBytesWritten</td><td>A pointer to a variable that receives the number of bytes transferred into the specified process. This parameter is optional. If lpNumberOfBytesWritten is IntPtr.Zero, the parameter is ignored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true when the function succeeds; otherwise false. To get extended error information, call GetLastError.</dd></dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>unmanaged</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="a176b201c8312fe19a24bf4b641e434a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a176b201c8312fe19a24bf4b641e434a3">&#9670;&nbsp;</a></span>WriteProcessMemoryPartial&lt; T &gt;() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool ProcessMemoryUtilities.Managed.NativeWrapper.WriteProcessMemoryPartial&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>baseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ref T&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>WriteProcessMemory copies the data from the specified buffer in the current process to the address range of the specified process. Any process that has a handle with PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process to be written to can call the function. Typically but not always, the process with address space that is being written to is being debugged. The entire area to be written to must be accessible, and if it is not accessible, the function fails. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A handle to the process memory to be modified. The handle must have PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process.</td></tr>
    <tr><td class="paramname">baseAddress</td><td>A pointer to the base address in the specified process to which data is written. Before data transfer occurs, the system verifies that all data in the base address and memory of the specified size is accessible for write access, and if it is not accessible, the function fails.</td></tr>
    <tr><td class="paramname">buffer</td><td>A pointer to the buffer that contains data to be written in the address space of the specified process.</td></tr>
    <tr><td class="paramname">offset</td><td>A byte offset from inside the array to copy from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true when the function succeeds; otherwise false. To get extended error information, call GetLastError.</dd></dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>unmanaged</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>WriteProcessMemoryPartial</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>handle</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>baseAddress</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>ref</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>buffer</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>offset</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>out</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>var</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>_</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="aff408e636055f64b89e8a80e1f02175b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff408e636055f64b89e8a80e1f02175b">&#9670;&nbsp;</a></span>WriteProcessMemoryPartial&lt; T &gt;() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool ProcessMemoryUtilities.Managed.NativeWrapper.WriteProcessMemoryPartial&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>baseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ref T&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>WriteProcessMemory copies the data from the specified buffer in the current process to the address range of the specified process. Any process that has a handle with PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process to be written to can call the function. Typically but not always, the process with address space that is being written to is being debugged. The entire area to be written to must be accessible, and if it is not accessible, the function fails. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A handle to the process memory to be modified. The handle must have PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process.</td></tr>
    <tr><td class="paramname">baseAddress</td><td>A pointer to the base address in the specified process to which data is written. Before data transfer occurs, the system verifies that all data in the base address and memory of the specified size is accessible for write access, and if it is not accessible, the function fails.</td></tr>
    <tr><td class="paramname">buffer</td><td>A pointer to the buffer that contains data to be written in the address space of the specified process.</td></tr>
    <tr><td class="paramname">offset</td><td>A byte offset from inside the array to copy from.</td></tr>
    <tr><td class="paramname">length</td><td>The number of bytes to copy to the buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true when the function succeeds; otherwise false. To get extended error information, call GetLastError.</dd></dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>unmanaged</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>WriteProcessMemoryPartial</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>handle</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>baseAddress</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>ref</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>buffer</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>offset</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>length</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>out</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>var</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>_</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="aa066859002c8c3f8a31e80140e15c73c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa066859002c8c3f8a31e80140e15c73c">&#9670;&nbsp;</a></span>WriteProcessMemoryPartial&lt; T &gt;() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool ProcessMemoryUtilities.Managed.NativeWrapper.WriteProcessMemoryPartial&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>baseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ref T&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out IntPtr&#160;</td>
          <td class="paramname"><em>numberOfBytesWritten</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>WriteProcessMemory copies the data from the specified buffer in the current process to the address range of the specified process. Any process that has a handle with PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process to be written to can call the function. Typically but not always, the process with address space that is being written to is being debugged. The entire area to be written to must be accessible, and if it is not accessible, the function fails. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A handle to the process memory to be modified. The handle must have PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process.</td></tr>
    <tr><td class="paramname">baseAddress</td><td>A pointer to the base address in the specified process to which data is written. Before data transfer occurs, the system verifies that all data in the base address and memory of the specified size is accessible for write access, and if it is not accessible, the function fails.</td></tr>
    <tr><td class="paramname">buffer</td><td>A pointer to the buffer that contains data to be written in the address space of the specified process.</td></tr>
    <tr><td class="paramname">offset</td><td>A byte offset from inside the array to copy from.</td></tr>
    <tr><td class="paramname">numberOfBytesWritten</td><td>A pointer to a variable that receives the number of bytes transferred into the specified buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true when the function succeeds; otherwise false. To get extended error information, call GetLastError.</dd></dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>unmanaged</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>WriteProcessMemoryPartial</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>handle</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>baseAddress</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>ref</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>buffer</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>offset</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>InternalHelper.SizeOf&lt;T&gt;()</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>offset</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>out</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>numberOfBytesWritten</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="ad618f03e3466e000ea8e7b5c58200867"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad618f03e3466e000ea8e7b5c58200867">&#9670;&nbsp;</a></span>WriteProcessMemoryPartial&lt; T &gt;() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool ProcessMemoryUtilities.Managed.NativeWrapper.WriteProcessMemoryPartial&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>baseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ref T&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out IntPtr&#160;</td>
          <td class="paramname"><em>numberOfBytesWritten</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>WriteProcessMemory copies the data from the specified buffer in the current process to the address range of the specified process. Any process that has a handle with PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process to be written to can call the function. Typically but not always, the process with address space that is being written to is being debugged. The entire area to be written to must be accessible, and if it is not accessible, the function fails. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A handle to the process memory to be modified. The handle must have PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process.</td></tr>
    <tr><td class="paramname">baseAddress</td><td>A pointer to the base address in the specified process to which data is written. Before data transfer occurs, the system verifies that all data in the base address and memory of the specified size is accessible for write access, and if it is not accessible, the function fails.</td></tr>
    <tr><td class="paramname">buffer</td><td>A pointer to the buffer that contains data to be written in the address space of the specified process.</td></tr>
    <tr><td class="paramname">offset</td><td>A byte offset from inside the array to copy from.</td></tr>
    <tr><td class="paramname">length</td><td>The number of bytes to copy to the buffer.</td></tr>
    <tr><td class="paramname">numberOfBytesWritten</td><td>A pointer to a variable that receives the number of bytes transferred into the specified buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true when the function succeeds; otherwise false. To get extended error information, call GetLastError.</dd></dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>unmanaged</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a6ba549f844c192db7badb048f39533c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ba549f844c192db7badb048f39533c5">&#9670;&nbsp;</a></span>HasError</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ProcessMemoryUtilities.Managed.NativeWrapper.HasError =&gt; _lastError != 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the previously called method on this thread was successful. </p>

</div>
</div>
<a id="ae385d060ad80a299cceb4a8a25a9c10a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae385d060ad80a299cceb4a8a25a9c10a">&#9670;&nbsp;</a></span>INFINITE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint ProcessMemoryUtilities.Managed.NativeWrapper.INFINITE = uint.MaxValue</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A constant used to specify an infinite waiting period </p>

</div>
</div>
<h2 class="groupheader">Property Documentation</h2>
<a id="a66041f257d175ab349e2333d875d6198"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66041f257d175ab349e2333d875d6198">&#9670;&nbsp;</a></span>CaptureErrors</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ProcessMemoryUtilities.Managed.NativeWrapper.CaptureErrors</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">get</span><span class="mlabel">set</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether to capture the "LastError". </p>

</div>
</div>
<a id="a91bd57e60e710712659cbe994a3034ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91bd57e60e710712659cbe994a3034ce">&#9670;&nbsp;</a></span>LastError</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int? ProcessMemoryUtilities.Managed.NativeWrapper.LastError</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the win32 error code set by the last failed method on this thread. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>NativeWrapper.CRT.cs</li>
<li>NativeWrapper.cs</li>
<li>NativeWrapper.Kernel.cs</li>
<li>NativeWrapper.OP.cs</li>
<li>NativeWrapper.RPM.cs</li>
<li>NativeWrapper.V.cs</li>
<li>NativeWrapper.WPM.cs</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_process_memory_utilities.html">ProcessMemoryUtilities</a></li><li class="navelem"><a class="el" href="namespace_process_memory_utilities_1_1_managed.html">Managed</a></li><li class="navelem"><a class="el" href="class_process_memory_utilities_1_1_managed_1_1_native_wrapper.html">NativeWrapper</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.15 </li>
  </ul>
</div>
</body>
</html>
