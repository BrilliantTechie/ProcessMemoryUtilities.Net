<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ProcessMemoryUtilities.Net: ProcessMemoryUtilities.Native.NtDll Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ProcessMemoryUtilities.Net
   &#160;<span id="projectnumber">1.3.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('class_process_memory_utilities_1_1_native_1_1_nt_dll.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="class_process_memory_utilities_1_1_native_1_1_nt_dll-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ProcessMemoryUtilities.Native.NtDll Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Provides access to some methods of ntdll.dll  
 <a href="class_process_memory_utilities_1_1_native_1_1_nt_dll.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a258cefa755a564efd38ba09d31fffdb6"><td class="memItemLeft" align="right" valign="top">static uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_process_memory_utilities_1_1_native_1_1_nt_dll.html#a258cefa755a564efd38ba09d31fffdb6">RtlNtStatusToDosError</a> (uint value)</td></tr>
<tr class="memdesc:a258cefa755a564efd38ba09d31fffdb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the specified NTSTATUS code to its equivalent system error code.  <a href="#a258cefa755a564efd38ba09d31fffdb6">More...</a><br /></td></tr>
<tr class="separator:a258cefa755a564efd38ba09d31fffdb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a13a9c8abe715e084c32c1c85b6e8c9"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_process_memory_utilities_1_1_native_1_1_nt_dll.html#a1a13a9c8abe715e084c32c1c85b6e8c9">NtSuccess</a> (uint value)</td></tr>
<tr class="memdesc:a1a13a9c8abe715e084c32c1c85b6e8c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the specified NTSTATUS is a success or informational type.  <a href="#a1a13a9c8abe715e084c32c1c85b6e8c9">More...</a><br /></td></tr>
<tr class="separator:a1a13a9c8abe715e084c32c1c85b6e8c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17b6a73c98659b634bdf307c474d8fb8"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_process_memory_utilities_1_1_native_1_1_nt_dll.html#a17b6a73c98659b634bdf307c474d8fb8">NtSuccessOnly</a> (uint value)</td></tr>
<tr class="memdesc:a17b6a73c98659b634bdf307c474d8fb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the specified NTSTATUS is a success type.  <a href="#a17b6a73c98659b634bdf307c474d8fb8">More...</a><br /></td></tr>
<tr class="separator:a17b6a73c98659b634bdf307c474d8fb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05a8ea78edac1a8c358f939aad93a264"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_process_memory_utilities_1_1_native_1_1_nt_dll.html#a05a8ea78edac1a8c358f939aad93a264">NtInformation</a> (uint value)</td></tr>
<tr class="memdesc:a05a8ea78edac1a8c358f939aad93a264"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the specified NTSTATUS is a informational type.  <a href="#a05a8ea78edac1a8c358f939aad93a264">More...</a><br /></td></tr>
<tr class="separator:a05a8ea78edac1a8c358f939aad93a264"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dcb983defbb18bc69ba05f46cc4c68a"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_process_memory_utilities_1_1_native_1_1_nt_dll.html#a4dcb983defbb18bc69ba05f46cc4c68a">NtWarning</a> (uint value)</td></tr>
<tr class="memdesc:a4dcb983defbb18bc69ba05f46cc4c68a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the specified NTSTATUS is a warning type.  <a href="#a4dcb983defbb18bc69ba05f46cc4c68a">More...</a><br /></td></tr>
<tr class="separator:a4dcb983defbb18bc69ba05f46cc4c68a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a508477c71a2362ba36ab6c742bbc1dfd"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_process_memory_utilities_1_1_native_1_1_nt_dll.html#a508477c71a2362ba36ab6c742bbc1dfd">NtError</a> (uint value)</td></tr>
<tr class="memdesc:a508477c71a2362ba36ab6c742bbc1dfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the specified NTSTATUS is a error type.  <a href="#a508477c71a2362ba36ab6c742bbc1dfd">More...</a><br /></td></tr>
<tr class="separator:a508477c71a2362ba36ab6c742bbc1dfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fa713b81e28abb77aff9aefccb08c3b"><td class="memItemLeft" align="right" valign="top">static uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_process_memory_utilities_1_1_native_1_1_nt_dll.html#a1fa713b81e28abb77aff9aefccb08c3b">NtClose</a> (IntPtr handle)</td></tr>
<tr class="memdesc:a1fa713b81e28abb77aff9aefccb08c3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes an open object handle.  <a href="#a1fa713b81e28abb77aff9aefccb08c3b">More...</a><br /></td></tr>
<tr class="separator:a1fa713b81e28abb77aff9aefccb08c3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad77e2d9b34773356e9406efded8719b1"><td class="memItemLeft" align="right" valign="top">static uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_process_memory_utilities_1_1_native_1_1_nt_dll.html#ad77e2d9b34773356e9406efded8719b1">NtOpenProcess</a> (<a class="el" href="namespace_process_memory_utilities_1_1_native.html#abdfccb438f768cae26c138a43489d2ff">ProcessAccessFlags</a> desiredAccess, int processId, out IntPtr handle)</td></tr>
<tr class="memdesc:ad77e2d9b34773356e9406efded8719b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens an existing local process object.  <a href="#ad77e2d9b34773356e9406efded8719b1">More...</a><br /></td></tr>
<tr class="separator:ad77e2d9b34773356e9406efded8719b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59a45a49292b97df48938578b5eb9177"><td class="memItemLeft" align="right" valign="top">static uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_process_memory_utilities_1_1_native_1_1_nt_dll.html#a59a45a49292b97df48938578b5eb9177">NtOpenProcess</a> (<a class="el" href="namespace_process_memory_utilities_1_1_native.html#abdfccb438f768cae26c138a43489d2ff">ProcessAccessFlags</a> desiredAccess, bool inheritHandle, int processId, out IntPtr handle)</td></tr>
<tr class="memdesc:a59a45a49292b97df48938578b5eb9177"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens an existing local process object.  <a href="#a59a45a49292b97df48938578b5eb9177">More...</a><br /></td></tr>
<tr class="separator:a59a45a49292b97df48938578b5eb9177"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5452370c265199e375a6e11c4aa6e17c"><td class="memItemLeft" align="right" valign="top">static uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_process_memory_utilities_1_1_native_1_1_nt_dll.html#a5452370c265199e375a6e11c4aa6e17c">NtReadVirtualMemory</a> (IntPtr handle, IntPtr baseAddress, IntPtr buffer, IntPtr size, IntPtr numberOfBytesRead)</td></tr>
<tr class="memdesc:a5452370c265199e375a6e11c4aa6e17c"><td class="mdescLeft">&#160;</td><td class="mdescRight">ReadProcessMemory copies the data in the specified address range from the address space of the specified process into the specified buffer of the current process. Any process that has a handle with PROCESS_VM_READ access can call the function. The entire area to be read must be accessible, and if it is not accessible, the function fails.  <a href="#a5452370c265199e375a6e11c4aa6e17c">More...</a><br /></td></tr>
<tr class="separator:a5452370c265199e375a6e11c4aa6e17c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27ef2ee3d936c3f64e78a9a820f1cc28"><td class="memItemLeft" align="right" valign="top">static uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_process_memory_utilities_1_1_native_1_1_nt_dll.html#a27ef2ee3d936c3f64e78a9a820f1cc28">NtReadVirtualMemory</a> (IntPtr handle, IntPtr baseAddress, IntPtr buffer, IntPtr size, out IntPtr numberOfBytesRead)</td></tr>
<tr class="memdesc:a27ef2ee3d936c3f64e78a9a820f1cc28"><td class="mdescLeft">&#160;</td><td class="mdescRight">ReadProcessMemory copies the data in the specified address range from the address space of the specified process into the specified buffer of the current process. Any process that has a handle with PROCESS_VM_READ access can call the function. The entire area to be read must be accessible, and if it is not accessible, the function fails.  <a href="#a27ef2ee3d936c3f64e78a9a820f1cc28">More...</a><br /></td></tr>
<tr class="separator:a27ef2ee3d936c3f64e78a9a820f1cc28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dcdeed8ef57278496f22f062eed66af"><td class="memItemLeft" align="right" valign="top">static uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_process_memory_utilities_1_1_native_1_1_nt_dll.html#a0dcdeed8ef57278496f22f062eed66af">NtReadVirtualMemory</a> (IntPtr handle, IntPtr baseAddress, IntPtr buffer, IntPtr size)</td></tr>
<tr class="memdesc:a0dcdeed8ef57278496f22f062eed66af"><td class="mdescLeft">&#160;</td><td class="mdescRight">ReadProcessMemory copies the data in the specified address range from the address space of the specified process into the specified buffer of the current process. Any process that has a handle with PROCESS_VM_READ access can call the function. The entire area to be read must be accessible, and if it is not accessible, the function fails.  <a href="#a0dcdeed8ef57278496f22f062eed66af">More...</a><br /></td></tr>
<tr class="separator:a0dcdeed8ef57278496f22f062eed66af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e26eadcc1bd147c4803b7c94d55aef4"><td class="memItemLeft" align="right" valign="top">static uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_process_memory_utilities_1_1_native_1_1_nt_dll.html#a2e26eadcc1bd147c4803b7c94d55aef4">NtReadVirtualMemory&lt; T &gt;</a> (IntPtr handle, IntPtr baseAddress, ref T buffer)</td></tr>
<tr class="memdesc:a2e26eadcc1bd147c4803b7c94d55aef4"><td class="mdescLeft">&#160;</td><td class="mdescRight">ReadProcessMemory copies the data in the specified address range from the address space of the specified process into the specified buffer of the current process. Any process that has a handle with PROCESS_VM_READ access can call the function. The entire area to be read must be accessible, and if it is not accessible, the function fails.  <a href="#a2e26eadcc1bd147c4803b7c94d55aef4">More...</a><br /></td></tr>
<tr class="separator:a2e26eadcc1bd147c4803b7c94d55aef4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a451e9c5b938fd0c3f6c37d3366791d43"><td class="memItemLeft" align="right" valign="top">static uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_process_memory_utilities_1_1_native_1_1_nt_dll.html#a451e9c5b938fd0c3f6c37d3366791d43">NtReadVirtualMemory&lt; T &gt;</a> (IntPtr handle, IntPtr baseAddress, ref T buffer, out IntPtr numberOfBytesRead)</td></tr>
<tr class="memdesc:a451e9c5b938fd0c3f6c37d3366791d43"><td class="mdescLeft">&#160;</td><td class="mdescRight">ReadProcessMemory copies the data in the specified address range from the address space of the specified process into the specified buffer of the current process. Any process that has a handle with PROCESS_VM_READ access can call the function. The entire area to be read must be accessible, and if it is not accessible, the function fails.  <a href="#a451e9c5b938fd0c3f6c37d3366791d43">More...</a><br /></td></tr>
<tr class="separator:a451e9c5b938fd0c3f6c37d3366791d43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af95ef9217cc4632dfe5e21718df2f9f7"><td class="memItemLeft" align="right" valign="top">static uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_process_memory_utilities_1_1_native_1_1_nt_dll.html#af95ef9217cc4632dfe5e21718df2f9f7">NtReadVirtualMemoryArray&lt; T &gt;</a> (IntPtr handle, IntPtr baseAddress, T[] buffer, int offset, int length)</td></tr>
<tr class="memdesc:af95ef9217cc4632dfe5e21718df2f9f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">ReadProcessMemory copies the data in the specified address range from the address space of the specified process into the specified buffer of the current process. Any process that has a handle with PROCESS_VM_READ access can call the function. The entire area to be read must be accessible, and if it is not accessible, the function fails.  <a href="#af95ef9217cc4632dfe5e21718df2f9f7">More...</a><br /></td></tr>
<tr class="separator:af95ef9217cc4632dfe5e21718df2f9f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add7ab85c7888c406e9a7bb0fcd0e314a"><td class="memItemLeft" align="right" valign="top">static uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_process_memory_utilities_1_1_native_1_1_nt_dll.html#add7ab85c7888c406e9a7bb0fcd0e314a">NtReadVirtualMemoryArray&lt; T &gt;</a> (IntPtr handle, IntPtr baseAddress, T[] buffer, int offset, int length, out IntPtr numberOfBytesRead)</td></tr>
<tr class="memdesc:add7ab85c7888c406e9a7bb0fcd0e314a"><td class="mdescLeft">&#160;</td><td class="mdescRight">ReadProcessMemory copies the data in the specified address range from the address space of the specified process into the specified buffer of the current process. Any process that has a handle with PROCESS_VM_READ access can call the function. The entire area to be read must be accessible, and if it is not accessible, the function fails.  <a href="#add7ab85c7888c406e9a7bb0fcd0e314a">More...</a><br /></td></tr>
<tr class="separator:add7ab85c7888c406e9a7bb0fcd0e314a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8d1a2e707e10af2da946bf0d03ef259"><td class="memItemLeft" align="right" valign="top">static uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_process_memory_utilities_1_1_native_1_1_nt_dll.html#af8d1a2e707e10af2da946bf0d03ef259">NtReadVirtualMemoryArray&lt; T &gt;</a> (IntPtr handle, IntPtr baseAddress, T[] buffer, int offset)</td></tr>
<tr class="memdesc:af8d1a2e707e10af2da946bf0d03ef259"><td class="mdescLeft">&#160;</td><td class="mdescRight">ReadProcessMemory copies the data in the specified address range from the address space of the specified process into the specified buffer of the current process. Any process that has a handle with PROCESS_VM_READ access can call the function. The entire area to be read must be accessible, and if it is not accessible, the function fails.  <a href="#af8d1a2e707e10af2da946bf0d03ef259">More...</a><br /></td></tr>
<tr class="separator:af8d1a2e707e10af2da946bf0d03ef259"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a624275e9caf0ed4306b87d6cbb45f703"><td class="memItemLeft" align="right" valign="top">static uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_process_memory_utilities_1_1_native_1_1_nt_dll.html#a624275e9caf0ed4306b87d6cbb45f703">NtReadVirtualMemoryArray&lt; T &gt;</a> (IntPtr handle, IntPtr baseAddress, T[] buffer, int offset, out IntPtr numberOfBytesRead)</td></tr>
<tr class="memdesc:a624275e9caf0ed4306b87d6cbb45f703"><td class="mdescLeft">&#160;</td><td class="mdescRight">ReadProcessMemory copies the data in the specified address range from the address space of the specified process into the specified buffer of the current process. Any process that has a handle with PROCESS_VM_READ access can call the function. The entire area to be read must be accessible, and if it is not accessible, the function fails.  <a href="#a624275e9caf0ed4306b87d6cbb45f703">More...</a><br /></td></tr>
<tr class="separator:a624275e9caf0ed4306b87d6cbb45f703"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5cc931ed3f232600ab34b9198548c9d"><td class="memItemLeft" align="right" valign="top">static uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_process_memory_utilities_1_1_native_1_1_nt_dll.html#af5cc931ed3f232600ab34b9198548c9d">NtReadVirtualMemoryArray&lt; T &gt;</a> (IntPtr handle, IntPtr baseAddress, T[] buffer)</td></tr>
<tr class="memdesc:af5cc931ed3f232600ab34b9198548c9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">ReadProcessMemory copies the data in the specified address range from the address space of the specified process into the specified buffer of the current process. Any process that has a handle with PROCESS_VM_READ access can call the function. The entire area to be read must be accessible, and if it is not accessible, the function fails.  <a href="#af5cc931ed3f232600ab34b9198548c9d">More...</a><br /></td></tr>
<tr class="separator:af5cc931ed3f232600ab34b9198548c9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9aac5cdf02e55421b21697af810c6ea"><td class="memItemLeft" align="right" valign="top">static uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_process_memory_utilities_1_1_native_1_1_nt_dll.html#ae9aac5cdf02e55421b21697af810c6ea">NtReadVirtualMemoryArray&lt; T &gt;</a> (IntPtr handle, IntPtr baseAddress, T[] buffer, out IntPtr numberOfBytesRead)</td></tr>
<tr class="memdesc:ae9aac5cdf02e55421b21697af810c6ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">ReadProcessMemory copies the data in the specified address range from the address space of the specified process into the specified buffer of the current process. Any process that has a handle with PROCESS_VM_READ access can call the function. The entire area to be read must be accessible, and if it is not accessible, the function fails.  <a href="#ae9aac5cdf02e55421b21697af810c6ea">More...</a><br /></td></tr>
<tr class="separator:ae9aac5cdf02e55421b21697af810c6ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a784e4099a4e82214e3f0d860467bb50a"><td class="memItemLeft" align="right" valign="top">static uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_process_memory_utilities_1_1_native_1_1_nt_dll.html#a784e4099a4e82214e3f0d860467bb50a">NtReadVirtualMemoryPartial&lt; T &gt;</a> (IntPtr handle, IntPtr baseAddress, ref T buffer, int offset, int length)</td></tr>
<tr class="memdesc:a784e4099a4e82214e3f0d860467bb50a"><td class="mdescLeft">&#160;</td><td class="mdescRight">ReadProcessMemory copies the data in the specified address range from the address space of the specified process into the specified buffer of the current process. Any process that has a handle with PROCESS_VM_READ access can call the function. The entire area to be read must be accessible, and if it is not accessible, the function fails.  <a href="#a784e4099a4e82214e3f0d860467bb50a">More...</a><br /></td></tr>
<tr class="separator:a784e4099a4e82214e3f0d860467bb50a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6a288474c6a814634e77c11db009fab"><td class="memItemLeft" align="right" valign="top">static uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_process_memory_utilities_1_1_native_1_1_nt_dll.html#ae6a288474c6a814634e77c11db009fab">NtReadVirtualMemoryPartial&lt; T &gt;</a> (IntPtr handle, IntPtr baseAddress, ref T buffer, int offset, int length, out IntPtr numberOfBytesRead)</td></tr>
<tr class="memdesc:ae6a288474c6a814634e77c11db009fab"><td class="mdescLeft">&#160;</td><td class="mdescRight">ReadProcessMemory copies the data in the specified address range from the address space of the specified process into the specified buffer of the current process. Any process that has a handle with PROCESS_VM_READ access can call the function. The entire area to be read must be accessible, and if it is not accessible, the function fails.  <a href="#ae6a288474c6a814634e77c11db009fab">More...</a><br /></td></tr>
<tr class="separator:ae6a288474c6a814634e77c11db009fab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11ea85527ac4e707d06dd93300c36d95"><td class="memItemLeft" align="right" valign="top">static uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_process_memory_utilities_1_1_native_1_1_nt_dll.html#a11ea85527ac4e707d06dd93300c36d95">NtReadVirtualMemoryPartial&lt; T &gt;</a> (IntPtr handle, IntPtr baseAddress, ref T buffer, int offset)</td></tr>
<tr class="memdesc:a11ea85527ac4e707d06dd93300c36d95"><td class="mdescLeft">&#160;</td><td class="mdescRight">ReadProcessMemory copies the data in the specified address range from the address space of the specified process into the specified buffer of the current process. Any process that has a handle with PROCESS_VM_READ access can call the function. The entire area to be read must be accessible, and if it is not accessible, the function fails.  <a href="#a11ea85527ac4e707d06dd93300c36d95">More...</a><br /></td></tr>
<tr class="separator:a11ea85527ac4e707d06dd93300c36d95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8ee911091188dd8a105b0e2e4be71f5"><td class="memItemLeft" align="right" valign="top">static uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_process_memory_utilities_1_1_native_1_1_nt_dll.html#af8ee911091188dd8a105b0e2e4be71f5">NtReadVirtualMemoryPartial&lt; T &gt;</a> (IntPtr handle, IntPtr baseAddress, ref T buffer, int offset, out IntPtr numberOfBytesRead)</td></tr>
<tr class="memdesc:af8ee911091188dd8a105b0e2e4be71f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">ReadProcessMemory copies the data in the specified address range from the address space of the specified process into the specified buffer of the current process. Any process that has a handle with PROCESS_VM_READ access can call the function. The entire area to be read must be accessible, and if it is not accessible, the function fails.  <a href="#af8ee911091188dd8a105b0e2e4be71f5">More...</a><br /></td></tr>
<tr class="separator:af8ee911091188dd8a105b0e2e4be71f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64cd55f68724f0f46de864cd041665ce"><td class="memItemLeft" align="right" valign="top">static uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_process_memory_utilities_1_1_native_1_1_nt_dll.html#a64cd55f68724f0f46de864cd041665ce">NtAllocateVirtualMemory</a> (IntPtr handle, IntPtr size, <a class="el" href="namespace_process_memory_utilities_1_1_native.html#a0729ee4af770ea067d43d9761df4cbdb">AllocationType</a> allocationType, <a class="el" href="namespace_process_memory_utilities_1_1_native.html#a253e5867c7af9a40486194ce6ab3cf53">MemoryProtectionFlags</a> memoryProtection, out IntPtr address)</td></tr>
<tr class="memdesc:a64cd55f68724f0f46de864cd041665ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserves, commits, or changes the state of a region of memory within the virtual address space of a specified process. The function initializes the memory it allocates to zero.  <a href="#a64cd55f68724f0f46de864cd041665ce">More...</a><br /></td></tr>
<tr class="separator:a64cd55f68724f0f46de864cd041665ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93439ba2c60bfee60965ba9ac49f10a3"><td class="memItemLeft" align="right" valign="top">static uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_process_memory_utilities_1_1_native_1_1_nt_dll.html#a93439ba2c60bfee60965ba9ac49f10a3">NtFreeVirtualMemory</a> (IntPtr handle, IntPtr address, IntPtr size, <a class="el" href="namespace_process_memory_utilities_1_1_native.html#adb58001ff27279e48c274189fcab7293">FreeType</a> freeType)</td></tr>
<tr class="memdesc:a93439ba2c60bfee60965ba9ac49f10a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases, decommits, or releases and decommits a region of memory within the virtual address space of a specified process.  <a href="#a93439ba2c60bfee60965ba9ac49f10a3">More...</a><br /></td></tr>
<tr class="separator:a93439ba2c60bfee60965ba9ac49f10a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa46fb903c74c0032968b4bb3b7d946f7"><td class="memItemLeft" align="right" valign="top">static uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_process_memory_utilities_1_1_native_1_1_nt_dll.html#aa46fb903c74c0032968b4bb3b7d946f7">NtProtectVirtualMemory</a> (IntPtr handle, IntPtr address, IntPtr size, <a class="el" href="namespace_process_memory_utilities_1_1_native.html#a253e5867c7af9a40486194ce6ab3cf53">MemoryProtectionFlags</a> newProtection, out <a class="el" href="namespace_process_memory_utilities_1_1_native.html#a253e5867c7af9a40486194ce6ab3cf53">MemoryProtectionFlags</a> oldProtection)</td></tr>
<tr class="memdesc:aa46fb903c74c0032968b4bb3b7d946f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the protection on a region of committed pages in the virtual address space of a specified process.  <a href="#aa46fb903c74c0032968b4bb3b7d946f7">More...</a><br /></td></tr>
<tr class="separator:aa46fb903c74c0032968b4bb3b7d946f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc3b76c71aa2037f15a16079de57b433"><td class="memItemLeft" align="right" valign="top">static uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_process_memory_utilities_1_1_native_1_1_nt_dll.html#afc3b76c71aa2037f15a16079de57b433">NtWriteVirtualMemory</a> (IntPtr handle, IntPtr baseAddress, IntPtr buffer, IntPtr size, IntPtr numberOfBytesWritten)</td></tr>
<tr class="memdesc:afc3b76c71aa2037f15a16079de57b433"><td class="mdescLeft">&#160;</td><td class="mdescRight">WriteProcessMemory copies the data from the specified buffer in the current process to the address range of the specified process. Any process that has a handle with PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process to be written to can call the function. Typically but not always, the process with address space that is being written to is being debugged. The entire area to be written to must be accessible, and if it is not accessible, the function fails.  <a href="#afc3b76c71aa2037f15a16079de57b433">More...</a><br /></td></tr>
<tr class="separator:afc3b76c71aa2037f15a16079de57b433"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3b4046237e2fa9b9b67d5bd171dfa37"><td class="memItemLeft" align="right" valign="top">static uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_process_memory_utilities_1_1_native_1_1_nt_dll.html#ab3b4046237e2fa9b9b67d5bd171dfa37">NtWriteVirtualMemory</a> (IntPtr handle, IntPtr baseAddress, IntPtr buffer, IntPtr size, out IntPtr numberOfBytesWritten)</td></tr>
<tr class="memdesc:ab3b4046237e2fa9b9b67d5bd171dfa37"><td class="mdescLeft">&#160;</td><td class="mdescRight">WriteProcessMemory copies the data from the specified buffer in the current process to the address range of the specified process. Any process that has a handle with PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process to be written to can call the function. Typically but not always, the process with address space that is being written to is being debugged. The entire area to be written to must be accessible, and if it is not accessible, the function fails.  <a href="#ab3b4046237e2fa9b9b67d5bd171dfa37">More...</a><br /></td></tr>
<tr class="separator:ab3b4046237e2fa9b9b67d5bd171dfa37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cf63ae337ed6239ebe8a712a98ebc48"><td class="memItemLeft" align="right" valign="top">static uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_process_memory_utilities_1_1_native_1_1_nt_dll.html#a3cf63ae337ed6239ebe8a712a98ebc48">NtWriteVirtualMemory</a> (IntPtr handle, IntPtr baseAddress, IntPtr buffer, IntPtr size)</td></tr>
<tr class="memdesc:a3cf63ae337ed6239ebe8a712a98ebc48"><td class="mdescLeft">&#160;</td><td class="mdescRight">WriteProcessMemory copies the data from the specified buffer in the current process to the address range of the specified process. Any process that has a handle with PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process to be written to can call the function. Typically but not always, the process with address space that is being written to is being debugged. The entire area to be written to must be accessible, and if it is not accessible, the function fails.  <a href="#a3cf63ae337ed6239ebe8a712a98ebc48">More...</a><br /></td></tr>
<tr class="separator:a3cf63ae337ed6239ebe8a712a98ebc48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77120a88bf74554776c3b99fc140c742"><td class="memItemLeft" align="right" valign="top">static uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_process_memory_utilities_1_1_native_1_1_nt_dll.html#a77120a88bf74554776c3b99fc140c742">NtWriteVirtualMemory&lt; T &gt;</a> (IntPtr handle, IntPtr baseAddress, ref T buffer)</td></tr>
<tr class="memdesc:a77120a88bf74554776c3b99fc140c742"><td class="mdescLeft">&#160;</td><td class="mdescRight">WriteProcessMemory copies the data from the specified buffer in the current process to the address range of the specified process. Any process that has a handle with PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process to be written to can call the function. Typically but not always, the process with address space that is being written to is being debugged. The entire area to be written to must be accessible, and if it is not accessible, the function fails.  <a href="#a77120a88bf74554776c3b99fc140c742">More...</a><br /></td></tr>
<tr class="separator:a77120a88bf74554776c3b99fc140c742"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae439e711d12a805df3e498b9d78d37b2"><td class="memItemLeft" align="right" valign="top">static uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_process_memory_utilities_1_1_native_1_1_nt_dll.html#ae439e711d12a805df3e498b9d78d37b2">NtWriteVirtualMemory&lt; T &gt;</a> (IntPtr handle, IntPtr baseAddress, ref T buffer, out IntPtr numberOfBytesWritten)</td></tr>
<tr class="memdesc:ae439e711d12a805df3e498b9d78d37b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">WriteProcessMemory copies the data from the specified buffer in the current process to the address range of the specified process. Any process that has a handle with PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process to be written to can call the function. Typically but not always, the process with address space that is being written to is being debugged. The entire area to be written to must be accessible, and if it is not accessible, the function fails.  <a href="#ae439e711d12a805df3e498b9d78d37b2">More...</a><br /></td></tr>
<tr class="separator:ae439e711d12a805df3e498b9d78d37b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a804ef50512b5815fa6f5913feb929e59"><td class="memItemLeft" align="right" valign="top">static uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_process_memory_utilities_1_1_native_1_1_nt_dll.html#a804ef50512b5815fa6f5913feb929e59">NtWriteVirtualMemoryArray&lt; T &gt;</a> (IntPtr handle, IntPtr baseAddress, T[] buffer, int offset, int length)</td></tr>
<tr class="memdesc:a804ef50512b5815fa6f5913feb929e59"><td class="mdescLeft">&#160;</td><td class="mdescRight">WriteProcessMemory copies the data from the specified buffer in the current process to the address range of the specified process. Any process that has a handle with PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process to be written to can call the function. Typically but not always, the process with address space that is being written to is being debugged. The entire area to be written to must be accessible, and if it is not accessible, the function fails.  <a href="#a804ef50512b5815fa6f5913feb929e59">More...</a><br /></td></tr>
<tr class="separator:a804ef50512b5815fa6f5913feb929e59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a631e466d0e1e4e3e84b5aeb02d511b2e"><td class="memItemLeft" align="right" valign="top">static uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_process_memory_utilities_1_1_native_1_1_nt_dll.html#a631e466d0e1e4e3e84b5aeb02d511b2e">NtWriteVirtualMemoryArray&lt; T &gt;</a> (IntPtr handle, IntPtr baseAddress, T[] buffer, int offset, int length, out IntPtr numberOfBytesWritten)</td></tr>
<tr class="memdesc:a631e466d0e1e4e3e84b5aeb02d511b2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">WriteProcessMemory copies the data from the specified buffer in the current process to the address range of the specified process. Any process that has a handle with PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process to be written to can call the function. Typically but not always, the process with address space that is being written to is being debugged. The entire area to be written to must be accessible, and if it is not accessible, the function fails.  <a href="#a631e466d0e1e4e3e84b5aeb02d511b2e">More...</a><br /></td></tr>
<tr class="separator:a631e466d0e1e4e3e84b5aeb02d511b2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf205dc691b5544105f51cb4bb663238"><td class="memItemLeft" align="right" valign="top">static uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_process_memory_utilities_1_1_native_1_1_nt_dll.html#abf205dc691b5544105f51cb4bb663238">NtWriteVirtualMemoryArray&lt; T &gt;</a> (IntPtr handle, IntPtr baseAddress, T[] buffer, int offset)</td></tr>
<tr class="memdesc:abf205dc691b5544105f51cb4bb663238"><td class="mdescLeft">&#160;</td><td class="mdescRight">WriteProcessMemory copies the data from the specified buffer in the current process to the address range of the specified process. Any process that has a handle with PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process to be written to can call the function. Typically but not always, the process with address space that is being written to is being debugged. The entire area to be written to must be accessible, and if it is not accessible, the function fails.  <a href="#abf205dc691b5544105f51cb4bb663238">More...</a><br /></td></tr>
<tr class="separator:abf205dc691b5544105f51cb4bb663238"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eadcfabedef350bc33e228d99c0f1ae"><td class="memItemLeft" align="right" valign="top">static uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_process_memory_utilities_1_1_native_1_1_nt_dll.html#a1eadcfabedef350bc33e228d99c0f1ae">NtWriteVirtualMemoryArray&lt; T &gt;</a> (IntPtr handle, IntPtr baseAddress, T[] buffer, int offset, out IntPtr numberOfBytesWritten)</td></tr>
<tr class="memdesc:a1eadcfabedef350bc33e228d99c0f1ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">WriteProcessMemory copies the data from the specified buffer in the current process to the address range of the specified process. Any process that has a handle with PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process to be written to can call the function. Typically but not always, the process with address space that is being written to is being debugged. The entire area to be written to must be accessible, and if it is not accessible, the function fails.  <a href="#a1eadcfabedef350bc33e228d99c0f1ae">More...</a><br /></td></tr>
<tr class="separator:a1eadcfabedef350bc33e228d99c0f1ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d1b8b6a91cee2f98861779a7137abb8"><td class="memItemLeft" align="right" valign="top">static uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_process_memory_utilities_1_1_native_1_1_nt_dll.html#a8d1b8b6a91cee2f98861779a7137abb8">NtWriteVirtualMemoryArray&lt; T &gt;</a> (IntPtr handle, IntPtr baseAddress, T[] buffer)</td></tr>
<tr class="memdesc:a8d1b8b6a91cee2f98861779a7137abb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">WriteProcessMemory copies the data from the specified buffer in the current process to the address range of the specified process. Any process that has a handle with PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process to be written to can call the function. Typically but not always, the process with address space that is being written to is being debugged. The entire area to be written to must be accessible, and if it is not accessible, the function fails.  <a href="#a8d1b8b6a91cee2f98861779a7137abb8">More...</a><br /></td></tr>
<tr class="separator:a8d1b8b6a91cee2f98861779a7137abb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5623ae258b5dd0d21b2c49bf89396d17"><td class="memItemLeft" align="right" valign="top">static uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_process_memory_utilities_1_1_native_1_1_nt_dll.html#a5623ae258b5dd0d21b2c49bf89396d17">NtWriteVirtualMemoryArray&lt; T &gt;</a> (IntPtr handle, IntPtr baseAddress, T[] buffer, out IntPtr numberOfBytesWritten)</td></tr>
<tr class="memdesc:a5623ae258b5dd0d21b2c49bf89396d17"><td class="mdescLeft">&#160;</td><td class="mdescRight">WriteProcessMemory copies the data from the specified buffer in the current process to the address range of the specified process. Any process that has a handle with PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process to be written to can call the function. Typically but not always, the process with address space that is being written to is being debugged. The entire area to be written to must be accessible, and if it is not accessible, the function fails.  <a href="#a5623ae258b5dd0d21b2c49bf89396d17">More...</a><br /></td></tr>
<tr class="separator:a5623ae258b5dd0d21b2c49bf89396d17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eda4f3f1b41a9f379c44eb579c6c3f5"><td class="memItemLeft" align="right" valign="top">static uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_process_memory_utilities_1_1_native_1_1_nt_dll.html#a9eda4f3f1b41a9f379c44eb579c6c3f5">NtWriteVirtualMemoryPartial&lt; T &gt;</a> (IntPtr handle, IntPtr baseAddress, ref T buffer, int offset, int length)</td></tr>
<tr class="memdesc:a9eda4f3f1b41a9f379c44eb579c6c3f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">WriteProcessMemory copies the data from the specified buffer in the current process to the address range of the specified process. Any process that has a handle with PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process to be written to can call the function. Typically but not always, the process with address space that is being written to is being debugged. The entire area to be written to must be accessible, and if it is not accessible, the function fails.  <a href="#a9eda4f3f1b41a9f379c44eb579c6c3f5">More...</a><br /></td></tr>
<tr class="separator:a9eda4f3f1b41a9f379c44eb579c6c3f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a341df8038f54311f460e7e576d23ea1c"><td class="memItemLeft" align="right" valign="top">static uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_process_memory_utilities_1_1_native_1_1_nt_dll.html#a341df8038f54311f460e7e576d23ea1c">NtWriteVirtualMemoryPartial&lt; T &gt;</a> (IntPtr handle, IntPtr baseAddress, ref T buffer, int offset, int length, out IntPtr numberOfBytesWritten)</td></tr>
<tr class="memdesc:a341df8038f54311f460e7e576d23ea1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">WriteProcessMemory copies the data from the specified buffer in the current process to the address range of the specified process. Any process that has a handle with PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process to be written to can call the function. Typically but not always, the process with address space that is being written to is being debugged. The entire area to be written to must be accessible, and if it is not accessible, the function fails.  <a href="#a341df8038f54311f460e7e576d23ea1c">More...</a><br /></td></tr>
<tr class="separator:a341df8038f54311f460e7e576d23ea1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ccd0899e60fc5507c08cea784d2c40d"><td class="memItemLeft" align="right" valign="top">static uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_process_memory_utilities_1_1_native_1_1_nt_dll.html#a7ccd0899e60fc5507c08cea784d2c40d">NtWriteVirtualMemoryPartial&lt; T &gt;</a> (IntPtr handle, IntPtr baseAddress, ref T buffer, int offset)</td></tr>
<tr class="memdesc:a7ccd0899e60fc5507c08cea784d2c40d"><td class="mdescLeft">&#160;</td><td class="mdescRight">WriteProcessMemory copies the data from the specified buffer in the current process to the address range of the specified process. Any process that has a handle with PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process to be written to can call the function. Typically but not always, the process with address space that is being written to is being debugged. The entire area to be written to must be accessible, and if it is not accessible, the function fails.  <a href="#a7ccd0899e60fc5507c08cea784d2c40d">More...</a><br /></td></tr>
<tr class="separator:a7ccd0899e60fc5507c08cea784d2c40d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a064e46588f39e98f413483da51647d48"><td class="memItemLeft" align="right" valign="top">static uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_process_memory_utilities_1_1_native_1_1_nt_dll.html#a064e46588f39e98f413483da51647d48">NtWriteVirtualMemoryPartial&lt; T &gt;</a> (IntPtr handle, IntPtr baseAddress, ref T buffer, int offset, out IntPtr numberOfBytesWritten)</td></tr>
<tr class="memdesc:a064e46588f39e98f413483da51647d48"><td class="mdescLeft">&#160;</td><td class="mdescRight">WriteProcessMemory copies the data from the specified buffer in the current process to the address range of the specified process. Any process that has a handle with PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process to be written to can call the function. Typically but not always, the process with address space that is being written to is being debugged. The entire area to be written to must be accessible, and if it is not accessible, the function fails.  <a href="#a064e46588f39e98f413483da51647d48">More...</a><br /></td></tr>
<tr class="separator:a064e46588f39e98f413483da51647d48"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Provides access to some methods of ntdll.dll </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a64cd55f68724f0f46de864cd041665ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64cd55f68724f0f46de864cd041665ce">&#9670;&nbsp;</a></span>NtAllocateVirtualMemory()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint ProcessMemoryUtilities.Native.NtDll.NtAllocateVirtualMemory </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_process_memory_utilities_1_1_native.html#a0729ee4af770ea067d43d9761df4cbdb">AllocationType</a>&#160;</td>
          <td class="paramname"><em>allocationType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_process_memory_utilities_1_1_native.html#a253e5867c7af9a40486194ce6ab3cf53">MemoryProtectionFlags</a>&#160;</td>
          <td class="paramname"><em>memoryProtection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out IntPtr&#160;</td>
          <td class="paramname"><em>address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reserves, commits, or changes the state of a region of memory within the virtual address space of a specified process. The function initializes the memory it allocates to zero. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>The handle to a process. The function allocates memory within the virtual address space of this process. The handle must have the PROCESS_VM_OPERATION access right.For more information, see Process Security and Access Rights.</td></tr>
    <tr><td class="paramname">size</td><td>The size of the region of memory to allocate, in bytes.</td></tr>
    <tr><td class="paramname">allocationType</td><td>The type of memory allocation. Common flags are <a class="el" href="namespace_process_memory_utilities_1_1_native.html#a0729ee4af770ea067d43d9761df4cbdba59d5b10c3a447f036d85cb5ce524c96c" title="Allocates memory charges (from the overall size of memory and the paging files on disk) for the speci...">AllocationType.Commit</a> | <a class="el" href="namespace_process_memory_utilities_1_1_native.html#a0729ee4af770ea067d43d9761df4cbdba66f9c6c5b672ee16deeef6e4503cb4bc" title="Reserves a range of the process&#39;s virtual address space without allocating any actual physical storag...">AllocationType.Reserve</a>.</td></tr>
    <tr><td class="paramname">memoryProtection</td><td>The memory protection for the region of pages to be allocated. If the pages are being committed, you can specify any one of the memory protection constants.</td></tr>
    <tr><td class="paramname">address</td><td>A pointer to a variable that receives the base address of the allocated region of pages.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns an NTSTATUS success or error code.</dd></dl>

</div>
</div>
<a id="a1fa713b81e28abb77aff9aefccb08c3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fa713b81e28abb77aff9aefccb08c3b">&#9670;&nbsp;</a></span>NtClose()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint ProcessMemoryUtilities.Native.NtDll.NtClose </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Closes an open object handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A valid handle to an open object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns an NTSTATUS success or error code.</dd></dl>

</div>
</div>
<a id="a508477c71a2362ba36ab6c742bbc1dfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a508477c71a2362ba36ab6c742bbc1dfd">&#9670;&nbsp;</a></span>NtError()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool ProcessMemoryUtilities.Native.NtDll.NtError </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the specified NTSTATUS is a error type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>A NTSTATUS value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the specified NTSTATUS is a error type.</dd></dl>

</div>
</div>
<a id="a93439ba2c60bfee60965ba9ac49f10a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93439ba2c60bfee60965ba9ac49f10a3">&#9670;&nbsp;</a></span>NtFreeVirtualMemory()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint ProcessMemoryUtilities.Native.NtDll.NtFreeVirtualMemory </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_process_memory_utilities_1_1_native.html#adb58001ff27279e48c274189fcab7293">FreeType</a>&#160;</td>
          <td class="paramname"><em>freeType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Releases, decommits, or releases and decommits a region of memory within the virtual address space of a specified process. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A handle to a process. The function frees memory within the virtual address space of the process. The handle must have the PROCESS_VM_OPERATION access right.For more information, see Process Security and Access Rights.</td></tr>
    <tr><td class="paramname">address</td><td>A pointer to the starting address of the region of memory to be freed. If the dwFreeType parameter is MEM_RELEASE, lpAddress must be the base address returned by the VirtualAllocEx function when the region is reserved.</td></tr>
    <tr><td class="paramname">size</td><td>The size of the region of memory to free, in bytes. If the dwFreeType parameter is MEM_RELEASE, dwSize must be 0 (zero). The function frees the entire region that is reserved in the initial allocation call to VirtualAllocEx. If dwFreeType is MEM_DECOMMIT, the function decommits all memory pages that contain one or more bytes in the range from the lpAddress parameter to (lpAddress+dwSize). This means, for example, that a 2-byte region of memory that straddles a page boundary causes both pages to be decommitted. If lpAddress is the base address returned by VirtualAllocEx and dwSize is 0 (zero), the function decommits the entire region that is allocated by VirtualAllocEx. After that, the entire region is in the reserved state.</td></tr>
    <tr><td class="paramname">freeType</td><td>The type of free operation. This parameter can be one of the FreeType values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns an NTSTATUS success or error code.</dd></dl>

</div>
</div>
<a id="a05a8ea78edac1a8c358f939aad93a264"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05a8ea78edac1a8c358f939aad93a264">&#9670;&nbsp;</a></span>NtInformation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool ProcessMemoryUtilities.Native.NtDll.NtInformation </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the specified NTSTATUS is a informational type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>A NTSTATUS value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the specified NTSTATUS is a informational type.</dd></dl>

</div>
</div>
<a id="ad77e2d9b34773356e9406efded8719b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad77e2d9b34773356e9406efded8719b1">&#9670;&nbsp;</a></span>NtOpenProcess() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint ProcessMemoryUtilities.Native.NtDll.NtOpenProcess </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_process_memory_utilities_1_1_native.html#abdfccb438f768cae26c138a43489d2ff">ProcessAccessFlags</a>&#160;</td>
          <td class="paramname"><em>desiredAccess</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>processId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out IntPtr&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Opens an existing local process object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desiredAccess</td><td>The access to the process object. This access right is checked against the security descriptor for the process. This parameter can be one or more of the process access rights.</td></tr>
    <tr><td class="paramname">processId</td><td>The identifier of the local process to be opened.</td></tr>
    <tr><td class="paramname">handle</td><td>A variable that receives the opened handle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns an NTSTATUS success or error code.</dd></dl>

</div>
</div>
<a id="a59a45a49292b97df48938578b5eb9177"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59a45a49292b97df48938578b5eb9177">&#9670;&nbsp;</a></span>NtOpenProcess() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint ProcessMemoryUtilities.Native.NtDll.NtOpenProcess </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_process_memory_utilities_1_1_native.html#abdfccb438f768cae26c138a43489d2ff">ProcessAccessFlags</a>&#160;</td>
          <td class="paramname"><em>desiredAccess</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>inheritHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>processId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out IntPtr&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Opens an existing local process object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desiredAccess</td><td>The access to the process object. This access right is checked against the security descriptor for the process. This parameter can be one or more of the process access rights.</td></tr>
    <tr><td class="paramname">inheritHandle</td><td>If this value is TRUE, processes created by this process will inherit the handle. Otherwise, the processes do not inherit this handle.</td></tr>
    <tr><td class="paramname">processId</td><td>The identifier of the local process to be opened.</td></tr>
    <tr><td class="paramname">handle</td><td>A variable that receives the opened handle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns an NTSTATUS success or error code.</dd></dl>

</div>
</div>
<a id="aa46fb903c74c0032968b4bb3b7d946f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa46fb903c74c0032968b4bb3b7d946f7">&#9670;&nbsp;</a></span>NtProtectVirtualMemory()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint ProcessMemoryUtilities.Native.NtDll.NtProtectVirtualMemory </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_process_memory_utilities_1_1_native.html#a253e5867c7af9a40486194ce6ab3cf53">MemoryProtectionFlags</a>&#160;</td>
          <td class="paramname"><em>newProtection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out <a class="el" href="namespace_process_memory_utilities_1_1_native.html#a253e5867c7af9a40486194ce6ab3cf53">MemoryProtectionFlags</a>&#160;</td>
          <td class="paramname"><em>oldProtection</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Changes the protection on a region of committed pages in the virtual address space of a specified process. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A handle to the process whose memory protection is to be changed. The handle must have the PROCESS_VM_OPERATION access right. For more information, see Process Security and Access Rights.</td></tr>
    <tr><td class="paramname">address</td><td>A pointer to the base address of the region of pages whose access protection attributes are to be changed. All pages in the specified region must be within the same reserved region allocated when calling the VirtualAlloc or VirtualAllocEx function using MEM_RESERVE. The pages cannot span adjacent reserved regions that were allocated by separate calls to VirtualAlloc or VirtualAllocEx using MEM_RESERVE.</td></tr>
    <tr><td class="paramname">size</td><td>The size of the region whose access protection attributes are changed, in bytes. The region of affected pages includes all pages containing one or more bytes in the range from the lpAddress parameter to (lpAddress+dwSize). This means that a 2-byte range straddling a page boundary causes the protection attributes of both pages to be changed.</td></tr>
    <tr><td class="paramname">newProtection</td><td>The memory protection option. This parameter can be one of the MemoryProtectionFlags.</td></tr>
    <tr><td class="paramname">oldProtection</td><td>A pointer to a variable that receives the previous MemoryProtectionFlags of the first page in the specified region of pages.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns an NTSTATUS success or error code.</dd></dl>

</div>
</div>
<a id="a5452370c265199e375a6e11c4aa6e17c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5452370c265199e375a6e11c4aa6e17c">&#9670;&nbsp;</a></span>NtReadVirtualMemory() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint ProcessMemoryUtilities.Native.NtDll.NtReadVirtualMemory </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>baseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>numberOfBytesRead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>ReadProcessMemory copies the data in the specified address range from the address space of the specified process into the specified buffer of the current process. Any process that has a handle with PROCESS_VM_READ access can call the function. The entire area to be read must be accessible, and if it is not accessible, the function fails. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A handle to the process with memory that is being read. The handle must have PROCESS_VM_READ access to the process.</td></tr>
    <tr><td class="paramname">baseAddress</td><td>A pointer to the base address in the specified process from which to read. Before any data transfer occurs, the system verifies that all data in the base address and memory of the specified size is accessible for read access, and if it is not accessible the function fails.</td></tr>
    <tr><td class="paramname">buffer</td><td>A pointer to a buffer that receives the contents from the address space of the specified process.</td></tr>
    <tr><td class="paramname">size</td><td>The number of bytes to be read from the specified process.</td></tr>
    <tr><td class="paramname">numberOfBytesRead</td><td>A pointer to a variable that receives the number of bytes transferred into the specified buffer. If lpNumberOfBytesRead is IntPtr.Zero, the parameter is ignored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns an NTSTATUS success or error code.</dd></dl>

</div>
</div>
<a id="a27ef2ee3d936c3f64e78a9a820f1cc28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27ef2ee3d936c3f64e78a9a820f1cc28">&#9670;&nbsp;</a></span>NtReadVirtualMemory() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint ProcessMemoryUtilities.Native.NtDll.NtReadVirtualMemory </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>baseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out IntPtr&#160;</td>
          <td class="paramname"><em>numberOfBytesRead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>ReadProcessMemory copies the data in the specified address range from the address space of the specified process into the specified buffer of the current process. Any process that has a handle with PROCESS_VM_READ access can call the function. The entire area to be read must be accessible, and if it is not accessible, the function fails. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A handle to the process with memory that is being read. The handle must have PROCESS_VM_READ access to the process.</td></tr>
    <tr><td class="paramname">baseAddress</td><td>A pointer to the base address in the specified process from which to read. Before any data transfer occurs, the system verifies that all data in the base address and memory of the specified size is accessible for read access, and if it is not accessible the function fails.</td></tr>
    <tr><td class="paramname">buffer</td><td>A pointer to a buffer that receives the contents from the address space of the specified process.</td></tr>
    <tr><td class="paramname">size</td><td>The number of bytes to be read from the specified process.</td></tr>
    <tr><td class="paramname">numberOfBytesRead</td><td>A pointer to a variable that receives the number of bytes transferred into the specified buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns an NTSTATUS success or error code.</dd></dl>

</div>
</div>
<a id="a0dcdeed8ef57278496f22f062eed66af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dcdeed8ef57278496f22f062eed66af">&#9670;&nbsp;</a></span>NtReadVirtualMemory() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint ProcessMemoryUtilities.Native.NtDll.NtReadVirtualMemory </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>baseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>ReadProcessMemory copies the data in the specified address range from the address space of the specified process into the specified buffer of the current process. Any process that has a handle with PROCESS_VM_READ access can call the function. The entire area to be read must be accessible, and if it is not accessible, the function fails. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A handle to the process with memory that is being read. The handle must have PROCESS_VM_READ access to the process.</td></tr>
    <tr><td class="paramname">baseAddress</td><td>A pointer to the base address in the specified process from which to read. Before any data transfer occurs, the system verifies that all data in the base address and memory of the specified size is accessible for read access, and if it is not accessible the function fails.</td></tr>
    <tr><td class="paramname">buffer</td><td>A pointer to a buffer that receives the contents from the address space of the specified process.</td></tr>
    <tr><td class="paramname">size</td><td>The number of bytes to be read from the specified process.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns an NTSTATUS success or error code.</dd></dl>

</div>
</div>
<a id="a2e26eadcc1bd147c4803b7c94d55aef4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e26eadcc1bd147c4803b7c94d55aef4">&#9670;&nbsp;</a></span>NtReadVirtualMemory&lt; T &gt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint <a class="el" href="class_process_memory_utilities_1_1_native_1_1_nt_dll.html#a5452370c265199e375a6e11c4aa6e17c">ProcessMemoryUtilities.Native.NtDll.NtReadVirtualMemory</a>&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>baseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ref T&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>ReadProcessMemory copies the data in the specified address range from the address space of the specified process into the specified buffer of the current process. Any process that has a handle with PROCESS_VM_READ access can call the function. The entire area to be read must be accessible, and if it is not accessible, the function fails. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A handle to the process with memory that is being read. The handle must have PROCESS_VM_READ access to the process.</td></tr>
    <tr><td class="paramname">baseAddress</td><td>A pointer to the base address in the specified process from which to read. Before any data transfer occurs, the system verifies that all data in the base address and memory of the specified size is accessible for read access, and if it is not accessible the function fails.</td></tr>
    <tr><td class="paramname">buffer</td><td>A pointer to a buffer that receives the contents from the address space of the specified process.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns an NTSTATUS success or error code.</dd></dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>unmanaged</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="a451e9c5b938fd0c3f6c37d3366791d43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a451e9c5b938fd0c3f6c37d3366791d43">&#9670;&nbsp;</a></span>NtReadVirtualMemory&lt; T &gt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint <a class="el" href="class_process_memory_utilities_1_1_native_1_1_nt_dll.html#a5452370c265199e375a6e11c4aa6e17c">ProcessMemoryUtilities.Native.NtDll.NtReadVirtualMemory</a>&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>baseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ref T&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out IntPtr&#160;</td>
          <td class="paramname"><em>numberOfBytesRead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>ReadProcessMemory copies the data in the specified address range from the address space of the specified process into the specified buffer of the current process. Any process that has a handle with PROCESS_VM_READ access can call the function. The entire area to be read must be accessible, and if it is not accessible, the function fails. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A handle to the process with memory that is being read. The handle must have PROCESS_VM_READ access to the process.</td></tr>
    <tr><td class="paramname">baseAddress</td><td>A pointer to the base address in the specified process from which to read. Before any data transfer occurs, the system verifies that all data in the base address and memory of the specified size is accessible for read access, and if it is not accessible the function fails.</td></tr>
    <tr><td class="paramname">buffer</td><td>A pointer to a buffer that receives the contents from the address space of the specified process.</td></tr>
    <tr><td class="paramname">numberOfBytesRead</td><td>A pointer to a variable that receives the number of bytes transferred into the specified buffer. If lpNumberOfBytesRead is IntPtr.Zero, the parameter is ignored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns an NTSTATUS success or error code.</dd></dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>unmanaged</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="af95ef9217cc4632dfe5e21718df2f9f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af95ef9217cc4632dfe5e21718df2f9f7">&#9670;&nbsp;</a></span>NtReadVirtualMemoryArray&lt; T &gt;() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint ProcessMemoryUtilities.Native.NtDll.NtReadVirtualMemoryArray&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>baseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T []&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>ReadProcessMemory copies the data in the specified address range from the address space of the specified process into the specified buffer of the current process. Any process that has a handle with PROCESS_VM_READ access can call the function. The entire area to be read must be accessible, and if it is not accessible, the function fails. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A handle to the process with memory that is being read. The handle must have PROCESS_VM_READ access to the process.</td></tr>
    <tr><td class="paramname">baseAddress</td><td>A pointer to the base address in the specified process from which to read. Before any data transfer occurs, the system verifies that all data in the base address and memory of the specified size is accessible for read access, and if it is not accessible the function fails.</td></tr>
    <tr><td class="paramname">buffer</td><td>A pointer to a buffer that receives the contents from the address space of the specified process.</td></tr>
    <tr><td class="paramname">offset</td><td>A byte offset from inside the array to copy to.</td></tr>
    <tr><td class="paramname">length</td><td>The number of bytes to copy to the array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns an NTSTATUS success or error code.</dd></dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>unmanaged</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="add7ab85c7888c406e9a7bb0fcd0e314a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add7ab85c7888c406e9a7bb0fcd0e314a">&#9670;&nbsp;</a></span>NtReadVirtualMemoryArray&lt; T &gt;() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint ProcessMemoryUtilities.Native.NtDll.NtReadVirtualMemoryArray&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>baseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T []&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out IntPtr&#160;</td>
          <td class="paramname"><em>numberOfBytesRead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>ReadProcessMemory copies the data in the specified address range from the address space of the specified process into the specified buffer of the current process. Any process that has a handle with PROCESS_VM_READ access can call the function. The entire area to be read must be accessible, and if it is not accessible, the function fails. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A handle to the process with memory that is being read. The handle must have PROCESS_VM_READ access to the process.</td></tr>
    <tr><td class="paramname">baseAddress</td><td>A pointer to the base address in the specified process from which to read. Before any data transfer occurs, the system verifies that all data in the base address and memory of the specified size is accessible for read access, and if it is not accessible the function fails.</td></tr>
    <tr><td class="paramname">buffer</td><td>A pointer to a buffer that receives the contents from the address space of the specified process.</td></tr>
    <tr><td class="paramname">offset</td><td>A byte offset from inside the array to copy to.</td></tr>
    <tr><td class="paramname">length</td><td>The number of bytes to copy to the array.</td></tr>
    <tr><td class="paramname">numberOfBytesRead</td><td>A pointer to a variable that receives the number of bytes transferred into the specified buffer. If lpNumberOfBytesRead is IntPtr.Zero, the parameter is ignored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns an NTSTATUS success or error code.</dd></dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>unmanaged</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="af8d1a2e707e10af2da946bf0d03ef259"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8d1a2e707e10af2da946bf0d03ef259">&#9670;&nbsp;</a></span>NtReadVirtualMemoryArray&lt; T &gt;() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint ProcessMemoryUtilities.Native.NtDll.NtReadVirtualMemoryArray&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>baseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T []&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>ReadProcessMemory copies the data in the specified address range from the address space of the specified process into the specified buffer of the current process. Any process that has a handle with PROCESS_VM_READ access can call the function. The entire area to be read must be accessible, and if it is not accessible, the function fails. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A handle to the process with memory that is being read. The handle must have PROCESS_VM_READ access to the process.</td></tr>
    <tr><td class="paramname">baseAddress</td><td>A pointer to the base address in the specified process from which to read. Before any data transfer occurs, the system verifies that all data in the base address and memory of the specified size is accessible for read access, and if it is not accessible the function fails.</td></tr>
    <tr><td class="paramname">buffer</td><td>A pointer to a buffer that receives the contents from the address space of the specified process.</td></tr>
    <tr><td class="paramname">offset</td><td>A byte offset from inside the array to copy to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns an NTSTATUS success or error code.</dd></dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>unmanaged</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>NtReadVirtualMemoryArray</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>handle</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>baseAddress</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>buffer</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>offset</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>buffer.Length</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>offset</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="a624275e9caf0ed4306b87d6cbb45f703"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a624275e9caf0ed4306b87d6cbb45f703">&#9670;&nbsp;</a></span>NtReadVirtualMemoryArray&lt; T &gt;() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint ProcessMemoryUtilities.Native.NtDll.NtReadVirtualMemoryArray&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>baseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T []&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out IntPtr&#160;</td>
          <td class="paramname"><em>numberOfBytesRead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>ReadProcessMemory copies the data in the specified address range from the address space of the specified process into the specified buffer of the current process. Any process that has a handle with PROCESS_VM_READ access can call the function. The entire area to be read must be accessible, and if it is not accessible, the function fails. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A handle to the process with memory that is being read. The handle must have PROCESS_VM_READ access to the process.</td></tr>
    <tr><td class="paramname">baseAddress</td><td>A pointer to the base address in the specified process from which to read. Before any data transfer occurs, the system verifies that all data in the base address and memory of the specified size is accessible for read access, and if it is not accessible the function fails.</td></tr>
    <tr><td class="paramname">buffer</td><td>A pointer to a buffer that receives the contents from the address space of the specified process.</td></tr>
    <tr><td class="paramname">offset</td><td>A byte offset from inside the array to copy to.</td></tr>
    <tr><td class="paramname">numberOfBytesRead</td><td>A pointer to a variable that receives the number of bytes transferred into the specified buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns an NTSTATUS success or error code.</dd></dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>unmanaged</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>NtReadVirtualMemoryArray</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>handle</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>baseAddress</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>buffer</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>offset</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>buffer.Length</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>offset</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>out</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>numberOfBytesRead</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="af5cc931ed3f232600ab34b9198548c9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5cc931ed3f232600ab34b9198548c9d">&#9670;&nbsp;</a></span>NtReadVirtualMemoryArray&lt; T &gt;() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint ProcessMemoryUtilities.Native.NtDll.NtReadVirtualMemoryArray&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>baseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T []&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>ReadProcessMemory copies the data in the specified address range from the address space of the specified process into the specified buffer of the current process. Any process that has a handle with PROCESS_VM_READ access can call the function. The entire area to be read must be accessible, and if it is not accessible, the function fails. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A handle to the process with memory that is being read. The handle must have PROCESS_VM_READ access to the process.</td></tr>
    <tr><td class="paramname">baseAddress</td><td>A pointer to the base address in the specified process from which to read. Before any data transfer occurs, the system verifies that all data in the base address and memory of the specified size is accessible for read access, and if it is not accessible the function fails.</td></tr>
    <tr><td class="paramname">buffer</td><td>A pointer to a buffer that receives the contents from the address space of the specified process.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns an NTSTATUS success or error code.</dd></dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>unmanaged</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>NtReadVirtualMemoryArray</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>handle</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>baseAddress</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>buffer</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>buffer.Length</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="ae9aac5cdf02e55421b21697af810c6ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9aac5cdf02e55421b21697af810c6ea">&#9670;&nbsp;</a></span>NtReadVirtualMemoryArray&lt; T &gt;() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint ProcessMemoryUtilities.Native.NtDll.NtReadVirtualMemoryArray&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>baseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T []&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out IntPtr&#160;</td>
          <td class="paramname"><em>numberOfBytesRead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>ReadProcessMemory copies the data in the specified address range from the address space of the specified process into the specified buffer of the current process. Any process that has a handle with PROCESS_VM_READ access can call the function. The entire area to be read must be accessible, and if it is not accessible, the function fails. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A handle to the process with memory that is being read. The handle must have PROCESS_VM_READ access to the process.</td></tr>
    <tr><td class="paramname">baseAddress</td><td>A pointer to the base address in the specified process from which to read. Before any data transfer occurs, the system verifies that all data in the base address and memory of the specified size is accessible for read access, and if it is not accessible the function fails.</td></tr>
    <tr><td class="paramname">buffer</td><td>A pointer to a buffer that receives the contents from the address space of the specified process.</td></tr>
    <tr><td class="paramname">numberOfBytesRead</td><td>A pointer to a variable that receives the number of bytes transferred into the specified buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns an NTSTATUS success or error code.</dd></dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>unmanaged</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>NtReadVirtualMemoryArray</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>handle</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>baseAddress</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>buffer</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>buffer.Length</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>out</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>numberOfBytesRead</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="a784e4099a4e82214e3f0d860467bb50a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a784e4099a4e82214e3f0d860467bb50a">&#9670;&nbsp;</a></span>NtReadVirtualMemoryPartial&lt; T &gt;() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint ProcessMemoryUtilities.Native.NtDll.NtReadVirtualMemoryPartial&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>baseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ref T&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>ReadProcessMemory copies the data in the specified address range from the address space of the specified process into the specified buffer of the current process. Any process that has a handle with PROCESS_VM_READ access can call the function. The entire area to be read must be accessible, and if it is not accessible, the function fails. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A handle to the process with memory that is being read. The handle must have PROCESS_VM_READ access to the process.</td></tr>
    <tr><td class="paramname">baseAddress</td><td>A pointer to the base address in the specified process from which to read. Before any data transfer occurs, the system verifies that all data in the base address and memory of the specified size is accessible for read access, and if it is not accessible the function fails.</td></tr>
    <tr><td class="paramname">buffer</td><td>A pointer to a buffer that receives the contents from the address space of the specified process.</td></tr>
    <tr><td class="paramname">offset</td><td>A byte offset from the start of the buffer.</td></tr>
    <tr><td class="paramname">length</td><td>The number of bytes to copy to the buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns an NTSTATUS success or error code.</dd></dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>unmanaged</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="ae6a288474c6a814634e77c11db009fab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6a288474c6a814634e77c11db009fab">&#9670;&nbsp;</a></span>NtReadVirtualMemoryPartial&lt; T &gt;() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint ProcessMemoryUtilities.Native.NtDll.NtReadVirtualMemoryPartial&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>baseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ref T&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out IntPtr&#160;</td>
          <td class="paramname"><em>numberOfBytesRead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>ReadProcessMemory copies the data in the specified address range from the address space of the specified process into the specified buffer of the current process. Any process that has a handle with PROCESS_VM_READ access can call the function. The entire area to be read must be accessible, and if it is not accessible, the function fails. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A handle to the process with memory that is being read. The handle must have PROCESS_VM_READ access to the process.</td></tr>
    <tr><td class="paramname">baseAddress</td><td>A pointer to the base address in the specified process from which to read. Before any data transfer occurs, the system verifies that all data in the base address and memory of the specified size is accessible for read access, and if it is not accessible the function fails.</td></tr>
    <tr><td class="paramname">buffer</td><td>A pointer to a buffer that receives the contents from the address space of the specified process.</td></tr>
    <tr><td class="paramname">offset</td><td>A byte offset from the start of the buffer.</td></tr>
    <tr><td class="paramname">length</td><td>The number of bytes to copy to the buffer.</td></tr>
    <tr><td class="paramname">numberOfBytesRead</td><td>A pointer to a variable that receives the number of bytes transferred into the specified buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns an NTSTATUS success or error code.</dd></dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>unmanaged</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="a11ea85527ac4e707d06dd93300c36d95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11ea85527ac4e707d06dd93300c36d95">&#9670;&nbsp;</a></span>NtReadVirtualMemoryPartial&lt; T &gt;() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint ProcessMemoryUtilities.Native.NtDll.NtReadVirtualMemoryPartial&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>baseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ref T&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>ReadProcessMemory copies the data in the specified address range from the address space of the specified process into the specified buffer of the current process. Any process that has a handle with PROCESS_VM_READ access can call the function. The entire area to be read must be accessible, and if it is not accessible, the function fails. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A handle to the process with memory that is being read. The handle must have PROCESS_VM_READ access to the process.</td></tr>
    <tr><td class="paramname">baseAddress</td><td>A pointer to the base address in the specified process from which to read. Before any data transfer occurs, the system verifies that all data in the base address and memory of the specified size is accessible for read access, and if it is not accessible the function fails.</td></tr>
    <tr><td class="paramname">buffer</td><td>A pointer to a buffer that receives the contents from the address space of the specified process.</td></tr>
    <tr><td class="paramname">offset</td><td>A byte offset from the start of the buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns an NTSTATUS success or error code.</dd></dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>unmanaged</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>NtReadVirtualMemoryPartial</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>handle</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>baseAddress</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>ref</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>buffer</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>offset</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>InternalHelper.SizeOf&lt;T&gt;()</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>offset</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="af8ee911091188dd8a105b0e2e4be71f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8ee911091188dd8a105b0e2e4be71f5">&#9670;&nbsp;</a></span>NtReadVirtualMemoryPartial&lt; T &gt;() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint ProcessMemoryUtilities.Native.NtDll.NtReadVirtualMemoryPartial&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>baseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ref T&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out IntPtr&#160;</td>
          <td class="paramname"><em>numberOfBytesRead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>ReadProcessMemory copies the data in the specified address range from the address space of the specified process into the specified buffer of the current process. Any process that has a handle with PROCESS_VM_READ access can call the function. The entire area to be read must be accessible, and if it is not accessible, the function fails. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A handle to the process with memory that is being read. The handle must have PROCESS_VM_READ access to the process.</td></tr>
    <tr><td class="paramname">baseAddress</td><td>A pointer to the base address in the specified process from which to read. Before any data transfer occurs, the system verifies that all data in the base address and memory of the specified size is accessible for read access, and if it is not accessible the function fails.</td></tr>
    <tr><td class="paramname">buffer</td><td>A pointer to a buffer that receives the contents from the address space of the specified process.</td></tr>
    <tr><td class="paramname">offset</td><td>A byte offset from the start of the buffer.</td></tr>
    <tr><td class="paramname">numberOfBytesRead</td><td>A pointer to a variable that receives the number of bytes transferred into the specified buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns an NTSTATUS success or error code.</dd></dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>unmanaged</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>NtReadVirtualMemoryPartial</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>handle</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>baseAddress</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>ref</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>buffer</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>offset</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>InternalHelper.SizeOf&lt;T&gt;()</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>offset</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>out</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>numberOfBytesRead</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="a1a13a9c8abe715e084c32c1c85b6e8c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a13a9c8abe715e084c32c1c85b6e8c9">&#9670;&nbsp;</a></span>NtSuccess()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool ProcessMemoryUtilities.Native.NtDll.NtSuccess </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the specified NTSTATUS is a success or informational type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>A NTSTATUS value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the specified NTSTATUS is a success or informational type.</dd></dl>

</div>
</div>
<a id="a17b6a73c98659b634bdf307c474d8fb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17b6a73c98659b634bdf307c474d8fb8">&#9670;&nbsp;</a></span>NtSuccessOnly()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool ProcessMemoryUtilities.Native.NtDll.NtSuccessOnly </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the specified NTSTATUS is a success type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>A NTSTATUS value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the specified NTSTATUS is a success type.</dd></dl>

</div>
</div>
<a id="a4dcb983defbb18bc69ba05f46cc4c68a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dcb983defbb18bc69ba05f46cc4c68a">&#9670;&nbsp;</a></span>NtWarning()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool ProcessMemoryUtilities.Native.NtDll.NtWarning </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the specified NTSTATUS is a warning type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>A NTSTATUS value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the specified NTSTATUS is a warning type.</dd></dl>

</div>
</div>
<a id="afc3b76c71aa2037f15a16079de57b433"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc3b76c71aa2037f15a16079de57b433">&#9670;&nbsp;</a></span>NtWriteVirtualMemory() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint ProcessMemoryUtilities.Native.NtDll.NtWriteVirtualMemory </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>baseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>numberOfBytesWritten</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>WriteProcessMemory copies the data from the specified buffer in the current process to the address range of the specified process. Any process that has a handle with PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process to be written to can call the function. Typically but not always, the process with address space that is being written to is being debugged. The entire area to be written to must be accessible, and if it is not accessible, the function fails. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A handle to the process memory to be modified. The handle must have PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process.</td></tr>
    <tr><td class="paramname">baseAddress</td><td>A pointer to the base address in the specified process to which data is written. Before data transfer occurs, the system verifies that all data in the base address and memory of the specified size is accessible for write access, and if it is not accessible, the function fails.</td></tr>
    <tr><td class="paramname">buffer</td><td>A pointer to the buffer that contains data to be written in the address space of the specified process.</td></tr>
    <tr><td class="paramname">size</td><td>The number of bytes to be written to the specified process.</td></tr>
    <tr><td class="paramname">numberOfBytesWritten</td><td>A pointer to a variable that receives the number of bytes transferred into the specified process. This parameter is optional. If lpNumberOfBytesWritten is IntPtr.Zero, the parameter is ignored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns an NTSTATUS success or error code.</dd></dl>

</div>
</div>
<a id="ab3b4046237e2fa9b9b67d5bd171dfa37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3b4046237e2fa9b9b67d5bd171dfa37">&#9670;&nbsp;</a></span>NtWriteVirtualMemory() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint ProcessMemoryUtilities.Native.NtDll.NtWriteVirtualMemory </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>baseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out IntPtr&#160;</td>
          <td class="paramname"><em>numberOfBytesWritten</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>WriteProcessMemory copies the data from the specified buffer in the current process to the address range of the specified process. Any process that has a handle with PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process to be written to can call the function. Typically but not always, the process with address space that is being written to is being debugged. The entire area to be written to must be accessible, and if it is not accessible, the function fails. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A handle to the process memory to be modified. The handle must have PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process.</td></tr>
    <tr><td class="paramname">baseAddress</td><td>A pointer to the base address in the specified process to which data is written. Before data transfer occurs, the system verifies that all data in the base address and memory of the specified size is accessible for write access, and if it is not accessible, the function fails.</td></tr>
    <tr><td class="paramname">buffer</td><td>A pointer to the buffer that contains data to be written in the address space of the specified process.</td></tr>
    <tr><td class="paramname">size</td><td>The number of bytes to be written to the specified process.</td></tr>
    <tr><td class="paramname">numberOfBytesWritten</td><td>A pointer to a variable that receives the number of bytes transferred into the specified buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns an NTSTATUS success or error code.</dd></dl>

</div>
</div>
<a id="a3cf63ae337ed6239ebe8a712a98ebc48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cf63ae337ed6239ebe8a712a98ebc48">&#9670;&nbsp;</a></span>NtWriteVirtualMemory() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint ProcessMemoryUtilities.Native.NtDll.NtWriteVirtualMemory </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>baseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>WriteProcessMemory copies the data from the specified buffer in the current process to the address range of the specified process. Any process that has a handle with PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process to be written to can call the function. Typically but not always, the process with address space that is being written to is being debugged. The entire area to be written to must be accessible, and if it is not accessible, the function fails. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A handle to the process memory to be modified. The handle must have PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process.</td></tr>
    <tr><td class="paramname">baseAddress</td><td>A pointer to the base address in the specified process to which data is written. Before data transfer occurs, the system verifies that all data in the base address and memory of the specified size is accessible for write access, and if it is not accessible, the function fails.</td></tr>
    <tr><td class="paramname">buffer</td><td>A pointer to the buffer that contains data to be written in the address space of the specified process.</td></tr>
    <tr><td class="paramname">size</td><td>The number of bytes to be written to the specified process.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns an NTSTATUS success or error code.</dd></dl>

</div>
</div>
<a id="a77120a88bf74554776c3b99fc140c742"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77120a88bf74554776c3b99fc140c742">&#9670;&nbsp;</a></span>NtWriteVirtualMemory&lt; T &gt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint <a class="el" href="class_process_memory_utilities_1_1_native_1_1_nt_dll.html#afc3b76c71aa2037f15a16079de57b433">ProcessMemoryUtilities.Native.NtDll.NtWriteVirtualMemory</a>&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>baseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ref T&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>WriteProcessMemory copies the data from the specified buffer in the current process to the address range of the specified process. Any process that has a handle with PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process to be written to can call the function. Typically but not always, the process with address space that is being written to is being debugged. The entire area to be written to must be accessible, and if it is not accessible, the function fails. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A handle to the process memory to be modified. The handle must have PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process.</td></tr>
    <tr><td class="paramname">baseAddress</td><td>A pointer to the base address in the specified process to which data is written. Before data transfer occurs, the system verifies that all data in the base address and memory of the specified size is accessible for write access, and if it is not accessible, the function fails.</td></tr>
    <tr><td class="paramname">buffer</td><td>A pointer to the buffer that contains data to be written in the address space of the specified process.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns an NTSTATUS success or error code.</dd></dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>unmanaged</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="ae439e711d12a805df3e498b9d78d37b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae439e711d12a805df3e498b9d78d37b2">&#9670;&nbsp;</a></span>NtWriteVirtualMemory&lt; T &gt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint <a class="el" href="class_process_memory_utilities_1_1_native_1_1_nt_dll.html#afc3b76c71aa2037f15a16079de57b433">ProcessMemoryUtilities.Native.NtDll.NtWriteVirtualMemory</a>&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>baseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ref T&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out IntPtr&#160;</td>
          <td class="paramname"><em>numberOfBytesWritten</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>WriteProcessMemory copies the data from the specified buffer in the current process to the address range of the specified process. Any process that has a handle with PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process to be written to can call the function. Typically but not always, the process with address space that is being written to is being debugged. The entire area to be written to must be accessible, and if it is not accessible, the function fails. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A handle to the process memory to be modified. The handle must have PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process.</td></tr>
    <tr><td class="paramname">baseAddress</td><td>A pointer to the base address in the specified process to which data is written. Before data transfer occurs, the system verifies that all data in the base address and memory of the specified size is accessible for write access, and if it is not accessible, the function fails.</td></tr>
    <tr><td class="paramname">buffer</td><td>A pointer to the buffer that contains data to be written in the address space of the specified process.</td></tr>
    <tr><td class="paramname">numberOfBytesWritten</td><td>A pointer to a variable that receives the number of bytes transferred into the specified process. This parameter is optional. If lpNumberOfBytesWritten is IntPtr.Zero, the parameter is ignored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns an NTSTATUS success or error code.</dd></dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>unmanaged</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="a804ef50512b5815fa6f5913feb929e59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a804ef50512b5815fa6f5913feb929e59">&#9670;&nbsp;</a></span>NtWriteVirtualMemoryArray&lt; T &gt;() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint ProcessMemoryUtilities.Native.NtDll.NtWriteVirtualMemoryArray&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>baseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T []&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>WriteProcessMemory copies the data from the specified buffer in the current process to the address range of the specified process. Any process that has a handle with PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process to be written to can call the function. Typically but not always, the process with address space that is being written to is being debugged. The entire area to be written to must be accessible, and if it is not accessible, the function fails. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A handle to the process memory to be modified. The handle must have PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process.</td></tr>
    <tr><td class="paramname">baseAddress</td><td>A pointer to the base address in the specified process to which data is written. Before data transfer occurs, the system verifies that all data in the base address and memory of the specified size is accessible for write access, and if it is not accessible, the function fails.</td></tr>
    <tr><td class="paramname">buffer</td><td>A pointer to the buffer that contains data to be written in the address space of the specified process.</td></tr>
    <tr><td class="paramname">offset</td><td>A byte offset from inside the array to copy from.</td></tr>
    <tr><td class="paramname">length</td><td>The number of bytes to copy from the array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns an NTSTATUS success or error code.</dd></dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>unmanaged</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="a631e466d0e1e4e3e84b5aeb02d511b2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a631e466d0e1e4e3e84b5aeb02d511b2e">&#9670;&nbsp;</a></span>NtWriteVirtualMemoryArray&lt; T &gt;() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint ProcessMemoryUtilities.Native.NtDll.NtWriteVirtualMemoryArray&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>baseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T []&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out IntPtr&#160;</td>
          <td class="paramname"><em>numberOfBytesWritten</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>WriteProcessMemory copies the data from the specified buffer in the current process to the address range of the specified process. Any process that has a handle with PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process to be written to can call the function. Typically but not always, the process with address space that is being written to is being debugged. The entire area to be written to must be accessible, and if it is not accessible, the function fails. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A handle to the process memory to be modified. The handle must have PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process.</td></tr>
    <tr><td class="paramname">baseAddress</td><td>A pointer to the base address in the specified process to which data is written. Before data transfer occurs, the system verifies that all data in the base address and memory of the specified size is accessible for write access, and if it is not accessible, the function fails.</td></tr>
    <tr><td class="paramname">buffer</td><td>A pointer to the buffer that contains data to be written in the address space of the specified process.</td></tr>
    <tr><td class="paramname">offset</td><td>A byte offset from inside the array to copy from.</td></tr>
    <tr><td class="paramname">length</td><td>The number of bytes to copy from the array.</td></tr>
    <tr><td class="paramname">numberOfBytesWritten</td><td>A pointer to a variable that receives the number of bytes transferred into the specified process. This parameter is optional. If lpNumberOfBytesWritten is IntPtr.Zero, the parameter is ignored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns an NTSTATUS success or error code.</dd></dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>unmanaged</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="abf205dc691b5544105f51cb4bb663238"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf205dc691b5544105f51cb4bb663238">&#9670;&nbsp;</a></span>NtWriteVirtualMemoryArray&lt; T &gt;() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint ProcessMemoryUtilities.Native.NtDll.NtWriteVirtualMemoryArray&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>baseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T []&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>WriteProcessMemory copies the data from the specified buffer in the current process to the address range of the specified process. Any process that has a handle with PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process to be written to can call the function. Typically but not always, the process with address space that is being written to is being debugged. The entire area to be written to must be accessible, and if it is not accessible, the function fails. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A handle to the process memory to be modified. The handle must have PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process.</td></tr>
    <tr><td class="paramname">baseAddress</td><td>A pointer to the base address in the specified process to which data is written. Before data transfer occurs, the system verifies that all data in the base address and memory of the specified size is accessible for write access, and if it is not accessible, the function fails.</td></tr>
    <tr><td class="paramname">buffer</td><td>A pointer to the buffer that contains data to be written in the address space of the specified process.</td></tr>
    <tr><td class="paramname">offset</td><td>A byte offset from inside the array to copy from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns an NTSTATUS success or error code.</dd></dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>unmanaged</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>NtWriteVirtualMemoryArray</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>handle</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>baseAddress</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>buffer</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>offset</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>buffer.Length</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>offset</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="a1eadcfabedef350bc33e228d99c0f1ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1eadcfabedef350bc33e228d99c0f1ae">&#9670;&nbsp;</a></span>NtWriteVirtualMemoryArray&lt; T &gt;() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint ProcessMemoryUtilities.Native.NtDll.NtWriteVirtualMemoryArray&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>baseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T []&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out IntPtr&#160;</td>
          <td class="paramname"><em>numberOfBytesWritten</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>WriteProcessMemory copies the data from the specified buffer in the current process to the address range of the specified process. Any process that has a handle with PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process to be written to can call the function. Typically but not always, the process with address space that is being written to is being debugged. The entire area to be written to must be accessible, and if it is not accessible, the function fails. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A handle to the process memory to be modified. The handle must have PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process.</td></tr>
    <tr><td class="paramname">baseAddress</td><td>A pointer to the base address in the specified process to which data is written. Before data transfer occurs, the system verifies that all data in the base address and memory of the specified size is accessible for write access, and if it is not accessible, the function fails.</td></tr>
    <tr><td class="paramname">buffer</td><td>A pointer to the buffer that contains data to be written in the address space of the specified process.</td></tr>
    <tr><td class="paramname">offset</td><td>A byte offset from inside the array to copy from.</td></tr>
    <tr><td class="paramname">numberOfBytesWritten</td><td>A pointer to a variable that receives the number of bytes transferred into the specified buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns an NTSTATUS success or error code.</dd></dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>unmanaged</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>NtWriteVirtualMemoryArray</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>handle</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>baseAddress</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>buffer</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>offset</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>buffer.Length</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>offset</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>out</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>numberOfBytesWritten</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="a8d1b8b6a91cee2f98861779a7137abb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d1b8b6a91cee2f98861779a7137abb8">&#9670;&nbsp;</a></span>NtWriteVirtualMemoryArray&lt; T &gt;() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint ProcessMemoryUtilities.Native.NtDll.NtWriteVirtualMemoryArray&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>baseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T []&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>WriteProcessMemory copies the data from the specified buffer in the current process to the address range of the specified process. Any process that has a handle with PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process to be written to can call the function. Typically but not always, the process with address space that is being written to is being debugged. The entire area to be written to must be accessible, and if it is not accessible, the function fails. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A handle to the process memory to be modified. The handle must have PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process.</td></tr>
    <tr><td class="paramname">baseAddress</td><td>A pointer to the base address in the specified process to which data is written. Before data transfer occurs, the system verifies that all data in the base address and memory of the specified size is accessible for write access, and if it is not accessible, the function fails.</td></tr>
    <tr><td class="paramname">buffer</td><td>A pointer to the buffer that contains data to be written in the address space of the specified process.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns an NTSTATUS success or error code.</dd></dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>unmanaged</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>NtWriteVirtualMemoryArray</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>handle</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>baseAddress</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>buffer</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>buffer.Length</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="a5623ae258b5dd0d21b2c49bf89396d17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5623ae258b5dd0d21b2c49bf89396d17">&#9670;&nbsp;</a></span>NtWriteVirtualMemoryArray&lt; T &gt;() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint ProcessMemoryUtilities.Native.NtDll.NtWriteVirtualMemoryArray&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>baseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T []&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out IntPtr&#160;</td>
          <td class="paramname"><em>numberOfBytesWritten</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>WriteProcessMemory copies the data from the specified buffer in the current process to the address range of the specified process. Any process that has a handle with PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process to be written to can call the function. Typically but not always, the process with address space that is being written to is being debugged. The entire area to be written to must be accessible, and if it is not accessible, the function fails. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A handle to the process memory to be modified. The handle must have PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process.</td></tr>
    <tr><td class="paramname">baseAddress</td><td>A pointer to the base address in the specified process to which data is written. Before data transfer occurs, the system verifies that all data in the base address and memory of the specified size is accessible for write access, and if it is not accessible, the function fails.</td></tr>
    <tr><td class="paramname">buffer</td><td>A pointer to the buffer that contains data to be written in the address space of the specified process.</td></tr>
    <tr><td class="paramname">numberOfBytesWritten</td><td>A pointer to a variable that receives the number of bytes transferred into the specified buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns an NTSTATUS success or error code.</dd></dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>unmanaged</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>NtWriteVirtualMemoryArray</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>handle</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>baseAddress</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>buffer</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>buffer.Length</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>out</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>numberOfBytesWritten</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="a9eda4f3f1b41a9f379c44eb579c6c3f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9eda4f3f1b41a9f379c44eb579c6c3f5">&#9670;&nbsp;</a></span>NtWriteVirtualMemoryPartial&lt; T &gt;() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint ProcessMemoryUtilities.Native.NtDll.NtWriteVirtualMemoryPartial&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>baseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ref T&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>WriteProcessMemory copies the data from the specified buffer in the current process to the address range of the specified process. Any process that has a handle with PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process to be written to can call the function. Typically but not always, the process with address space that is being written to is being debugged. The entire area to be written to must be accessible, and if it is not accessible, the function fails. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A handle to the process memory to be modified. The handle must have PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process.</td></tr>
    <tr><td class="paramname">baseAddress</td><td>A pointer to the base address in the specified process to which data is written. Before data transfer occurs, the system verifies that all data in the base address and memory of the specified size is accessible for write access, and if it is not accessible, the function fails.</td></tr>
    <tr><td class="paramname">buffer</td><td>A pointer to the buffer that contains data to be written in the address space of the specified process.</td></tr>
    <tr><td class="paramname">offset</td><td>A byte offset from the start of the buffer.</td></tr>
    <tr><td class="paramname">length</td><td>The number of bytes to copy to the buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns an NTSTATUS success or error code.</dd></dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>unmanaged</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="a341df8038f54311f460e7e576d23ea1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a341df8038f54311f460e7e576d23ea1c">&#9670;&nbsp;</a></span>NtWriteVirtualMemoryPartial&lt; T &gt;() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint ProcessMemoryUtilities.Native.NtDll.NtWriteVirtualMemoryPartial&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>baseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ref T&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out IntPtr&#160;</td>
          <td class="paramname"><em>numberOfBytesWritten</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>WriteProcessMemory copies the data from the specified buffer in the current process to the address range of the specified process. Any process that has a handle with PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process to be written to can call the function. Typically but not always, the process with address space that is being written to is being debugged. The entire area to be written to must be accessible, and if it is not accessible, the function fails. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A handle to the process memory to be modified. The handle must have PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process.</td></tr>
    <tr><td class="paramname">baseAddress</td><td>A pointer to the base address in the specified process to which data is written. Before data transfer occurs, the system verifies that all data in the base address and memory of the specified size is accessible for write access, and if it is not accessible, the function fails.</td></tr>
    <tr><td class="paramname">buffer</td><td>A pointer to the buffer that contains data to be written in the address space of the specified process.</td></tr>
    <tr><td class="paramname">offset</td><td>A byte offset from the start of the buffer.</td></tr>
    <tr><td class="paramname">length</td><td>The number of bytes to copy to the buffer.</td></tr>
    <tr><td class="paramname">numberOfBytesWritten</td><td>A pointer to a variable that receives the number of bytes transferred into the specified buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns an NTSTATUS success or error code.</dd></dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>unmanaged</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="a7ccd0899e60fc5507c08cea784d2c40d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ccd0899e60fc5507c08cea784d2c40d">&#9670;&nbsp;</a></span>NtWriteVirtualMemoryPartial&lt; T &gt;() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint ProcessMemoryUtilities.Native.NtDll.NtWriteVirtualMemoryPartial&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>baseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ref T&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>WriteProcessMemory copies the data from the specified buffer in the current process to the address range of the specified process. Any process that has a handle with PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process to be written to can call the function. Typically but not always, the process with address space that is being written to is being debugged. The entire area to be written to must be accessible, and if it is not accessible, the function fails. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A handle to the process memory to be modified. The handle must have PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process.</td></tr>
    <tr><td class="paramname">baseAddress</td><td>A pointer to the base address in the specified process to which data is written. Before data transfer occurs, the system verifies that all data in the base address and memory of the specified size is accessible for write access, and if it is not accessible, the function fails.</td></tr>
    <tr><td class="paramname">buffer</td><td>A pointer to the buffer that contains data to be written in the address space of the specified process.</td></tr>
    <tr><td class="paramname">offset</td><td>A byte offset from the start of the buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns an NTSTATUS success or error code.</dd></dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>unmanaged</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>NtWriteVirtualMemoryPartial</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>handle</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>baseAddress</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>ref</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>buffer</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>offset</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>InternalHelper.SizeOf&lt;T&gt;()</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>offset</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="a064e46588f39e98f413483da51647d48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a064e46588f39e98f413483da51647d48">&#9670;&nbsp;</a></span>NtWriteVirtualMemoryPartial&lt; T &gt;() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint ProcessMemoryUtilities.Native.NtDll.NtWriteVirtualMemoryPartial&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntPtr&#160;</td>
          <td class="paramname"><em>baseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ref T&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out IntPtr&#160;</td>
          <td class="paramname"><em>numberOfBytesWritten</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>WriteProcessMemory copies the data from the specified buffer in the current process to the address range of the specified process. Any process that has a handle with PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process to be written to can call the function. Typically but not always, the process with address space that is being written to is being debugged. The entire area to be written to must be accessible, and if it is not accessible, the function fails. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A handle to the process memory to be modified. The handle must have PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process.</td></tr>
    <tr><td class="paramname">baseAddress</td><td>A pointer to the base address in the specified process to which data is written. Before data transfer occurs, the system verifies that all data in the base address and memory of the specified size is accessible for write access, and if it is not accessible, the function fails.</td></tr>
    <tr><td class="paramname">buffer</td><td>A pointer to the buffer that contains data to be written in the address space of the specified process.</td></tr>
    <tr><td class="paramname">offset</td><td>A byte offset from the start of the buffer.</td></tr>
    <tr><td class="paramname">numberOfBytesWritten</td><td>A pointer to a variable that receives the number of bytes transferred into the specified buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns an NTSTATUS success or error code.</dd></dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>unmanaged</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>NtWriteVirtualMemoryPartial</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>handle</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>baseAddress</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>ref</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>buffer</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>offset</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>InternalHelper.SizeOf&lt;T&gt;()</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>offset</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>out</em></td><td>&#160;</td></tr>
<tr><td valign="top"><em>T</em></td><td>&#160;:</td><td valign="top"><em>numberOfBytesWritten</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="a258cefa755a564efd38ba09d31fffdb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a258cefa755a564efd38ba09d31fffdb6">&#9670;&nbsp;</a></span>RtlNtStatusToDosError()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint ProcessMemoryUtilities.Native.NtDll.RtlNtStatusToDosError </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts the specified NTSTATUS code to its equivalent system error code. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The NTSTATUS code to be converted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The function returns the corresponding system error code.</dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>NtDll.cs</li>
<li>NtDll.OP.cs</li>
<li>NtDll.RVM.cs</li>
<li>NtDll.V.cs</li>
<li>NtDll.WVM.cs</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_process_memory_utilities.html">ProcessMemoryUtilities</a></li><li class="navelem"><a class="el" href="namespace_process_memory_utilities_1_1_native.html">Native</a></li><li class="navelem"><a class="el" href="class_process_memory_utilities_1_1_native_1_1_nt_dll.html">NtDll</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.15 </li>
  </ul>
</div>
</body>
</html>
